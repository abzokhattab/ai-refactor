{
  "correct": [
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type {\n  FirstWeekContainsDateOptions,\n  Locale,\n  LocalizedOptions,\n  WeekOptions,\n} from \"../../types.js\";\n\nexport type DefaultOptions = LocalizedOptions<keyof Locale> &\n  WeekOptions &\n  FirstWeekContainsDateOptions;\n\nlet defaultOptions: DefaultOptions = {};\n\nexport function getDefaultOptions(): DefaultOptions {\n  return defaultOptions;\n}\n\nexport function setDefaultOptions(newOptions: DefaultOptions): void {\n  defaultOptions = newOptions;\n}\n"
      },
      {
        "role": "assistant",
        "content": "import type {\n  FirstWeekContainsDateOptions,\n  Locale,\n  LocalizedOptions,\n  WeekOptions,\n} from \"../../types.js\";\n\nexport type DefaultOptions = LocalizedOptions<keyof Locale> &\n  WeekOptions &\n  FirstWeekContainsDateOptions;\n\nlet defaultOptions: DefaultOptions = {};\n\nexport function getDefaultOptions(): DefaultOptions {\n  return defaultOptions;\n}\n\nexport function setDefaultOptions(newOptions: DefaultOptions): void {\n  defaultOptions = newOptions;\n}\n\n// Extracted methods for modularity and readability\nexport function updateDefaultOptions(newOptions: DefaultOptions): void {\n  setDefaultOptions(newOptions);\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { toDate } from \"../toDate/index.js\";\n\n/**\n * @name getYear\n * @category Year Helpers\n * @summary Get the year of the given date.\n *\n * @description\n * Get the year of the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The given date\n *\n * @returns The year\n *\n * @example\n * // Which year is 2 July 2014?\n * const result = getYear(new Date(2014, 6, 2))\n * //=> 2014\n */\nexport function getYear<DateType extends Date>(\n  date: DateType | number | string,\n): number {\n  return toDate(date).getFullYear();\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { toDate } from \"../toDate/index.js\";\n\n/**\n * @name getYear\n * @category Year Helpers\n * @summary Get the year of the given date.\n *\n * @description\n * Get the year of the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The given date\n *\n * @returns The year\n *\n * @example\n * // Which year is 2 July 2014?\n * const result = getYear(new Date(2014, 6, 2))\n * //=> 2014\n */\nexport function getYear<DateType extends Date>(\n  date: DateType | number | string,\n): number {\n  return toDate(date).getFullYear();\n}\n\n/**\n * @name extractYear\n * @param date - The given date\n * @returns The year extracted from the date\n */\nfunction extractYear<DateType extends Date>(\n  date: DateType | number | string,\n): number {\n  return toDate(date).getFullYear();\n}\n\nexport { extractYear };"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatRelativeFn } from \"../../../types.js\";\n\nconst formatRelativeLocale = {\n  lastWeek: \"eeee 'الماضي عند الساعة' p\",\n  yesterday: \"'الأمس عند الساعة' p\",\n  today: \"'اليوم عند الساعة' p\",\n  tomorrow: \"'غدا عند الساعة' p\",\n  nextWeek: \"eeee 'القادم عند الساعة' p\",\n  other: \"P\",\n};\n\nexport const formatRelative: FormatRelativeFn = (token) =>\n  formatRelativeLocale[token];\n"
      },
      {
        "role": "assistant",
        "content": "import type { FormatRelativeFn } from \"../../../types.js\";\n\nconst formatRelativeLocale = {\n  lastWeek: \"eeee 'الماضي عند الساعة' p\",\n  yesterday: \"'الأمس عند الساعة' p\",\n  today: \"'اليوم عند الساعة' p\",\n  tomorrow: \"'غدا عند الساعة' p\",\n  nextWeek: \"eeee 'القادم عند الساعة' p\",\n  other: \"P\",\n};\n\nconst getFormattedRelative = (token) => {\n  return formatRelativeLocale[token];\n};\n\nexport const formatRelative: FormatRelativeFn = (token) => {\n  return getFormattedRelative(token);\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatRelativeFn } from \"../../../types.js\";\n\nconst formatRelativeLocale = {\n  lastWeek: (date: Date) => {\n    switch (date.getDay()) {\n      case 6: //Σάββατο\n        return \"'το προηγούμενο' eeee 'στις' p\";\n      default:\n        return \"'την προηγούμενη' eeee 'στις' p\";\n    }\n  },\n  yesterday: \"'χθες στις' p\",\n  today: \"'σήμερα στις' p\",\n  tomorrow: \"'αύριο στις' p\",\n  nextWeek: \"eeee 'στις' p\",\n  other: \"P\",\n};\n\nexport const formatRelative: FormatRelativeFn = (token, date) => {\n  const format = formatRelativeLocale[token];\n\n  if (typeof format === \"function\") return format(date);\n\n  return format;\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { FormatRelativeFn } from \"../../../types.js\";\n\nconst formatRelativeLocale = {\n  lastWeek: (date: Date) => {\n    switch (date.getDay()) {\n      case 6: //Σάββατο\n        return \"'το προηγούμενο' eeee 'στις' p\";\n      default:\n        return \"'την προηγούμενη' eeee 'στις' p\";\n    }\n  },\n  yesterday: \"'χθες στις' p\",\n  today: \"'σήμερα στις' p\",\n  tomorrow: \"'αύριο στις' p\",\n  nextWeek: \"eeee 'στις' p\",\n  other: \"P\",\n};\n\nconst getFormat = (token) => {\n  return formatRelativeLocale[token];\n};\n\nconst formatRelativeDate = (format, date) => {\n  if (typeof format === \"function\") return format(date);\n\n  return format;\n};\n\nexport const formatRelative: FormatRelativeFn = (token, date) => {\n  const format = getFormat(token);\n  return formatRelativeDate(format, date);\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Locale } from \"../types.js\";\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\n\n/**\n * @category Locales\n * @summary Gujarati locale (India).\n * @language Gujarati\n * @iso-639-2 guj\n * @author Manaday Mavani [@ManadayM](https://github.com/manadaym)\n */\nexport const gu: Locale = {\n  code: \"gu\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 4,\n  },\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { Locale } from \"../types.js\";\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\n\n/**\n * @category Locales\n * @summary Gujarati locale (India).\n * @language Gujarati\n * @iso-639-2 guj\n * @author Manaday Mavani [@ManadayM](https://github.com/manadaym)\n */\n\nconst getOptions = () => ({\n  weekStartsOn: 1, /* Monday */\n  firstWeekContainsDate: 4,\n});\n\nexport const gu: Locale = {\n  code: \"gu\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: getOptions(),\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatRelativeFn } from \"../../../types.js\";\n\nconst formatRelativeLocale = {\n  lastWeek: \"'Praėjusį' eeee p\",\n  yesterday: \"'Vakar' p\",\n  today: \"'Šiandien' p\",\n  tomorrow: \"'Rytoj' p\",\n  nextWeek: \"eeee p\",\n  other: \"P\",\n};\n\nexport const formatRelative: FormatRelativeFn = (\n  token,\n  _date,\n  _baseDate,\n  _options,\n) => formatRelativeLocale[token];\n"
      },
      {
        "role": "assistant",
        "content": "```javascript\nimport type { FormatRelativeFn } from \"../../../types.js\";\n\nconst formatRelativeLocale = {\n  lastWeek: \"'Praėjusį' eeee p\",\n  yesterday: \"'Vakar' p\",\n  today: \"'Šiandien' p\",\n  tomorrow: \"'Rytoj' p\",\n  nextWeek: \"eeee p\",\n  other: \"P\",\n};\n\nexport const formatRelative: FormatRelativeFn = (\n  token,\n  _date,\n  _baseDate,\n  _options,\n) => getFormattedToken(token);\n\nconst getFormattedToken = (token) => {\n  return formatRelativeLocale[token];\n};\n```"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Locale } from \"../types.js\";\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\n\n/**\n * @category Locales\n * @summary Slovenian locale.\n * @language Slovenian\n * @iso-639-2 slv\n * @author Adam Stradovnik [@Neoglyph](https://github.com/Neoglyph)\n * @author Mato Žgajner [@mzgajner](https://github.com/mzgajner)\n */\nexport const sl: Locale = {\n  code: \"sl\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 1,\n  },\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { Locale } from \"../types.js\";\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\n\nexport const sl: Locale = {\n  code: \"sl\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 1,\n  },\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { minutesInHour } from \"../constants/index.js\";\n\n/**\n * @name minutesToHours\n * @category Conversion Helpers\n * @summary Convert minutes to hours.\n *\n * @description\n * Convert a number of minutes to a full number of hours.\n *\n * @param minutes - The number of minutes to be converted\n *\n * @returns The number of minutes converted in hours\n *\n * @example\n * // Convert 140 minutes to hours:\n * const result = minutesToHours(120)\n * //=> 2\n *\n * @example\n * // It uses floor rounding:\n * const result = minutesToHours(179)\n * //=> 2\n */\nexport function minutesToHours(minutes: number): number {\n  const hours = minutes / minutesInHour;\n  return Math.trunc(hours);\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { minutesInHour } from \"../constants/index.js\";\n\n/**\n * @name minutesToHours\n * @category Conversion Helpers\n * @summary Convert minutes to hours.\n *\n * @description\n * Convert a number of minutes to a full number of hours.\n *\n * @param minutes - The number of minutes to be converted\n *\n * @returns The number of minutes converted in hours\n *\n * @example\n * // Convert 140 minutes to hours:\n * const result = minutesToHours(120)\n * //=> 2\n *\n * @example\n * // It uses floor rounding:\n * const result = minutesToHours(179)\n * //=> 2\n */\nexport function minutesToHours(minutes: number): number {\n  const hours = calculateHours(minutes);\n  return Math.trunc(hours);\n}\n\n/**\n * @name calculateHours\n * @description Calculate the number of hours from minutes.\n *\n * @param minutes - The number of minutes to be converted\n *\n * @returns The calculated hours\n */\nfunction calculateHours(minutes: number): number {\n  return minutes / minutesInHour;\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { startOfWeek } from \"../startOfWeek/index.js\";\n\n/**\n * @name startOfISOWeek\n * @category ISO Week Helpers\n * @summary Return the start of an ISO week for the given date.\n *\n * @description\n * Return the start of an ISO week for the given date.\n * The result will be in the local timezone.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The start of an ISO week\n *\n * @example\n * // The start of an ISO week for 2 September 2014 11:55:00:\n * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Mon Sep 01 2014 00:00:00\n */\nexport function startOfISOWeek<DateType extends Date>(\n  date: DateType | number | string,\n): DateType {\n  return startOfWeek(date, { weekStartsOn: 1 });\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { startOfWeek } from \"../startOfWeek/index.js\";\n\n/**\n * @name startOfISOWeek\n * @category ISO Week Helpers\n * @summary Return the start of an ISO week for the given date.\n *\n * @description\n * Return the start of an ISO week for the given date.\n * The result will be in the local timezone.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The start of an ISO week\n *\n * @example\n * // The start of an ISO week for 2 September 2014 11:55:00:\n * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Mon Sep 01 2014 00:00:00\n */\nexport function startOfISOWeek<DateType extends Date>(\n  date: DateType | number | string,\n): DateType {\n  return getStartOfWeek(date);\n}\n\n/**\n * Get the start of the week for the given date using the provided week start day.\n *\n * @param date - The original date\n * @param weekStartsOn - The day on which the week starts (0 - Sunday, 1 - Monday, etc.)\n * @returns The start of the week\n */\nfunction getStartOfWeek<DateType extends Date>(\n  date: DateType | number | string,\n  weekStartsOn: number = 1\n): DateType {\n  // Calculate the start of the week based on the provided week start day\n  // Here we are using weekStartsOn = 1 (Monday)\n  const startOfWeekDate = startOfWeek(date, { weekStartsOn });\n  return startOfWeekDate;\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { RoundingMethod } from \"../../types.js\";\n\nexport function getRoundingMethod(method: RoundingMethod | undefined) {\n  return (number: number) => {\n    const round = method ? Math[method] : Math.trunc;\n    const result = round(number);\n    // Prevent negative zero\n    return result === 0 ? 0 : result;\n  };\n}\n"
      },
      {
        "role": "assistant",
        "content": "import type { RoundingMethod } from \"../../types.js\";\n\nexport function getRoundingMethod(method: RoundingMethod | undefined) {\n  return (number: number) => {\n    const round = getRoundFunction(method);\n    const result = round(number);\n    return preventNegativeZero(result);\n  };\n}\n\nfunction getRoundFunction(method: RoundingMethod | undefined) {\n  return method ? Math[method] : Math.trunc;\n}\n\nfunction preventNegativeZero(result: number) {\n  return result === 0 ? 0 : result;\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { millisecondsInHour } from \"../constants/index.js\";\n\n/**\n * @name hoursToMilliseconds\n * @category  Conversion Helpers\n * @summary Convert hours to milliseconds.\n *\n * @description\n * Convert a number of hours to a full number of milliseconds.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param hours - number of hours to be converted\n *\n * @returns The number of hours converted to milliseconds\n *\n * @example\n * // Convert 2 hours to milliseconds:\n * const result = hoursToMilliseconds(2)\n * //=> 7200000\n */\nexport function hoursToMilliseconds(hours: number): number {\n  return Math.trunc(hours * millisecondsInHour);\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { millisecondsInHour } from \"../constants/index.js\";\n\n/**\n * @name hoursToMilliseconds\n * @category  Conversion Helpers\n * @summary Convert hours to milliseconds.\n *\n * @description\n * Convert a number of hours to a full number of milliseconds.\n *\n * @param hours - number of hours to be converted\n *\n * @returns The number of hours converted to milliseconds\n */\nexport function hoursToMilliseconds(hours: number): number {\n  return calculateMilliseconds(hours);\n}\n\n/**\n * @name calculateMilliseconds\n * @param hours - number of hours to be converted\n * @returns The number of hours converted to milliseconds\n */\nfunction calculateMilliseconds(hours: number): number {\n  return Math.trunc(hours * millisecondsInHour);\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\nimport type { Locale } from \"../types.js\";\n\n/**\n * @category Locales\n * @summary Arabic locale (Modern Standard Arabic - Al-fussha).\n * @language Modern Standard Arabic\n * @iso-639-2 ara\n * @author Abdallah Hassan [@AbdallahAHO](https://github.com/AbdallahAHO)\n * @author Koussay Haj Kacem [@essana3](https://github.com/essana3)\n */\nexport const ar: Locale = {\n  code: \"ar\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 6 /* Saturday */,\n    firstWeekContainsDate: 1,\n  },\n};\n"
      },
      {
        "role": "assistant",
        "content": "import { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\nimport type { Locale } from \"../types.js\";\n\n/**\n * @category Locales\n * @summary Arabic locale (Modern Standard Arabic - Al-fussha).\n * @language Modern Standard Arabic\n * @iso-639-2 ara\n * @author Abdallah Hassan [@AbdallahAHO](https://github.com/AbdallahAHO)\n * @author Koussay Haj Kacem [@essana3](https://github.com/essana3)\n */\nexport const ar: Locale = {\n  code: \"ar\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 6 /* Saturday */,\n    firstWeekContainsDate: 1,\n  },\n};\n\n/**\n * Get Arabic locale code.\n * @returns {string} Arabic locale code.\n */\nfunction getLocaleCode(): string {\n  return \"ar\";\n}\n\n/**\n * Set options for Arabic locale.\n * @returns {object} Options for Arabic locale.\n */\nfunction setLocaleOptions(): object {\n  return {\n    weekStartsOn: 6, // Saturday\n    firstWeekContainsDate: 1,\n  };\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Locale } from \"../types.js\";\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\n\n/**\n * @category Locales\n * @summary Greek locale.\n * @language Greek\n * @iso-639-2 ell\n * @author Fanis Katsimpas [@fanixk](https://github.com/fanixk)\n * @author Theodoros Orfanidis [@teoulas](https://github.com/teoulas)\n */\nexport const el: Locale = {\n  code: \"el\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 4,\n  },\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { Locale } from \"../types.js\";\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\n\n/**\n * @category Locales\n * @summary Greek locale.\n * @language Greek\n * @iso-639-2 ell\n * @author Fanis Katsimpas [@fanixk](https://github.com/fanixk)\n * @author Theodoros Orfanidis [@teoulas](https://github.com/teoulas)\n */\nexport const el: Locale = {\n  code: \"el\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 4,\n  },\n};\n\n// New method to set week start on Monday\nconst setWeekStartsOn = () => {\n  el.options.weekStartsOn = 1; // Monday\n};\n\n// New method to set the date that the first week contains\nconst setFirstWeekContainsDate = () => {\n  el.options.firstWeekContainsDate = 4;\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatRelativeFn } from \"../../../types.js\";\n\nconst formatRelativeLocale = {\n  lastWeek: \"eeee 'שעבר בשעה' p\",\n  yesterday: \"'אתמול בשעה' p\",\n  today: \"'היום בשעה' p\",\n  tomorrow: \"'מחר בשעה' p\",\n  nextWeek: \"eeee 'בשעה' p\",\n  other: \"P\",\n};\n\nexport const formatRelative: FormatRelativeFn = (\n  token,\n  _date,\n  _baseDate,\n  _options,\n) => formatRelativeLocale[token];\n"
      },
      {
        "role": "assistant",
        "content": "import type { FormatRelativeFn } from \"../../../types.js\";\n\nconst formatRelativeLocale = {\n  lastWeek: \"eeee 'שעבר בשעה' p\",\n  yesterday: \"'אתמול בשעה' p\",\n  today: \"'היום בשעה' p\",\n  tomorrow: \"'מחר בשעה' p\",\n  nextWeek: \"eeee 'בשעה' p\",\n  other: \"P\",\n};\n\nconst getFormattedRelativeText = (token) => {\n  return formatRelativeLocale[token];\n};\n\nexport const formatRelative: FormatRelativeFn = (\n  token,\n  _date,\n  _baseDate,\n  _options,\n) => getFormattedRelativeText(token);"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Locale } from \"../types.js\";\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\n\n/**\n * @category Locales\n * @summary Lithuanian locale.\n * @language Lithuanian\n * @iso-639-2 lit\n * @author Pavlo Shpak [@pshpak](https://github.com/pshpak)\n * @author Eduardo Pardo [@eduardopsll](https://github.com/eduardopsll)\n */\nexport const lt: Locale = {\n  code: \"lt\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 4,\n  },\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { Locale } from \"../types.js\";\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\n\n/**\n * @category Locales\n * @summary Lithuanian locale.\n * @language Lithuanian\n * @iso-639-2 lit\n * @author Pavlo Shpak [@pshpak](https://github.com/pshpak)\n * @author Eduardo Pardo [@eduardopsll](https://github.com/eduardopsll)\n */\nexport const lt: Locale = {\n  code: \"lt\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 4,\n  },\n};\n\n/**\n * Returns the week start day for the Lithuanian locale.\n * @returns {number} The week start day (1 for Monday).\n */\nfunction getWeekStartDay(): number {\n  return 1;\n}\n\n/**\n * Returns the date containing the first week for the Lithuanian locale.\n * @returns {number} The date containing the first week.\n */\nfunction getFirstWeekDate(): number {\n  return 4;\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatRelativeFn } from \"../../../types.js\";\n\nconst formatRelativeLocale = {\n  lastWeek: \"'të' eeee 'e shkuar në' p\",\n  yesterday: \"'dje në' p\",\n  today: \"'sot në' p\",\n  tomorrow: \"'nesër në' p\",\n  nextWeek: \"eeee 'at' p\",\n  other: \"P\",\n};\n\nexport const formatRelative: FormatRelativeFn = (\n  token,\n  _date,\n  _baseDate,\n  _options,\n) => formatRelativeLocale[token];\n"
      },
      {
        "role": "assistant",
        "content": "import type { FormatRelativeFn } from \"../../../types.js\";\n\nconst formatRelativeLocale = {\n  lastWeek: \"'të' eeee 'e shkuar në' p\",\n  yesterday: \"'dje në' p\",\n  today: \"'sot në' p\",\n  tomorrow: \"'nesër në' p\",\n  nextWeek: \"eeee 'at' p\",\n  other: \"P\",\n};\n\nconst getFormattedRelative = (token) => {\n  return formatRelativeLocale[token];\n};\n\nexport const formatRelative: FormatRelativeFn = (\n  token,\n  _date,\n  _baseDate,\n  _options,\n) => getFormattedRelative(token);"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { millisecondsInMinute } from \"../constants/index.js\";\n\n/**\n * @name minutesToMilliseconds\n * @category Conversion Helpers\n * @summary Convert minutes to milliseconds.\n *\n * @description\n * Convert a number of minutes to a full number of milliseconds.\n *\n * @param minutes - The number of minutes to be converted\n *\n * @returns The number of minutes converted in milliseconds\n *\n * @example\n * // Convert 2 minutes to milliseconds\n * const result = minutesToMilliseconds(2)\n * //=> 120000\n */\nexport function minutesToMilliseconds(minutes: number): number {\n  return Math.trunc(minutes * millisecondsInMinute);\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { millisecondsInMinute } from \"../constants/index.js\";\n\n/**\n * @name minutesToMilliseconds\n * @category Conversion Helpers\n * @summary Convert minutes to milliseconds.\n *\n * @description\n * Convert a number of minutes to a full number of milliseconds.\n *\n * @param minutes - The number of minutes to be converted\n *\n * @returns The number of minutes converted in milliseconds\n *\n * @example\n * // Convert 2 minutes to milliseconds\n * const result = minutesToMilliseconds(2)\n * //=> 120000\n */\nexport function minutesToMilliseconds(minutes: number): number {\n  return Math.trunc(minutes * millisecondsInMinute);\n}\n\n/**\n * @name convertMinutesToMilliseconds\n * @category Conversion Helpers\n * @summary Helper function to convert minutes to milliseconds.\n *\n * @param minutes - The number of minutes to be converted\n *\n * @returns The number of minutes converted in milliseconds\n */\nexport function convertMinutesToMilliseconds(minutes: number): number {\n  return minutesToMilliseconds(minutes);\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nconst dayOfYearTokenRE = /^D+$/;\nconst weekYearTokenRE = /^Y+$/;\n\nconst throwTokens = [\"D\", \"DD\", \"YY\", \"YYYY\"];\n\nexport function isProtectedDayOfYearToken(token: string) {\n  return dayOfYearTokenRE.test(token);\n}\n\nexport function isProtectedWeekYearToken(token: string) {\n  return weekYearTokenRE.test(token);\n}\n\nexport function warnOrThrowProtectedError(\n  token: string,\n  format: string,\n  input: string,\n): void {\n  const _message = message(token, format, input);\n  console.warn(_message);\n  if (throwTokens.includes(token)) throw new RangeError(_message);\n}\n\nfunction message(token: string, format: string, input: string) {\n  const subject = token[0] === \"Y\" ? \"years\" : \"days of the month\";\n  return `Use \\`${token.toLowerCase()}\\` instead of \\`${token}\\` (in \\`${format}\\`) for formatting ${subject} to the input \\`${input}\\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;\n}\n"
      },
      {
        "role": "assistant",
        "content": "```javascript\nconst dayOfYearTokenRE = /^D+$/;\nconst weekYearTokenRE = /^Y+$/;\n\nconst throwTokens = [\"D\", \"DD\", \"YY\", \"YYYY\"];\n\nexport function isProtectedDayOfYearToken(token: string) {\n  return dayOfYearTokenRE.test(token);\n}\n\nexport function isProtectedWeekYearToken(token: string) {\n  return weekYearTokenRE.test(token);\n}\n\nexport function warnOrThrowProtectedError(\n  token: string,\n  format: string,\n  input: string,\n): void {\n  const _message = message(token, format, input);\n  console.warn(_message);\n  if (throwTokens.includes(token)) throw new RangeError(_message);\n}\n\nfunction message(token: string, format: string, input: string) {\n  const subject = token[0] === \"Y\" ? \"years\" : \"days of the month\";\n  return `Use \\`${token.toLowerCase()}\\` instead of \\`${token}\\` (in \\`${format}\\`) for formatting ${subject} to the input \\`${input}\\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;\n}\n```"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { minutesInHour } from \"../constants/index.js\";\n\n/**\n * @name hoursToMinutes\n * @category Conversion Helpers\n * @summary Convert hours to minutes.\n *\n * @description\n * Convert a number of hours to a full number of minutes.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param hours - number of hours to be converted\n *\n * @returns The number of hours converted in minutes\n *\n * @example\n * // Convert 2 hours to minutes:\n * const result = hoursToMinutes(2)\n * //=> 120\n */\nexport function hoursToMinutes(hours: number): number {\n  return Math.trunc(hours * minutesInHour);\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { minutesInHour } from \"../constants/index.js\";\n\n/**\n * @name hoursToMinutes\n * @category Conversion Helpers\n * @summary Convert hours to minutes.\n *\n * @description\n * Convert a number of hours to a full number of minutes.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param hours - number of hours to be converted\n *\n * @returns The number of hours converted in minutes\n *\n * @example\n * // Convert 2 hours to minutes:\n * const result = hoursToMinutes(2)\n * //=> 120\n */\nexport function hoursToMinutes(hours: number): number {\n  return calculateMinutes(hours);\n}\n\nfunction calculateMinutes(hours: number): number {\n  return Math.trunc(hours * minutesInHour);\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatRelativeFn } from \"../../../types.js\";\n\nconst formatRelativeLocale = {\n  lastWeek: \"'أخر' eeee 'عند' p\",\n  yesterday: \"'أمس عند' p\",\n  today: \"'اليوم عند' p\",\n  tomorrow: \"'غداً عند' p\",\n  nextWeek: \"eeee 'عند' p\",\n  other: \"P\",\n};\n\nexport const formatRelative: FormatRelativeFn = (\n  token,\n  _date,\n  _baseDate,\n  _options,\n) => {\n  return formatRelativeLocale[token];\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { FormatRelativeFn } from \"../../../types.js\";\n\nconst formatRelativeLocale = {\n  lastWeek: \"'أخر' eeee 'عند' p\",\n  yesterday: \"'أمس عند' p\",\n  today: \"'اليوم عند' p\",\n  tomorrow: \"'غداً عند' p\",\n  nextWeek: \"eeee 'عند' p\",\n  other: \"P\",\n};\n\nconst getFormattedRelativeDate = (token) => {\n  return formatRelativeLocale[token];\n};\n\nexport const formatRelative: FormatRelativeFn = (\n  token,\n  _date,\n  _baseDate,\n  _options,\n) => {\n  return getFormattedRelativeDate(token);\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { formatDistance } from \"../en-US/_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"../en-US/_lib/formatRelative/index.js\";\nimport { localize } from \"../en-US/_lib/localize/index.js\";\nimport { match } from \"../en-US/_lib/match/index.js\";\nimport type { Locale } from \"../types.js\";\n\n/**\n * @category Locales\n * @summary English locale (Australia).\n * @language English\n * @iso-639-2 eng\n * @author Julien Malige [@JulienMalige](https://github.com/JulienMalige)\n */\nexport const enAU: Locale = {\n  code: \"en-AU\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 4,\n  },\n};\n"
      },
      {
        "role": "assistant",
        "content": "import { formatDistance } from \"../en-US/_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"../en-US/_lib/formatRelative/index.js\";\nimport { localize } from \"../en-US/_lib/localize/index.js\";\nimport { match } from \"../en-US/_lib/match/index.js\";\nimport type { Locale } from \"../types.js\";\n\n/**\n * @category Locales\n * @summary English locale (Australia).\n * @language English\n * @iso-639-2 eng\n * @author Julien Malige [@JulienMalige](https://github.com/JulienMalige)\n */\nexport const enAU: Locale = {\n  code: \"en-AU\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 4,\n  },\n};\n\n// Extracted methods for enhanced modularity and readability\nconst createEnAULocale = (): Locale => {\n  return {\n    code: \"en-AU\",\n    formatDistance: formatDistance,\n    formatLong: formatLong,\n    formatRelative: formatRelative,\n    localize: localize,\n    match: match,\n    options: {\n      weekStartsOn: 1 /* Monday */,\n      firstWeekContainsDate: 4,\n    },\n  };\n};\n\nexport { createEnAULocale };"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Locale } from \"../types.js\";\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\n\n/**\n * @category Locales\n * @summary Hebrew locale.\n * @language Hebrew\n * @iso-639-2 heb\n * @author Nir Lahad [@nirlah](https://github.com/nirlah)\n */\nexport const he: Locale = {\n  code: \"he\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 0 /* Sunday */,\n    firstWeekContainsDate: 1,\n  },\n};\n"
      },
      {
        "role": "assistant",
        "content": "import { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\n\n/**\n * @category Locales\n * @summary Hebrew locale.\n * @language Hebrew\n * @iso-639-2 heb\n * @author Nir Lahad [@nirlah](https://github.com/nirlah)\n */\nexport const he: Locale = {\n  code: \"he\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 0 /* Sunday */,\n    firstWeekContainsDate: 1,\n  },\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Locale } from \"../types.js\";\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\n\n/**\n * @category Locales\n * @summary Latvian locale (Latvia).\n * @language Latvian\n * @iso-639-2 lav\n * @author Rūdolfs Puķītis [@prudolfs](https://github.com/prudolfs)\n */\nexport const lv: Locale = {\n  code: \"lv\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 4,\n  },\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { Locale } from \"../types.js\";\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\n\n/**\n * @category Locales\n * @summary Latvian locale (Latvia).\n * @language Latvian\n * @iso-639-2 lav\n * @author Rūdolfs Puķītis [@prudolfs](https://github.com/prudolfs)\n */\nexport const lv: Locale = {\n  code: \"lv\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 4,\n  },\n};\n\n/**\n * Extracted method to handle formatting distance between dates in Latvian locale.\n */\nconst formatDistance = formatDistance;\n\n/**\n * Extracted method to handle formatting long date in Latvian locale.\n */\nconst formatLong = formatLong;\n\n/**\n * Extracted method to handle formatting relative date in Latvian locale.\n */\nconst formatRelative = formatRelative;\n\n/**\n * Extracted method to handle localization in Latvian locale.\n */\nconst localize = localize;\n\n/**\n * Extracted method to handle matching in Latvian locale.\n */\nconst match = match;"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Locale } from \"../types.js\";\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\n\n/**\n * @category Locales\n * @summary Albanian locale.\n * @language Shqip\n * @iso-639-2 sqi\n * @author Ardit Dine [@arditdine](https://github.com/arditdine)\n */\nexport const sq: Locale = {\n  code: \"sq\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 1,\n  },\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { Locale } from \"../types.js\";\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\n\n/**\n * @category Locales\n * @summary Albanian locale.\n * @language Shqip\n * @iso-639-2 sqi\n * @author Ardit Dine [@arditdine](https://github.com/arditdine)\n */\nexport const sq: Locale = {\n  code: \"sq\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 1,\n  },\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { secondsInMinute } from \"../constants/index.js\";\n\n/**\n * @name minutesToSeconds\n * @category Conversion Helpers\n * @summary Convert minutes to seconds.\n *\n * @description\n * Convert a number of minutes to a full number of seconds.\n *\n * @param minutes - The number of minutes to be converted\n *\n * @returns The number of minutes converted in seconds\n *\n * @example\n * // Convert 2 minutes to seconds\n * const result = minutesToSeconds(2)\n * //=> 120\n */\nexport function minutesToSeconds(minutes: number): number {\n  return Math.trunc(minutes * secondsInMinute);\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { secondsInMinute } from \"../constants/index.js\";\n\n/**\n * @name minutesToSeconds\n * @category Conversion Helpers\n * @summary Convert minutes to seconds.\n *\n * @description\n * Convert a number of minutes to a full number of seconds.\n *\n * @param minutes - The number of minutes to be converted\n *\n * @returns The number of minutes converted in seconds\n *\n * @example\n * // Convert 2 minutes to seconds\n * const result = minutesToSeconds(2)\n * //=> 120\n */\nexport function minutesToSeconds(minutes: number): number {\n  return calculateSeconds(minutes);\n}\n\n/**\n * @name calculateSeconds\n * @category Calculation Helpers\n * @summary Calculate seconds from minutes.\n *\n * @param minutes - The number of minutes to be converted\n *\n * @returns The number of minutes converted in seconds\n */\nfunction calculateSeconds(minutes: number): number {\n  return Math.trunc(minutes * secondsInMinute);\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { toDate } from \"../toDate/index.js\";\n\n/**\n * @name startOfSecond\n * @category Second Helpers\n * @summary Return the start of a second for the given date.\n *\n * @description\n * Return the start of a second for the given date.\n * The result will be in the local timezone.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The start of a second\n *\n * @example\n * // The start of a second for 1 December 2014 22:15:45.400:\n * const result = startOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))\n * //=> Mon Dec 01 2014 22:15:45.000\n */\nexport function startOfSecond<DateType extends Date>(\n  date: DateType | number | string,\n): DateType {\n  const _date = toDate(date);\n  _date.setMilliseconds(0);\n  return _date;\n}\n"
      },
      {
        "role": "assistant",
        "content": "```javascript\nimport { toDate } from \"../toDate/index.js\";\n\n/**\n * @name startOfSecond\n * @category Second Helpers\n * @summary Return the start of a second for the given date.\n *\n * @description\n * Return the start of a second for the given date.\n * The result will be in the local timezone.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The start of a second\n *\n * @example\n * // The start of a second for 1 December 2014 22:15:45.400:\n * const result = startOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))\n * //=> Mon Dec 01 2014 22:15:45.000\n */\nexport function startOfSecond<DateType extends Date>(\n  date: DateType | number | string,\n): DateType {\n  const _date = toDate(date);\n  setMillisecondsToZero(_date);\n  return _date;\n}\n\nfunction setMillisecondsToZero(date: Date) {\n  date.setMilliseconds(0);\n}\n```"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { addLeadingZeros } from \"../addLeadingZeros/index.js\";\nimport { setDefaultOptions } from \"../defaultOptions/index.js\";\n\nexport function assertType<T>(_: T): void {}\n\nexport function resetDefaultOptions(): void {\n  setDefaultOptions({});\n}\n\n// This makes sure we create the consistent offsets across timezones, no matter where these tests are ran.\nexport function generateOffset(originalDate: Date) {\n  // Add the timezone.\n  let offset = \"\";\n  const tzOffset = originalDate.getTimezoneOffset();\n\n  if (tzOffset !== 0) {\n    const absoluteOffset = Math.abs(tzOffset);\n    const hourOffset = addLeadingZeros(Math.trunc(absoluteOffset / 60), 2);\n    const minuteOffset = addLeadingZeros(absoluteOffset % 60, 2);\n    // If less than 0, the sign is +, because it is ahead of time.\n    const sign = tzOffset < 0 ? \"+\" : \"-\";\n\n    offset = `${sign}${hourOffset}:${minuteOffset}`;\n  } else {\n    offset = \"Z\";\n  }\n\n  return offset;\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { addLeadingZeros } from \"../addLeadingZeros/index.js\";\nimport { setDefaultOptions } from \"../defaultOptions/index.js\";\n\nexport function assertType<T>(_: T): void {}\n\nexport function resetDefaultOptions(): void {\n  setDefaultOptions({});\n}\n\nexport function generateOffset(originalDate: Date) {\n  const tzOffset = originalDate.getTimezoneOffset();\n  let offset = \"\";\n\n  if (tzOffset !== 0) {\n    offset = calculateOffset(tzOffset);\n  } else {\n    offset = \"Z\";\n  }\n\n  return offset;\n}\n\nfunction calculateOffset(tzOffset: number): string {\n  const absoluteOffset = Math.abs(tzOffset);\n  const hourOffset = addLeadingZeros(Math.trunc(absoluteOffset / 60), 2);\n  const minuteOffset = addLeadingZeros(absoluteOffset % 60, 2);\n  const sign = tzOffset < 0 ? \"+\" : \"-\";\n\n  return `${sign}${hourOffset}:${minuteOffset}`;\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { secondsInHour } from \"../constants/index.js\";\n\n/**\n * @name hoursToSeconds\n * @category Conversion Helpers\n * @summary Convert hours to seconds.\n *\n * @description\n * Convert a number of hours to a full number of seconds.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param hours - The number of hours to be converted\n *\n * @returns The number of hours converted in seconds\n *\n * @example\n * // Convert 2 hours to seconds:\n * const result = hoursToSeconds(2)\n * //=> 7200\n */\nexport function hoursToSeconds(hours: number): number {\n  return Math.trunc(hours * secondsInHour);\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { secondsInHour } from \"../constants/index.js\";\n\n/**\n * @name hoursToSeconds\n * @category Conversion Helpers\n * @summary Convert hours to seconds.\n *\n * @description\n * Convert a number of hours to a full number of seconds.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param hours - The number of hours to be converted\n *\n * @returns The number of hours converted in seconds\n *\n * @example\n * // Convert 2 hours to seconds:\n * const result = hoursToSeconds(2)\n * //=> 7200\n */\nexport function hoursToSeconds(hours: number): number {\n  return Math.trunc(convertHoursToSeconds(hours));\n}\n\n/**\n * @name convertHoursToSeconds\n * @param hours - The number of hours to be converted\n * @returns The number of hours converted in seconds\n */\nfunction convertHoursToSeconds(hours: number): number {\n  return hours * secondsInHour;\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\nimport type { Locale } from \"../types.js\";\n\n/**\n * @category Locales\n * @summary Arabic locale (Algerian Arabic).\n * @language Algerian Arabic\n * @iso-639-2 ara\n * @author Badreddine Boumaza [@badre429](https://github.com/badre429)\n * @author Ahmed ElShahat [@elshahat](https://github.com/elshahat)\n */\nexport const arDZ: Locale = {\n  code: \"ar-DZ\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 0 /* Sunday */,\n    firstWeekContainsDate: 1,\n  },\n};\n"
      },
      {
        "role": "assistant",
        "content": "import { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\nimport type { Locale } from \"../types.js\";\n\n/**\n * @category Locales\n * @summary Arabic locale (Algerian Arabic).\n * @language Algerian Arabic\n * @iso-639-2 ara\n * @author Badreddine Boumaza [@badre429](https://github.com/badre429)\n * @author Ahmed ElShahat [@elshahat](https://github.com/elshahat)\n */\nexport const arDZ: Locale = {\n  code: \"ar-DZ\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 0 /* Sunday */,\n    firstWeekContainsDate: 1,\n  },\n};\n\n// Extracted Methods\n\n/**\n * Get the week start day for the locale.\n * @returns {number} Week start day (0 for Sunday).\n */\nfunction getWeekStartDay(): number {\n  return 0;\n}\n\n/**\n * Get the date that the first week contains for the locale.\n * @returns {number} Date that the first week contains.\n */\nfunction getFirstWeekContainsDate(): number {\n  return 1;\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatLong } from \"../../../locale/types.js\";\n\ntype LongFormatter = (pattern: string, formatLong: FormatLong) => string;\n\nconst dateLongFormatter: LongFormatter = (pattern, formatLong) => {\n  switch (pattern) {\n    case \"P\":\n      return formatLong.date({ width: \"short\" });\n    case \"PP\":\n      return formatLong.date({ width: \"medium\" });\n    case \"PPP\":\n      return formatLong.date({ width: \"long\" });\n    case \"PPPP\":\n    default:\n      return formatLong.date({ width: \"full\" });\n  }\n};\n\nconst timeLongFormatter: LongFormatter = (pattern, formatLong) => {\n  switch (pattern) {\n    case \"p\":\n      return formatLong.time({ width: \"short\" });\n    case \"pp\":\n      return formatLong.time({ width: \"medium\" });\n    case \"ppp\":\n      return formatLong.time({ width: \"long\" });\n    case \"pppp\":\n    default:\n      return formatLong.time({ width: \"full\" });\n  }\n};\n\nconst dateTimeLongFormatter: LongFormatter = (\n  pattern: string,\n  formatLong: FormatLong,\n) => {\n  const matchResult = pattern.match(/(P+)(p+)?/) || [];\n  const datePattern = matchResult[1];\n  const timePattern = matchResult[2];\n\n  if (!timePattern) {\n    return dateLongFormatter(pattern, formatLong);\n  }\n\n  let dateTimeFormat: string;\n\n  switch (datePattern) {\n    case \"P\":\n      dateTimeFormat = formatLong.dateTime({ width: \"short\" });\n      break;\n    case \"PP\":\n      dateTimeFormat = formatLong.dateTime({ width: \"medium\" });\n      break;\n    case \"PPP\":\n      dateTimeFormat = formatLong.dateTime({ width: \"long\" });\n      break;\n    case \"PPPP\":\n    default:\n      dateTimeFormat = formatLong.dateTime({ width: \"full\" });\n      break;\n  }\n\n  return dateTimeFormat\n    .replace(\"{{date}}\", dateLongFormatter(datePattern, formatLong))\n    .replace(\"{{time}}\", timeLongFormatter(timePattern, formatLong));\n};\n\nexport const longFormatters: Record<string, LongFormatter> = {\n  p: timeLongFormatter,\n  P: dateTimeLongFormatter,\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { FormatLong } from \"../../../locale/types.js\";\n\ntype LongFormatter = (pattern: string, formatLong: FormatLong) => string;\n\nconst dateLongFormatter: LongFormatter = (pattern, formatLong) => {\n  switch (pattern) {\n    case \"P\":\n      return formatLong.date({ width: \"short\" });\n    case \"PP\":\n      return formatLong.date({ width: \"medium\" });\n    case \"PPP\":\n      return formatLong.date({ width: \"long\" });\n    case \"PPPP\":\n    default:\n      return formatLong.date({ width: \"full\" });\n  }\n};\n\nconst timeLongFormatter: LongFormatter = (pattern, formatLong) => {\n  switch (pattern) {\n    case \"p\":\n      return formatLong.time({ width: \"short\" });\n    case \"pp\":\n      return formatLong.time({ width: \"medium\" });\n    case \"ppp\":\n      return formatLong.time({ width: \"long\" });\n    case \"pppp\":\n    default:\n      return formatLong.time({ width: \"full\" });\n  }\n};\n\nconst getDateTimeFormat = (datePattern: string, formatLong: FormatLong) => {\n  switch (datePattern) {\n    case \"P\":\n      return formatLong.dateTime({ width: \"short\" });\n    case \"PP\":\n      return formatLong.dateTime({ width: \"medium\" });\n    case \"PPP\":\n      return formatLong.dateTime({ width: \"long\" });\n    case \"PPPP\":\n    default:\n      return formatLong.dateTime({ width: \"full\" });\n  }\n};\n\nconst replaceDateTimeStrings = (dateTimeFormat: string, datePattern: string, timePattern: string, formatLong: FormatLong) => {\n  return dateTimeFormat\n    .replace(\"{{date}}\", dateLongFormatter(datePattern, formatLong))\n    .replace(\"{{time}}\", timeLongFormatter(timePattern, formatLong));\n};\n\nconst dateTimeLongFormatter: LongFormatter = (\n  pattern: string,\n  formatLong: FormatLong,\n) => {\n  const matchResult = pattern.match(/(P+)(p+)?/) || [];\n  const datePattern = matchResult[1];\n  const timePattern = matchResult[2];\n\n  if (!timePattern) {\n    return dateLongFormatter(pattern, formatLong);\n  }\n\n  const dateTimeFormat = getDateTimeFormat(datePattern, formatLong);\n\n  return replaceDateTimeStrings(dateTimeFormat, datePattern, timePattern, formatLong);\n};\n\nexport const longFormatters: Record<string, LongFormatter> = {\n  p: timeLongFormatter,\n  P: dateTimeLongFormatter,\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { toDate } from \"../toDate/index.js\";\nimport type { LocalizedOptions, WeekOptions } from \"../types.js\";\nimport { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n\n/**\n * The {@link endOfWeek} function options.\n */\nexport interface EndOfWeekOptions\n  extends WeekOptions,\n    LocalizedOptions<\"options\"> {}\n\n/**\n * @name endOfWeek\n * @category Week Helpers\n * @summary Return the end of a week for the given date.\n *\n * @description\n * Return the end of a week for the given date.\n * The result will be in the local timezone.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n * @param options - An object with options\n *\n * @returns The end of a week\n *\n * @example\n * // The end of a week for 2 September 2014 11:55:00:\n * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Sat Sep 06 2014 23:59:59.999\n *\n * @example\n * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:\n * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })\n * //=> Sun Sep 07 2014 23:59:59.999\n */\nexport function endOfWeek<DateType extends Date>(\n  date: DateType | number | string,\n  options?: EndOfWeekOptions,\n): DateType {\n  const defaultOptions = getDefaultOptions();\n  const weekStartsOn =\n    options?.weekStartsOn ??\n    options?.locale?.options?.weekStartsOn ??\n    defaultOptions.weekStartsOn ??\n    defaultOptions.locale?.options?.weekStartsOn ??\n    0;\n\n  const _date = toDate(date);\n  const day = _date.getDay();\n  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);\n\n  _date.setDate(_date.getDate() + diff);\n  _date.setHours(23, 59, 59, 999);\n  return _date;\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { toDate } from \"../toDate/index.js\";\nimport type { LocalizedOptions, WeekOptions } from \"../types.js\";\nimport { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n\n/**\n * The {@link endOfWeek} function options.\n */\nexport interface EndOfWeekOptions\n  extends WeekOptions,\n    LocalizedOptions<\"options\"> {}\n\n/**\n * Get the week start day based on the options.\n * @param options - An object with options\n * @returns The week start day\n */\nfunction getWeekStartsOn(options: EndOfWeekOptions): number {\n  const defaultOptions = getDefaultOptions();\n  return (\n    options?.weekStartsOn ??\n    options?.locale?.options?.weekStartsOn ??\n    defaultOptions.weekStartsOn ??\n    defaultOptions.locale?.options?.weekStartsOn ??\n    0\n  );\n}\n\n/**\n * Calculate the end of a week based on the given date.\n * @param date - The original date\n * @param weekStartsOn - The week start day\n * @returns The end of a week\n */\nfunction calculateEndOfWeek<DateType extends Date>(date: DateType, weekStartsOn: number): DateType {\n  const _date = new Date(date.getTime());\n  const day = _date.getDay();\n  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);\n\n  _date.setDate(_date.getDate() + diff);\n  _date.setHours(23, 59, 59, 999);\n  return _date;\n}\n\n/**\n * Return the end of a week for the given date.\n * The result will be in the local timezone.\n * @param date - The original date\n * @param options - An object with options\n * @returns The end of a week\n */\nexport function endOfWeek<DateType extends Date>(\n  date: DateType | number | string,\n  options?: EndOfWeekOptions,\n): DateType {\n  const weekStartsOn = getWeekStartsOn(options);\n  const endDate = toDate(date);\n  return calculateEndOfWeek(endDate, weekStartsOn);\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { toDate } from \"../toDate/index.js\";\n\n/**\n * @name isBefore\n * @category Common Helpers\n * @summary Is the first date before the second one?\n *\n * @description\n * Is the first date before the second one?\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The date that should be before the other one to return true\n * @param dateToCompare - The date to compare with\n *\n * @returns The first date is before the second date\n *\n * @example\n * // Is 10 July 1989 before 11 February 1987?\n * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))\n * //=> false\n */\nexport function isBefore<DateType extends Date>(\n  date: DateType | number | string,\n  dateToCompare: DateType | number | string,\n): boolean {\n  const _date = toDate(date);\n  const _dateToCompare = toDate(dateToCompare);\n  return +_date < +_dateToCompare;\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { toDate } from \"../toDate/index.js\";\n\n/**\n * @name isBefore\n * @category Common Helpers\n * @summary Is the first date before the second one?\n *\n * @description\n * Is the first date before the second one?\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The date that should be before the other one to return true\n * @param dateToCompare - The date to compare with\n *\n * @returns The first date is before the second date\n *\n * @example\n * // Is 10 July 1989 before 11 February 1987?\n * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))\n * //=> false\n */\nexport function isBefore<DateType extends Date>(\n  date: DateType | number | string,\n  dateToCompare: DateType | number | string,\n): boolean {\n  const _date = toDate(date);\n  const _dateToCompare = toDate(dateToCompare);\n  return compareDates(_date, _dateToCompare);\n}\n\nfunction compareDates(date1: Date, date2: Date): boolean {\n  return +date1 < +date2;\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { lastDayOfWeek } from \"../lastDayOfWeek/index.js\";\n\n/**\n * @name lastDayOfISOWeek\n * @category ISO Week Helpers\n * @summary Return the last day of an ISO week for the given date.\n *\n * @description\n * Return the last day of an ISO week for the given date.\n * The result will be in the local timezone.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The last day of an ISO week\n *\n * @example\n * // The last day of an ISO week for 2 September 2014 11:55:00:\n * const result = lastDayOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Sun Sep 07 2014 00:00:00\n */\nexport function lastDayOfISOWeek<DateType extends Date>(\n  date: DateType | number | string,\n): DateType {\n  return lastDayOfWeek(date, { weekStartsOn: 1 });\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { lastDayOfWeek } from \"../lastDayOfWeek/index.js\";\n\n/**\n * @name lastDayOfISOWeek\n * @category ISO Week Helpers\n * @summary Return the last day of an ISO week for the given date.\n *\n * @description\n * Return the last day of an ISO week for the given date.\n * The result will be in the local timezone.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The last day of an ISO week\n *\n * @example\n * // The last day of an ISO week for 2 September 2014 11:55:00:\n * const result = lastDayOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Sun Sep 07 2014 00:00:00\n */\nexport function lastDayOfISOWeek<DateType extends Date>(\n  date: DateType | number | string,\n): DateType {\n  return getLastDayOfWeek(date);\n}\n\n/**\n * Get the last day of the week for the given date using ISO week numbering.\n * @param date - The original date\n * @returns The last day of the week\n */\nfunction getLastDayOfWeek(date: DateType | number | string): DateType {\n  return lastDayOfWeek(date, { weekStartsOn: 1 });\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { buildFormatLongFn } from \"../../../_lib/buildFormatLongFn/index.js\";\nimport type { FormatLong } from \"../../../types.js\";\n\n// DIN 5008: https://de.wikipedia.org/wiki/Datumsformat#DIN_5008\nconst dateFormats = {\n  full: \"EEEE, do MMMM y\", // Montag, 7. Januar 2018\n  long: \"do MMMM y\", // 7. Januar 2018\n  medium: \"do MMM y\", // 7. Jan. 2018\n  short: \"dd.MM.y\", // 07.01.2018\n};\n\nconst timeFormats = {\n  full: \"HH:mm:ss zzzz\",\n  long: \"HH:mm:ss z\",\n  medium: \"HH:mm:ss\",\n  short: \"HH:mm\",\n};\n\nconst dateTimeFormats = {\n  full: \"{{date}} 'um' {{time}}\",\n  long: \"{{date}} 'um' {{time}}\",\n  medium: \"{{date}} {{time}}\",\n  short: \"{{date}} {{time}}\",\n};\n\nexport const formatLong: FormatLong = {\n  date: buildFormatLongFn({\n    formats: dateFormats,\n    defaultWidth: \"full\",\n  }),\n\n  time: buildFormatLongFn({\n    formats: timeFormats,\n    defaultWidth: \"full\",\n  }),\n\n  dateTime: buildFormatLongFn({\n    formats: dateTimeFormats,\n    defaultWidth: \"full\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "const buildDateFormats = () => {\n  return {\n    full: \"EEEE, do MMMM y\", // Montag, 7. Januar 2018\n    long: \"do MMMM y\", // 7. Januar 2018\n    medium: \"do MMM y\", // 7. Jan. 2018\n    short: \"dd.MM.y\", // 07.01.2018\n  };\n};\n\nconst buildTimeFormats = () => {\n  return {\n    full: \"HH:mm:ss zzzz\",\n    long: \"HH:mm:ss z\",\n    medium: \"HH:mm:ss\",\n    short: \"HH:mm\",\n  };\n};\n\nconst buildDateTimeFormats = () => {\n  return {\n    full: \"{{date}} 'um' {{time}}\",\n    long: \"{{date}} 'um' {{time}}\",\n    medium: \"{{date}} {{time}}\",\n    short: \"{{date}} {{time}}\",\n  };\n};\n\nexport const formatLong: FormatLong = {\n  date: buildFormatLongFn({\n    formats: buildDateFormats(),\n    defaultWidth: \"full\",\n  }),\n\n  time: buildFormatLongFn({\n    formats: buildTimeFormats(),\n    defaultWidth: \"full\",\n  }),\n\n  dateTime: buildFormatLongFn({\n    formats: buildDateTimeFormats(),\n    defaultWidth: \"full\",\n  }),\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatLong } from \"../../../types.js\";\nimport { buildFormatLongFn } from \"../../../_lib/buildFormatLongFn/index.js\";\n\nconst dateFormats = {\n  full: \"EEEE, do MMMM, y\", // CLDR #1787\n  long: \"do MMMM, y\", // CLDR #1788\n  medium: \"d MMM, y\", // CLDR #1789\n  short: \"dd/MM/yyyy\", // CLDR #1790\n};\n\nconst timeFormats = {\n  full: \"h:mm:ss a zzzz\", // CLDR #1791\n  long: \"h:mm:ss a z\", // CLDR #1792\n  medium: \"h:mm:ss a\", // CLDR #1793\n  short: \"h:mm a\", // CLDR #1794\n};\n\nconst dateTimeFormats = {\n  full: \"{{date}} 'को' {{time}}\", // CLDR #1795\n  long: \"{{date}} 'को' {{time}}\", // CLDR #1796\n  medium: \"{{date}}, {{time}}\", // CLDR #1797\n  short: \"{{date}}, {{time}}\", // CLDR #1798\n};\n\nexport const formatLong: FormatLong = {\n  date: buildFormatLongFn({\n    formats: dateFormats,\n    defaultWidth: \"full\",\n  }),\n\n  time: buildFormatLongFn({\n    formats: timeFormats,\n    defaultWidth: \"full\",\n  }),\n\n  dateTime: buildFormatLongFn({\n    formats: dateTimeFormats,\n    defaultWidth: \"full\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { FormatLong } from \"../../../types.js\";\nimport { buildFormatLongFn } from \"../../../_lib/buildFormatLongFn/index.js\";\n\nconst dateFormats = {\n  full: \"EEEE, do MMMM, y\", // CLDR #1787\n  long: \"do MMMM, y\", // CLDR #1788\n  medium: \"d MMM, y\", // CLDR #1789\n  short: \"dd/MM/yyyy\", // CLDR #1790\n};\n\nconst timeFormats = {\n  full: \"h:mm:ss a zzzz\", // CLDR #1791\n  long: \"h:mm:ss a z\", // CLDR #1792\n  medium: \"h:mm:ss a\", // CLDR #1793\n  short: \"h:mm a\", // CLDR #1794\n};\n\nconst dateTimeFormats = {\n  full: \"{{date}} 'को' {{time}}\", // CLDR #1795\n  long: \"{{date}} 'को' {{time}}\", // CLDR #1796\n  medium: \"{{date}}, {{time}}\", // CLDR #1797\n  short: \"{{date}}, {{time}}\", // CLDR #1798\n};\n\nconst buildDateFormats = () => {\n  return buildFormatLongFn({\n    formats: dateFormats,\n    defaultWidth: \"full\",\n  });\n};\n\nconst buildTimeFormats = () => {\n  return buildFormatLongFn({\n    formats: timeFormats,\n    defaultWidth: \"full\",\n  });\n};\n\nconst buildDateTimeFormats = () => {\n  return buildFormatLongFn({\n    formats: dateTimeFormats,\n    defaultWidth: \"full\",\n  });\n};\n\nexport const formatLong: FormatLong = {\n  date: buildDateFormats(),\n  time: buildTimeFormats(),\n  dateTime: buildDateTimeFormats(),\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatLong } from \"../../../types.js\";\nimport { buildFormatLongFn } from \"../../../_lib/buildFormatLongFn/index.js\";\n\nconst dateFormats = {\n  full: \"EEEE, y. 'gada' d. MMMM\",\n  long: \"y. 'gada' d. MMMM\",\n  medium: \"dd.MM.y.\",\n  short: \"dd.MM.y.\",\n};\n\nconst timeFormats = {\n  full: \"HH:mm:ss zzzz\",\n  long: \"HH:mm:ss z\",\n  medium: \"HH:mm:ss\",\n  short: \"HH:mm\",\n};\n\nconst dateTimeFormats = {\n  full: \"{{date}} 'plkst.' {{time}}\",\n  long: \"{{date}} 'plkst.' {{time}}\",\n  medium: \"{{date}}, {{time}}\",\n  short: \"{{date}}, {{time}}\",\n};\n\nexport const formatLong: FormatLong = {\n  date: buildFormatLongFn({\n    formats: dateFormats,\n    defaultWidth: \"full\",\n  }),\n\n  time: buildFormatLongFn({\n    formats: timeFormats,\n    defaultWidth: \"full\",\n  }),\n\n  dateTime: buildFormatLongFn({\n    formats: dateTimeFormats,\n    defaultWidth: \"full\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { FormatLong } from \"../../../types.js\";\nimport { buildFormatLongFn } from \"../../../_lib/buildFormatLongFn/index.js\";\n\nconst dateFormats = {\n  full: \"EEEE, y. 'gada' d. MMMM\",\n  long: \"y. 'gada' d. MMMM\",\n  medium: \"dd.MM.y.\",\n  short: \"dd.MM.y.\",\n};\n\nconst timeFormats = {\n  full: \"HH:mm:ss zzzz\",\n  long: \"HH:mm:ss z\",\n  medium: \"HH:mm:ss\",\n  short: \"HH:mm\",\n};\n\nconst dateTimeFormats = {\n  full: \"{{date}} 'plkst.' {{time}}\",\n  long: \"{{date}} 'plkst.' {{time}}\",\n  medium: \"{{date}}, {{time}}\",\n  short: \"{{date}}, {{time}}\",\n};\n\nconst formatLong: FormatLong = {\n  date: buildFormatLongFn({\n    formats: dateFormats,\n    defaultWidth: \"full\",\n  }),\n\n  time: buildFormatLongFn({\n    formats: timeFormats,\n    defaultWidth: \"full\",\n  }),\n\n  dateTime: buildFormatLongFn({\n    formats: dateTimeFormats,\n    defaultWidth: \"full\",\n  }),\n};\n\nexport default formatLong;"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatLong } from \"../../../types.js\";\nimport { buildFormatLongFn } from \"../../../_lib/buildFormatLongFn/index.js\";\n\nconst dateFormats = {\n  full: \"EEEE, d. MMMM yyyy.\",\n  long: \"d. MMMM yyyy.\",\n  medium: \"d. MMM yy.\",\n  short: \"dd. MM. yy.\",\n};\n\nconst timeFormats = {\n  full: \"HH:mm:ss (zzzz)\",\n  long: \"HH:mm:ss z\",\n  medium: \"HH:mm:ss\",\n  short: \"HH:mm\",\n};\n\nconst dateTimeFormats = {\n  full: \"{{date}} 'u' {{time}}\",\n  long: \"{{date}} 'u' {{time}}\",\n  medium: \"{{date}} {{time}}\",\n  short: \"{{date}} {{time}}\",\n};\n\nexport const formatLong: FormatLong = {\n  date: buildFormatLongFn({\n    formats: dateFormats,\n    defaultWidth: \"full\",\n  }),\n\n  time: buildFormatLongFn({\n    formats: timeFormats,\n    defaultWidth: \"full\",\n  }),\n\n  dateTime: buildFormatLongFn({\n    formats: dateTimeFormats,\n    defaultWidth: \"full\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { FormatLong } from \"../../../types.js\";\nimport { buildFormatLongFn } from \"../../../_lib/buildFormatLongFn/index.js\";\n\nconst dateFormats = {\n  full: \"EEEE, d. MMMM yyyy.\",\n  long: \"d. MMMM yyyy.\",\n  medium: \"d. MMM yy.\",\n  short: \"dd. MM. yy.\",\n};\n\nconst timeFormats = {\n  full: \"HH:mm:ss (zzzz)\",\n  long: \"HH:mm:ss z\",\n  medium: \"HH:mm:ss\",\n  short: \"HH:mm\",\n};\n\nconst dateTimeFormats = {\n  full: \"{{date}} 'u' {{time}}\",\n  long: \"{{date}} 'u' {{time}}\",\n  medium: \"{{date}} {{time}}\",\n  short: \"{{date}} {{time}}\",\n};\n\nconst formatDate = (width: string) => {\n  return buildFormatLongFn({\n    formats: dateFormats,\n    defaultWidth: width,\n  });\n};\n\nconst formatTime = (width: string) => {\n  return buildFormatLongFn({\n    formats: timeFormats,\n    defaultWidth: width,\n  });\n};\n\nconst formatDateTime = (width: string) => {\n  return buildFormatLongFn({\n    formats: dateTimeFormats,\n    defaultWidth: width,\n  });\n};\n\nexport const formatLong: FormatLong = {\n  date: formatDate(\"full\"),\n  time: formatTime(\"full\"),\n  dateTime: formatDateTime(\"full\"),\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Match } from \"../../locale/types.js\";\nimport { ValueSetter } from \"./Setter.js\";\nimport type { ParseFlags, ParseResult, ParserOptions } from \"./types.js\";\n\nexport abstract class Parser<Value> {\n  public abstract incompatibleTokens: string[] | \"*\";\n  public abstract priority: number;\n  public subPriority?: number;\n\n  public run(\n    dateString: string,\n    token: string,\n    match: Match,\n    options: ParserOptions,\n  ): { setter: ValueSetter<Value>; rest: string } | null {\n    const result = this.parse(dateString, token, match, options);\n    if (!result) {\n      return null;\n    }\n\n    return {\n      setter: new ValueSetter<Value>(\n        result.value,\n        this.validate,\n        this.set,\n        this.priority,\n        this.subPriority,\n      ),\n      rest: result.rest,\n    };\n  }\n\n  protected abstract parse(\n    dateString: string,\n    token: string,\n    match: Match,\n    options: ParserOptions,\n  ): ParseResult<Value>;\n\n  protected validate<DateType extends Date>(\n    _utcDate: DateType,\n    _value: Value,\n    _options: ParserOptions,\n  ): boolean {\n    return true;\n  }\n\n  protected abstract set<DateType extends Date>(\n    date: DateType,\n    flags: ParseFlags,\n    value: Value,\n    options: ParserOptions,\n  ): DateType | [DateType, ParseFlags];\n}\n"
      },
      {
        "role": "assistant",
        "content": "import type { Match } from \"../../locale/types.js\";\nimport { ValueSetter } from \"./Setter.js\";\nimport type { ParseFlags, ParseResult, ParserOptions } from \"./types.js\";\n\nexport abstract class Parser<Value> {\n  public abstract incompatibleTokens: string[] | \"*\";\n  public abstract priority: number;\n  public subPriority?: number;\n\n  public run(\n    dateString: string,\n    token: string,\n    match: Match,\n    options: ParserOptions,\n  ): { setter: ValueSetter<Value>; rest: string } | null {\n    const result = this.parse(dateString, token, match, options);\n    if (!result) {\n      return null;\n    }\n\n    return this.processResult(result.value, result.rest);\n  }\n\n  protected abstract parse(\n    dateString: string,\n    token: string,\n    match: Match,\n    options: ParserOptions,\n  ): ParseResult<Value>;\n\n  protected validate<DateType extends Date>(\n    _utcDate: DateType,\n    _value: Value,\n    _options: ParserOptions,\n  ): boolean {\n    return true;\n  }\n\n  protected abstract set<DateType extends Date>(\n    date: DateType,\n    flags: ParseFlags,\n    value: Value,\n    options: ParserOptions,\n  ): DateType | [DateType, ParseFlags];\n\n  private processResult(\n    value: Value,\n    rest: string\n  ): { setter: ValueSetter<Value>; rest: string } {\n    return {\n      setter: new ValueSetter<Value>(\n        value,\n        this.validate,\n        this.set,\n        this.priority,\n        this.subPriority,\n      ),\n      rest: rest,\n    };\n  }\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { addHours } from \"../addHours/index.js\";\n\n/**\n * @name subHours\n * @category Hour Helpers\n * @summary Subtract the specified number of hours from the given date.\n *\n * @description\n * Subtract the specified number of hours from the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The date to be changed\n * @param amount - The amount of hours to be subtracted.\n *\n * @returns The new date with the hours subtracted\n *\n * @example\n * // Subtract 2 hours from 11 July 2014 01:00:00:\n * const result = subHours(new Date(2014, 6, 11, 1, 0), 2)\n * //=> Thu Jul 10 2014 23:00:00\n */\nexport function subHours<DateType extends Date>(\n  date: DateType | number | string,\n  amount: number,\n): DateType {\n  return addHours(date, -amount);\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { addHours } from \"../addHours/index.js\";\n\n/**\n * @name subHours\n * @category Hour Helpers\n * @summary Subtract the specified number of hours from the given date.\n *\n * @description\n * Subtract the specified number of hours from the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The date to be changed\n * @param amount - The amount of hours to be subtracted.\n *\n * @returns The new date with the hours subtracted\n *\n * @example\n * // Subtract 2 hours from 11 July 2014 01:00:00:\n * const result = subHours(new Date(2014, 6, 11, 1, 0), 2)\n * //=> Thu Jul 10 2014 23:00:00\n */\nexport function subHours<DateType extends Date>(\n  date: DateType | number | string,\n  amount: number,\n): DateType {\n  return addHours(date, -amount);\n}\n\n/**\n * @name subtractHours\n * @param date - The date to subtract hours from\n * @param hours - The number of hours to subtract\n * @returns The modified date with hours subtracted\n */\nfunction subtractHours(date: DateType, hours: number): DateType {\n  return addHours(date, -hours);\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { toDate } from \"../../toDate/index.js\";\n\n/**\n * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.\n * They usually appear for dates that denote time before the timezones were introduced\n * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891\n * and GMT+01:00:00 after that date)\n *\n * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,\n * which would lead to incorrect calculations.\n *\n * This function returns the timezone offset in milliseconds that takes seconds in account.\n */\nexport function getTimezoneOffsetInMilliseconds(\n  date: Date | number | string,\n): number {\n  const _date = toDate(date);\n  const utcDate = new Date(\n    Date.UTC(\n      _date.getFullYear(),\n      _date.getMonth(),\n      _date.getDate(),\n      _date.getHours(),\n      _date.getMinutes(),\n      _date.getSeconds(),\n      _date.getMilliseconds(),\n    ),\n  );\n  utcDate.setUTCFullYear(_date.getFullYear());\n  return +date - +utcDate;\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { toDate } from \"../../toDate/index.js\";\n\n/**\n * Adjusts the timezone offset in milliseconds for dates before timezone offset with seconds were introduced by Google Chrome.\n */\nexport function adjustTimezoneOffset(date: Date): Date {\n  const utcDate = new Date(\n    Date.UTC(\n      date.getFullYear(),\n      date.getMonth(),\n      date.getDate(),\n      date.getHours(),\n      date.getMinutes(),\n      date.getSeconds(),\n      date.getMilliseconds()\n    )\n  );\n  utcDate.setUTCFullYear(date.getFullYear());\n  return utcDate;\n}\n\n/**\n * Calculates the timezone offset in milliseconds that takes seconds into account.\n */\nexport function getTimezoneOffsetInMilliseconds(date: Date | number | string): number {\n  const _date = toDate(date);\n  const utcDate = adjustTimezoneOffset(_date);\n  return +date - +utcDate;\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { toDate } from \"../toDate/index.js\";\n\n/**\n * @name differenceInCalendarYears\n * @category Year Helpers\n * @summary Get the number of calendar years between the given dates.\n *\n * @description\n * Get the number of calendar years between the given dates.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param dateLeft - The later date\n * @param dateRight - The earlier date\n\n * @returns The number of calendar years\n *\n * @example\n * // How many calendar years are between 31 December 2013 and 11 February 2015?\n * const result = differenceInCalendarYears(\n *   new Date(2015, 1, 11),\n *   new Date(2013, 11, 31)\n * )\n * //=> 2\n */\nexport function differenceInCalendarYears<DateType extends Date>(\n  dateLeft: DateType | number | string,\n  dateRight: DateType | number | string,\n): number {\n  const _dateLeft = toDate(dateLeft);\n  const _dateRight = toDate(dateRight);\n\n  return _dateLeft.getFullYear() - _dateRight.getFullYear();\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { toDate } from \"../toDate/index.js\";\n\n/**\n * @name differenceInCalendarYears\n * @category Year Helpers\n * @summary Get the number of calendar years between the given dates.\n *\n * @description\n * Get the number of calendar years between the given dates.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param dateLeft - The later date\n * @param dateRight - The earlier date\n * @returns The number of calendar years\n *\n * @example\n * // How many calendar years are between 31 December 2013 and 11 February 2015?\n * const result = differenceInCalendarYears(\n *   new Date(2015, 1, 11),\n *   new Date(2013, 11, 31)\n * )\n * //=> 2\n */\nexport function differenceInCalendarYears<DateType extends Date>(\n  dateLeft: DateType | number | string,\n  dateRight: DateType | number | string,\n): number {\n  const _dateLeft = toDate(dateLeft);\n  const _dateRight = toDate(dateRight);\n\n  return getYearDifference(_dateLeft, _dateRight);\n}\n\n/**\n * Calculates the difference in years between two dates.\n * @param dateLeft - The later date\n * @param dateRight - The earlier date\n * @returns The difference in years\n */\nfunction getYearDifference(dateLeft: Date, dateRight: Date): number {\n  return dateLeft.getFullYear() - dateRight.getFullYear();\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { toDate } from \"../toDate/index.js\";\n\n/**\n * @name endOfYear\n * @category Year Helpers\n * @summary Return the end of a year for the given date.\n *\n * @description\n * Return the end of a year for the given date.\n * The result will be in the local timezone.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The end of a year\n *\n * @example\n * // The end of a year for 2 September 2014 11:55:00:\n * const result = endOfYear(new Date(2014, 8, 2, 11, 55, 00))\n * //=> Wed Dec 31 2014 23:59:59.999\n */\nexport function endOfYear<DateType extends Date>(\n  date: DateType | number | string,\n): DateType {\n  const _date = toDate(date);\n  const year = _date.getFullYear();\n  _date.setFullYear(year + 1, 0, 0);\n  _date.setHours(23, 59, 59, 999);\n  return _date;\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { toDate } from \"../toDate/index.js\";\n\n/**\n * @name endOfYear\n * @category Year Helpers\n * @summary Return the end of a year for the given date.\n *\n * @description\n * Return the end of a year for the given date.\n * The result will be in the local timezone.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The end of a year\n *\n * @example\n * // The end of a year for 2 September 2014 11:55:00:\n * const result = endOfYear(new Date(2014, 8, 2, 11, 55, 00))\n * //=> Wed Dec 31 2014 23:59:59.999\n */\nexport function endOfYear<DateType extends Date>(\n  date: DateType | number | string,\n): DateType {\n  const _date = toDate(date);\n  setEndOfYear(_date);\n  return _date;\n}\n\nfunction setEndOfYear(date) {\n  const year = date.getFullYear();\n  date.setFullYear(year + 1, 0, 0);\n  date.setHours(23, 59, 59, 999);\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\n/**\n * @name isDate\n * @category Common Helpers\n * @summary Is the given value a date?\n *\n * @description\n * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.\n *\n * @param value - The value to check\n *\n * @returns True if the given value is a date\n *\n * @example\n * // For a valid date:\n * const result = isDate(new Date())\n * //=> true\n *\n * @example\n * // For an invalid date:\n * const result = isDate(new Date(NaN))\n * //=> true\n *\n * @example\n * // For some value:\n * const result = isDate('2014-02-31')\n * //=> false\n *\n * @example\n * // For an object:\n * const result = isDate({})\n * //=> false\n */\nexport function isDate(value: unknown): value is Date {\n  return (\n    value instanceof Date ||\n    (typeof value === \"object\" &&\n      Object.prototype.toString.call(value) === \"[object Date]\")\n  );\n}\n"
      },
      {
        "role": "assistant",
        "content": "/**\n * @name isInstanceOfDate\n * @category Common Helpers\n * @summary Check if the given value is an instance of Date\n *\n * @param value - The value to check\n *\n * @returns True if the given value is an instance of Date\n */\nexport function isInstanceOfDate(value: unknown): boolean {\n  return value instanceof Date;\n}\n\n/**\n * @name isObjectDate\n * @category Common Helpers\n * @summary Check if the given value is an object of type Date\n *\n * @param value - The value to check\n *\n * @returns True if the given value is an object of type Date\n */\nexport function isObjectDate(value: unknown): boolean {\n  return typeof value === \"object\" && Object.prototype.toString.call(value) === \"[object Date]\";\n}\n\n/**\n * @name isDate\n * @category Common Helpers\n * @summary Is the given value a date?\n *\n * @description\n * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.\n *\n * @param value - The value to check\n *\n * @returns True if the given value is a date\n *\n * @example\n * // For a valid date:\n * const result = isDate(new Date())\n * //=> true\n *\n * @example\n * // For an invalid date:\n * const result = isDate(new Date(NaN))\n * //=> true\n *\n * @example\n * // For some value:\n * const result = isDate('2014-02-31')\n * //=> false\n *\n * @example\n * // For an object:\n * const result = isDate({})\n * //=> false\n */\nexport function isDate(value: unknown): boolean {\n  return isInstanceOfDate(value) || isObjectDate(value);\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\nimport type { Locale } from \"../types.js\";\n\n/**\n * @category Locales\n * @summary German locale.\n * @language German\n * @iso-639-2 deu\n * @author Thomas Eilmsteiner [@DeMuu](https://github.com/DeMuu)\n * @author Asia [@asia-t](https://github.com/asia-t)\n * @author Van Vuong Ngo [@vanvuongngo](https://github.com/vanvuongngo)\n * @author RomanErnst [@pex](https://github.com/pex)\n * @author Philipp Keck [@Philipp91](https://github.com/Philipp91)\n */\nexport const de: Locale = {\n  code: \"de\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 4,\n  },\n};\n"
      },
      {
        "role": "assistant",
        "content": "import { formatDistance } from \"./_lib/formatDistance/index.js\";\nimport { formatLong } from \"./_lib/formatLong/index.js\";\nimport { formatRelative } from \"./_lib/formatRelative/index.js\";\nimport { localize } from \"./_lib/localize/index.js\";\nimport { match } from \"./_lib/match/index.js\";\nimport type { Locale } from \"../types.js\";\n\n/**\n * @category Locales\n * @summary German locale.\n * @language German\n * @iso-639-2 deu\n * @author Thomas Eilmsteiner [@DeMuu](https://github.com/DeMuu)\n * @author Asia [@asia-t](https://github.com/asia-t)\n * @author Van Vuong Ngo [@vanvuongngo](https://github.com/vanvuongngo)\n * @author RomanErnst [@pex](https://github.com/pex)\n * @author Philipp Keck [@Philipp91](https://github.com/Philipp91)\n */\nexport const de: Locale = {\n  code: \"de\",\n  formatDistance: formatDistance,\n  formatLong: formatLong,\n  formatRelative: formatRelative,\n  localize: localize,\n  match: match,\n  options: {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 4,\n  },\n};\n\nconst setLocaleOptions = () => {\n  de.options = {\n    weekStartsOn: 1 /* Monday */,\n    firstWeekContainsDate: 4,\n  };\n};\n\nexport { setLocaleOptions };"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatLong } from \"../../../types.js\";\nimport { buildFormatLongFn } from \"../../../_lib/buildFormatLongFn/index.js\";\n\nconst dateFormats = {\n  full: \"EEEE, d. MMMM y.\",\n  long: \"d. MMMM y.\",\n  medium: \"d. MMM y.\",\n  short: \"dd. MM. y.\",\n};\n\nconst timeFormats = {\n  full: \"HH:mm:ss (zzzz)\",\n  long: \"HH:mm:ss z\",\n  medium: \"HH:mm:ss\",\n  short: \"HH:mm\",\n};\n\nconst dateTimeFormats = {\n  full: \"{{date}} 'u' {{time}}\",\n  long: \"{{date}} 'u' {{time}}\",\n  medium: \"{{date}} {{time}}\",\n  short: \"{{date}} {{time}}\",\n};\n\nexport const formatLong: FormatLong = {\n  date: buildFormatLongFn({\n    formats: dateFormats,\n    defaultWidth: \"full\",\n  }),\n\n  time: buildFormatLongFn({\n    formats: timeFormats,\n    defaultWidth: \"full\",\n  }),\n\n  dateTime: buildFormatLongFn({\n    formats: dateTimeFormats,\n    defaultWidth: \"full\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { FormatLong } from \"../../../types.js\";\nimport { buildFormatLongFn } from \"../../../_lib/buildFormatLongFn/index.js\";\n\nconst dateFormats = {\n  full: \"EEEE, d. MMMM y.\",\n  long: \"d. MMMM y.\",\n  medium: \"d. MMM y.\",\n  short: \"dd. MM. y.\",\n};\n\nconst timeFormats = {\n  full: \"HH:mm:ss (zzzz)\",\n  long: \"HH:mm:ss z\",\n  medium: \"HH:mm:ss\",\n  short: \"HH:mm\",\n};\n\nconst dateTimeFormats = {\n  full: \"{{date}} 'u' {{time}}\",\n  long: \"{{date}} 'u' {{time}}\",\n  medium: \"{{date}} {{time}}\",\n  short: \"{{date}} {{time}}\",\n};\n\nconst buildDateFormats = () => {\n  return buildFormatLongFn({\n    formats: dateFormats,\n    defaultWidth: \"full\",\n  });\n};\n\nconst buildTimeFormats = () => {\n  return buildFormatLongFn({\n    formats: timeFormats,\n    defaultWidth: \"full\",\n  });\n};\n\nconst buildDateTimeFormats = () => {\n  return buildFormatLongFn({\n    formats: dateTimeFormats,\n    defaultWidth: \"full\",\n  });\n};\n\nexport const formatLong: FormatLong = {\n  date: buildDateFormats(),\n  time: buildTimeFormats(),\n  dateTime: buildDateTimeFormats(),\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { isSameWeek } from \"../../../../isSameWeek/index.js\";\nimport type {\n  FormatRelativeFn,\n  FormatRelativeFnOptions,\n} from \"../../../types.js\";\n\nconst weekdays = [\n  \"svētdienā\",\n  \"pirmdienā\",\n  \"otrdienā\",\n  \"trešdienā\",\n  \"ceturtdienā\",\n  \"piektdienā\",\n  \"sestdienā\",\n];\n\nconst formatRelativeLocale = {\n  lastWeek: <DateType extends Date>(\n    date: DateType,\n    baseDate: DateType,\n    options?: FormatRelativeFnOptions,\n  ): string => {\n    if (isSameWeek(date, baseDate, options)) {\n      return \"eeee 'plkst.' p\";\n    }\n\n    const weekday = weekdays[date.getDay()];\n    return \"'Pagājušā \" + weekday + \" plkst.' p\";\n  },\n  yesterday: \"'Vakar plkst.' p\",\n  today: \"'Šodien plkst.' p\",\n  tomorrow: \"'Rīt plkst.' p\",\n  nextWeek: <DateType extends Date>(\n    date: DateType,\n    baseDate: DateType,\n    options?: FormatRelativeFnOptions,\n  ): string => {\n    if (isSameWeek(date, baseDate, options)) {\n      return \"eeee 'plkst.' p\";\n    }\n\n    const weekday = weekdays[date.getDay()];\n    return \"'Nākamajā \" + weekday + \" plkst.' p\";\n  },\n  other: \"P\",\n};\n\nexport const formatRelative: FormatRelativeFn = (\n  token,\n  date,\n  baseDate,\n  options,\n) => {\n  const format = formatRelativeLocale[token];\n\n  if (typeof format === \"function\") {\n    return format(date, baseDate, options);\n  }\n\n  return format;\n};\n"
      },
      {
        "role": "assistant",
        "content": "```javascript\nimport { isSameWeek } from \"../../../../isSameWeek/index.js\";\nimport type {\n  FormatRelativeFn,\n  FormatRelativeFnOptions,\n} from \"../../../types.js\";\n\nconst weekdays = [\n  \"svētdienā\",\n  \"pirmdienā\",\n  \"otrdienā\",\n  \"trešdienā\",\n  \"ceturtdienā\",\n  \"piektdienā\",\n  \"sestdienā\",\n];\n\nconst getLastWeekFormat = (date, baseDate, options) => {\n  if (isSameWeek(date, baseDate, options)) {\n    return \"eeee 'plkst.' p\";\n  }\n\n  const weekday = weekdays[date.getDay()];\n  return \"'Pagājušā \" + weekday + \" plkst.' p\";\n};\n\nconst getNextWeekFormat = (date, baseDate, options) => {\n  if (isSameWeek(date, baseDate, options)) {\n    return \"eeee 'plkst.' p\";\n  }\n\n  const weekday = weekdays[date.getDay()];\n  return \"'Nākamajā \" + weekday + \" plkst.' p\";\n};\n\nconst formatRelativeLocale = {\n  lastWeek: getLastWeekFormat,\n  yesterday: \"'Vakar plkst.' p\",\n  today: \"'Šodien plkst.' p\",\n  tomorrow: \"'Rīt plkst.' p\",\n  nextWeek: getNextWeekFormat,\n  other: \"P\",\n};\n\nexport const formatRelative: FormatRelativeFn = (\n  token,\n  date,\n  baseDate,\n  options,\n) => {\n  const format = formatRelativeLocale[token];\n\n  if (typeof format === \"function\") {\n    return format(date, baseDate, options);\n  }\n\n  return format;\n};\n```"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatRelativeFn } from \"../../../types.js\";\n\nconst formatRelativeLocale = {\n  lastWeek: (date: Date): string => {\n    switch (date.getDay()) {\n      case 0:\n        return \"'prošle nedelje u' p\";\n      case 3:\n        return \"'prošle srede u' p\";\n      case 6:\n        return \"'prošle subote u' p\";\n      default:\n        return \"'prošli' EEEE 'u' p\";\n    }\n  },\n  yesterday: \"'juče u' p\",\n  today: \"'danas u' p\",\n  tomorrow: \"'sutra u' p\",\n  nextWeek: (date: Date): string => {\n    switch (date.getDay()) {\n      case 0:\n        return \"'sledeće nedelje u' p\";\n      case 3:\n        return \"'sledeću sredu u' p\";\n      case 6:\n        return \"'sledeću subotu u' p\";\n      default:\n        return \"'sledeći' EEEE 'u' p\";\n    }\n  },\n  other: \"P\",\n};\n\nexport const formatRelative: FormatRelativeFn = (\n  token,\n  date,\n  _baseDate,\n  _options,\n) => {\n  const format = formatRelativeLocale[token];\n\n  if (typeof format === \"function\") {\n    return format(date);\n  }\n\n  return format;\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { FormatRelativeFn } from \"../../../types.js\";\n\nconst formatRelativeLocale = {\n  lastWeek: (date: Date): string => {\n    switch (date.getDay()) {\n      case 0:\n        return \"'prošle nedelje u' p\";\n      case 3:\n        return \"'prošle srede u' p\";\n      case 6:\n        return \"'prošle subote u' p\";\n      default:\n        return \"'prošli' EEEE 'u' p\";\n    }\n  },\n  yesterday: \"'juče u' p\",\n  today: \"'danas u' p\",\n  tomorrow: \"'sutra u' p\",\n  nextWeek: (date: Date): string => {\n    switch (date.getDay()) {\n      case 0:\n        return \"'sledeće nedelje u' p\";\n      case 3:\n        return \"'sledeću sredu u' p\";\n      case 6:\n        return \"'sledeću subotu u' p\";\n      default:\n        return \"'sledeći' EEEE 'u' p\";\n    }\n  },\n  other: \"P\",\n};\n\nconst getFormatByToken = (token) => {\n  const format = formatRelativeLocale[token];\n  return typeof format === \"function\" ? format : format;\n};\n\nexport const formatRelative: FormatRelativeFn = (\n  token,\n  date,\n  _baseDate,\n  _options,\n) => {\n  const format = getFormatByToken(token);\n\n  if (typeof format === \"function\") {\n    return format(date);\n  }\n\n  return format;\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { transpose } from \"../../transpose/index.js\";\nimport { constructFrom } from \"../../constructFrom/index.js\";\nimport type { ParseFlags, ParserOptions } from \"./types.js\";\n\nconst TIMEZONE_UNIT_PRIORITY = 10;\n\nexport abstract class Setter {\n  public abstract priority: number;\n  public subPriority = 0;\n\n  public validate<DateType extends Date>(\n    _utcDate: DateType,\n    _options?: ParserOptions,\n  ): boolean {\n    return true;\n  }\n\n  public abstract set<DateType extends Date>(\n    utcDate: DateType,\n    flags: ParseFlags,\n    options: ParserOptions,\n  ): DateType | [DateType, ParseFlags];\n}\n\nexport class ValueSetter<Value> extends Setter {\n  constructor(\n    private value: Value,\n\n    private validateValue: <DateType extends Date>(\n      utcDate: DateType,\n      value: Value,\n      options: ParserOptions,\n    ) => boolean,\n\n    private setValue: <DateType extends Date>(\n      utcDate: DateType,\n      flags: ParseFlags,\n      value: Value,\n      options: ParserOptions,\n    ) => DateType | [DateType, ParseFlags],\n    public priority: number,\n    subPriority?: number,\n  ) {\n    super();\n    if (subPriority) {\n      this.subPriority = subPriority;\n    }\n  }\n\n  validate<DateType extends Date>(\n    date: DateType,\n    options: ParserOptions,\n  ): boolean {\n    return this.validateValue(date, this.value, options);\n  }\n\n  set<DateType extends Date>(\n    date: DateType,\n    flags: ParseFlags,\n    options: ParserOptions,\n  ): DateType | [DateType, ParseFlags] {\n    return this.setValue(date, flags, this.value, options);\n  }\n}\n\nexport class DateToSystemTimezoneSetter extends Setter {\n  priority = TIMEZONE_UNIT_PRIORITY;\n  subPriority = -1;\n  set<DateType extends Date>(date: DateType, flags: ParseFlags): DateType {\n    if (flags.timestampIsSet) return date;\n    return constructFrom(date, transpose(date, Date));\n  }\n}\n"
      },
      {
        "role": "assistant",
        "content": "```javascript\nimport { transpose } from \"../../transpose/index.js\";\nimport { constructFrom } from \"../../constructFrom/index.js\";\nimport type { ParseFlags, ParserOptions } from \"./types.js\";\n\nconst TIMEZONE_UNIT_PRIORITY = 10;\n\nexport abstract class Setter {\n  public abstract priority: number;\n  public subPriority = 0;\n\n  public validate<DateType extends Date>(\n    _utcDate: DateType,\n    _options?: ParserOptions,\n  ): boolean {\n    return true;\n  }\n\n  public abstract set<DateType extends Date>(\n    utcDate: DateType,\n    flags: ParseFlags,\n    options: ParserOptions,\n  ): DateType | [DateType, ParseFlags];\n}\n\nexport class ValueSetter<Value> extends Setter {\n  constructor(\n    private value: Value,\n    private validateValue: <DateType extends Date>(\n      utcDate: DateType,\n      value: Value,\n      options: ParserOptions,\n    ) => boolean,\n    private setValue: <DateType extends Date>(\n      utcDate: DateType,\n      flags: ParseFlags,\n      value: Value,\n      options: ParserOptions,\n    ) => DateType | [DateType, ParseFlags],\n    public priority: number,\n    subPriority?: number,\n  ) {\n    super();\n    if (subPriority) {\n      this.subPriority = subPriority;\n    }\n  }\n\n  validate<DateType extends Date>(\n    date: DateType,\n    options: ParserOptions,\n  ): boolean {\n    return this.validateValue(date, this.value, options);\n  }\n\n  set<DateType extends Date>(\n    date: DateType,\n    flags: ParseFlags,\n    options: ParserOptions,\n  ): DateType | [DateType, ParseFlags] {\n    return this.setValue(date, flags, this.value, options);\n  }\n}\n\nexport class DateToSystemTimezoneSetter extends Setter {\n  priority = TIMEZONE_UNIT_PRIORITY;\n  subPriority = -1;\n  \n  set<DateType extends Date>(date: DateType, flags: ParseFlags): DateType {\n    if (flags.timestampIsSet) return date;\n    return this.convertToSystemTimezone(date);\n  }\n\n  private convertToSystemTimezone<DateType extends Date>(date: DateType): DateType {\n    return constructFrom(date, transpose(date, Date));\n  }\n}\n```"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { toDate } from \"../toDate/index.js\";\n\n/**\n * @name setDayOfYear\n * @category Day Helpers\n * @summary Set the day of the year to the given date.\n *\n * @description\n * Set the day of the year to the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The date to be changed\n * @param dayOfYear - The day of the year of the new date\n *\n * @returns The new date with the day of the year set\n *\n * @example\n * // Set the 2nd day of the year to 2 July 2014:\n * const result = setDayOfYear(new Date(2014, 6, 2), 2)\n * //=> Thu Jan 02 2014 00:00:00\n */\nexport function setDayOfYear<DateType extends Date>(\n  date: DateType | number | string,\n  dayOfYear: number,\n): DateType {\n  const _date = toDate(date);\n  _date.setMonth(0);\n  _date.setDate(dayOfYear);\n  return _date;\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { toDate } from \"../toDate/index.js\";\n\n/**\n * @name setDayOfYear\n * @category Day Helpers\n * @summary Set the day of the year to the given date.\n *\n * @description\n * Set the day of the year to the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The date to be changed\n * @param dayOfYear - The day of the year of the new date\n *\n * @returns The new date with the day of the year set\n *\n * @example\n * // Set the 2nd day of the year to 2 July 2014:\n * const result = setDayOfYear(new Date(2014, 6, 2), 2)\n * //=> Thu Jan 02 2014 00:00:00\n */\nexport function setDayOfYear<DateType extends Date>(\n  date: DateType | number | string,\n  dayOfYear: number,\n): DateType {\n  const _date = toDate(date);\n  setMonthToJanuary(_date);\n  setDayOfMonth(_date, dayOfYear);\n  return _date;\n}\n\nfunction setMonthToJanuary(date: Date): void {\n  date.setMonth(0);\n}\n\nfunction setDayOfMonth(date: Date, day: number): void {\n  date.setDate(day);\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { addLeadingZeros } from \"../addLeadingZeros/index.js\";\nimport { setDefaultOptions } from \"../defaultOptions/index.js\";\n\nexport function assertType<T>(_: T): void {}\n\nexport function resetDefaultOptions(): void {\n  setDefaultOptions({});\n}\n\n// This makes sure we create the consistent offsets across timezones, no matter where these tests are ran.\nexport function generateOffset(originalDate: Date) {\n  // Add the timezone.\n  let offset = \"\";\n  const tzOffset = originalDate.getTimezoneOffset();\n\n  if (tzOffset !== 0) {\n    const absoluteOffset = Math.abs(tzOffset);\n    const hourOffset = addLeadingZeros(Math.trunc(absoluteOffset / 60), 2);\n    const minuteOffset = addLeadingZeros(absoluteOffset % 60, 2);\n    // If less than 0, the sign is +, because it is ahead of time.\n    const sign = tzOffset < 0 ? \"+\" : \"-\";\n\n    offset = `${sign}${hourOffset}:${minuteOffset}`;\n  } else {\n    offset = \"Z\";\n  }\n\n  return offset;\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { addLeadingZeros } from \"../addLeadingZeros/index.js\";\nimport { setDefaultOptions } from \"../defaultOptions/index.js\";\n\nexport function assertType<T>(_: T): void {}\n\nexport function resetDefaultOptions(): void {\n  setDefaultOptions({});\n}\n\nexport function generateOffset(originalDate: Date) {\n  const tzOffset = originalDate.getTimezoneOffset();\n  let offset = \"\";\n\n  if (tzOffset !== 0) {\n    offset = calculateOffset(tzOffset);\n  } else {\n    offset = \"Z\";\n  }\n\n  return offset;\n}\n\nfunction calculateOffset(tzOffset: number): string {\n  const absoluteOffset = Math.abs(tzOffset);\n  const hourOffset = addLeadingZeros(Math.trunc(absoluteOffset / 60), 2);\n  const minuteOffset = addLeadingZeros(absoluteOffset % 60, 2);\n  const sign = tzOffset < 0 ? \"+\" : \"-\";\n\n  return `${sign}${hourOffset}:${minuteOffset}`;\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { getRoundingMethod } from \"../_lib/getRoundingMethod/index.js\";\nimport { millisecondsInHour } from \"../constants/index.js\";\nimport { differenceInMilliseconds } from \"../differenceInMilliseconds/index.js\";\nimport type { RoundingOptions } from \"../types.js\";\n\n/**\n * The {@link differenceInHours} function options.\n */\nexport interface DifferenceInHoursOptions extends RoundingOptions {}\n\n/**\n * @name differenceInHours\n * @category Hour Helpers\n * @summary Get the number of hours between the given dates.\n *\n * @description\n * Get the number of hours between the given dates.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param dateLeft - The later date\n * @param dateRight - The earlier date\n * @param options - An object with options.\n *\n * @returns The number of hours\n *\n * @example\n * // How many hours are between 2 July 2014 06:50:00 and 2 July 2014 19:00:00?\n * const result = differenceInHours(\n *   new Date(2014, 6, 2, 19, 0),\n *   new Date(2014, 6, 2, 6, 50)\n * )\n * //=> 12\n */\nexport function differenceInHours<DateType extends Date>(\n  dateLeft: DateType | number | string,\n  dateRight: DateType | number | string,\n  options?: DifferenceInHoursOptions,\n): number {\n  const diff =\n    differenceInMilliseconds(dateLeft, dateRight) / millisecondsInHour;\n  return getRoundingMethod(options?.roundingMethod)(diff);\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { getRoundingMethod } from \"../_lib/getRoundingMethod/index.js\";\nimport { millisecondsInHour } from \"../constants/index.js\";\nimport { differenceInMilliseconds } from \"../differenceInMilliseconds/index.js\";\nimport type { RoundingOptions } from \"../types.js\";\n\n/**\n * The {@link differenceInHours} function options.\n */\nexport interface DifferenceInHoursOptions extends RoundingOptions {}\n\n/**\n * Calculate the number of hours between two dates.\n * @param dateLeft - The later date\n * @param dateRight - The earlier date\n * @returns The difference in hours\n */\nfunction calculateDifferenceInHours(dateLeft: Date | number | string, dateRight: Date | number | string): number {\n  const diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInHour;\n  return diff;\n}\n\n/**\n * Round the calculated difference based on the rounding method specified in options.\n * @param diff - The calculated difference in hours\n * @param options - An object with options\n * @returns The rounded difference in hours\n */\nfunction roundDifferenceInHours(diff: number, options?: DifferenceInHoursOptions): number {\n  return getRoundingMethod(options?.roundingMethod)(diff);\n}\n\n/**\n * Get the number of hours between the given dates.\n * @param dateLeft - The later date\n * @param dateRight - The earlier date\n * @param options - An object with options\n * @returns The number of hours\n */\nexport function differenceInHours<DateType extends Date>(\n  dateLeft: DateType | number | string,\n  dateRight: DateType | number | string,\n  options?: DifferenceInHoursOptions,\n): number {\n  const diff = calculateDifferenceInHours(dateLeft, dateRight);\n  return roundDifferenceInHours(diff, options);\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { toDate } from \"../toDate/index.js\";\n\n/**\n * @name isEqual\n * @category Common Helpers\n * @summary Are the given dates equal?\n *\n * @description\n * Are the given dates equal?\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param dateLeft - The first date to compare\n * @param dateRight - The second date to compare\n *\n * @returns The dates are equal\n *\n * @example\n * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?\n * const result = isEqual(\n *   new Date(2014, 6, 2, 6, 30, 45, 0),\n *   new Date(2014, 6, 2, 6, 30, 45, 500)\n * )\n * //=> false\n */\nexport function isEqual<DateType extends Date>(\n  leftDate: DateType | number | string,\n  rightDate: DateType | number | string,\n): boolean {\n  const _dateLeft = toDate(leftDate);\n  const _dateRight = toDate(rightDate);\n  return +_dateLeft === +_dateRight;\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { toDate } from \"../toDate/index.js\";\n\n/**\n * @name isEqual\n * @category Common Helpers\n * @summary Are the given dates equal?\n *\n * @description\n * Are the given dates equal?\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param dateLeft - The first date to compare\n * @param dateRight - The second date to compare\n *\n * @returns The dates are equal\n *\n * @example\n * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?\n * const result = isEqual(\n *   new Date(2014, 6, 2, 6, 30, 45, 0),\n *   new Date(2014, 6, 2, 6, 30, 45, 500)\n * )\n * //=> false\n */\nexport function isEqual<DateType extends Date>(\n  leftDate: DateType | number | string,\n  rightDate: DateType | number | string,\n): boolean {\n  const _dateLeft = toDate(leftDate);\n  const _dateRight = toDate(rightDate);\n  return areDatesEqual(_dateLeft, _dateRight);\n}\n\n/**\n * @name areDatesEqual\n * @param dateLeft - The first date to compare\n * @param dateRight - The second date to compare\n * @returns True if the dates are equal, false otherwise\n */\nfunction areDatesEqual(dateLeft: Date, dateRight: Date): boolean {\n  return +dateLeft === +dateRight;\n}"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatLong } from \"../../../types.js\";\nimport { buildFormatLongFn } from \"../../../_lib/buildFormatLongFn/index.js\";\n\nconst dateFormats = {\n  full: \"EEEE, d MMMM y\",\n  long: \"d MMMM y\",\n  medium: \"d MMM y\",\n  short: \"d/M/yy\",\n};\n\nconst timeFormats = {\n  full: \"h:mm:ss a zzzz\",\n  long: \"h:mm:ss a z\",\n  medium: \"h:mm:ss a\",\n  short: \"h:mm a\",\n};\n\nconst dateTimeFormats = {\n  full: \"{{date}} - {{time}}\",\n  long: \"{{date}} - {{time}}\",\n  medium: \"{{date}}, {{time}}\",\n  short: \"{{date}}, {{time}}\",\n};\n\nexport const formatLong: FormatLong = {\n  date: buildFormatLongFn({\n    formats: dateFormats,\n    defaultWidth: \"full\",\n  }),\n\n  time: buildFormatLongFn({\n    formats: timeFormats,\n    defaultWidth: \"full\",\n  }),\n\n  dateTime: buildFormatLongFn({\n    formats: dateTimeFormats,\n    defaultWidth: \"full\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { FormatLong } from \"../../../types.js\";\nimport { buildFormatLongFn } from \"../../../_lib/buildFormatLongFn/index.js\";\n\nconst dateFormats = {\n  full: \"EEEE, d MMMM y\",\n  long: \"d MMMM y\",\n  medium: \"d MMM y\",\n  short: \"d/M/yy\",\n};\n\nconst timeFormats = {\n  full: \"h:mm:ss a zzzz\",\n  long: \"h:mm:ss a z\",\n  medium: \"h:mm:ss a\",\n  short: \"h:mm a\",\n};\n\nconst dateTimeFormats = {\n  full: \"{{date}} - {{time}}\",\n  long: \"{{date}} - {{time}}\",\n  medium: \"{{date}}, {{time}}\",\n  short: \"{{date}}, {{time}}\",\n};\n\nconst formatDate = () => {\n  return buildFormatLongFn({\n    formats: dateFormats,\n    defaultWidth: \"full\",\n  });\n};\n\nconst formatTime = () => {\n  return buildFormatLongFn({\n    formats: timeFormats,\n    defaultWidth: \"full\",\n  });\n};\n\nconst formatDateTime = () => {\n  return buildFormatLongFn({\n    formats: dateTimeFormats,\n    defaultWidth: \"full\",\n  });\n};\n\nexport const formatLong: FormatLong = {\n  date: formatDate(),\n  time: formatTime(),\n  dateTime: formatDateTime(),\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\nimport type { Quarter } from \"../../../../types.js\";\n\nconst eraValues = {\n  narrow: [\"ق\", \"ب\"] as const,\n  abbreviated: [\"ق.م.\", \"ب.م.\"] as const,\n  wide: [\"قبل الميلاد\", \"بعد الميلاد\"] as const,\n};\n\nconst quarterValues = {\n  narrow: [\"1\", \"2\", \"3\", \"4\"] as const,\n  abbreviated: [\"ر1\", \"ر2\", \"ر3\", \"ر4\"] as const,\n  wide: [\n    \"الربع الأول\",\n    \"الربع الثاني\",\n    \"الربع الثالث\",\n    \"الربع الرابع\",\n  ] as const,\n};\n\nconst monthValues = {\n  narrow: [\"ج\", \"ف\", \"م\", \"أ\", \"م\", \"ج\", \"ج\", \"أ\", \"س\", \"أ\", \"ن\", \"د\"] as const,\n  abbreviated: [\n    \"جانـ\",\n    \"فيفـ\",\n    \"مارس\",\n    \"أفريل\",\n    \"مايـ\",\n    \"جوانـ\",\n    \"جويـ\",\n    \"أوت\",\n    \"سبتـ\",\n    \"أكتـ\",\n    \"نوفـ\",\n    \"ديسـ\",\n  ] as const,\n  wide: [\n    \"جانفي\",\n    \"فيفري\",\n    \"مارس\",\n    \"أفريل\",\n    \"ماي\",\n    \"جوان\",\n    \"جويلية\",\n    \"أوت\",\n    \"سبتمبر\",\n    \"أكتوبر\",\n    \"نوفمبر\",\n    \"ديسمبر\",\n  ] as const,\n};\n\nconst dayValues = {\n  narrow: [\"ح\", \"ن\", \"ث\", \"ر\", \"خ\", \"ج\", \"س\"] as const,\n  short: [\"أحد\", \"اثنين\", \"ثلاثاء\", \"أربعاء\", \"خميس\", \"جمعة\", \"سبت\"] as const,\n  abbreviated: [\"أحد\", \"اثنـ\", \"ثلا\", \"أربـ\", \"خميـ\", \"جمعة\", \"سبت\"] as const,\n  wide: [\n    \"الأحد\",\n    \"الاثنين\",\n    \"الثلاثاء\",\n    \"الأربعاء\",\n    \"الخميس\",\n    \"الجمعة\",\n    \"السبت\",\n  ] as const,\n};\n\nconst dayPeriodValues = {\n  narrow: {\n    am: \"ص\",\n    pm: \"م\",\n    midnight: \"ن\",\n    noon: \"ظ\",\n    morning: \"صباحاً\",\n    afternoon: \"بعد الظهر\",\n    evening: \"مساءاً\",\n    night: \"ليلاً\",\n  },\n  abbreviated: {\n    am: \"ص\",\n    pm: \"م\",\n    midnight: \"نصف الليل\",\n    noon: \"ظهر\",\n    morning: \"صباحاً\",\n    afternoon: \"بعد الظهر\",\n    evening: \"مساءاً\",\n    night: \"ليلاً\",\n  },\n  wide: {\n    am: \"ص\",\n    pm: \"م\",\n    midnight: \"نصف الليل\",\n    noon: \"ظهر\",\n    morning: \"صباحاً\",\n    afternoon: \"بعد الظهر\",\n    evening: \"مساءاً\",\n    night: \"ليلاً\",\n  },\n};\nconst formattingDayPeriodValues = {\n  narrow: {\n    am: \"ص\",\n    pm: \"م\",\n    midnight: \"ن\",\n    noon: \"ظ\",\n    morning: \"في الصباح\",\n    afternoon: \"بعد الظـهر\",\n    evening: \"في المساء\",\n    night: \"في الليل\",\n  },\n  abbreviated: {\n    am: \"ص\",\n    pm: \"م\",\n    midnight: \"نصف الليل\",\n    noon: \"ظهر\",\n    morning: \"في الصباح\",\n    afternoon: \"بعد الظهر\",\n    evening: \"في المساء\",\n    night: \"في الليل\",\n  },\n  wide: {\n    am: \"ص\",\n    pm: \"م\",\n    midnight: \"نصف الليل\",\n    noon: \"ظهر\",\n    morning: \"صباحاً\",\n    afternoon: \"بعد الظـهر\",\n    evening: \"في المساء\",\n    night: \"في الليل\",\n  },\n};\n\nconst ordinalNumber: LocalizeFn<number> = (dirtyNumber) => {\n  return String(dirtyNumber);\n};\n\nexport const localize: Localize = {\n  ordinalNumber: ordinalNumber,\n\n  era: buildLocalizeFn({\n    values: eraValues,\n    defaultWidth: \"wide\",\n  }),\n\n  quarter: buildLocalizeFn({\n    values: quarterValues,\n    defaultWidth: \"wide\",\n    argumentCallback: (quarter) => (Number(quarter) - 1) as Quarter,\n  }),\n\n  month: buildLocalizeFn({\n    values: monthValues,\n    defaultWidth: \"wide\",\n  }),\n\n  day: buildLocalizeFn({\n    values: dayValues,\n    defaultWidth: \"wide\",\n  }),\n\n  dayPeriod: buildLocalizeFn({\n    values: dayPeriodValues,\n    defaultWidth: \"wide\",\n    formattingValues: formattingDayPeriodValues,\n    defaultFormattingWidth: \"wide\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "```javascript\nimport { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\nimport type { Quarter } from \"../../../../types.js\";\n\nconst eraValues = {\n  narrow: [\"ق\", \"ب\"] as const,\n  abbreviated: [\"ق.م.\", \"ب.م.\"] as const,\n  wide: [\"قبل الميلاد\", \"بعد الميلاد\"] as const,\n};\n\nconst quarterValues = {\n  narrow: [\"1\", \"2\", \"3\", \"4\"] as const,\n  abbreviated: [\"ر1\", \"ر2\", \"ر3\", \"ر4\"] as const,\n  wide: [\n    \"الربع الأول\",\n    \"الربع الثاني\",\n    \"الربع الثالث\",\n    \"الربع الرابع\",\n  ] as const,\n};\n\nconst monthValues = {\n  narrow: [\"ج\", \"ف\", \"م\", \"أ\", \"م\", \"ج\", \"ج\", \"أ\", \"س\", \"أ\", \"ن\", \"د\"] as const,\n  abbreviated: [\n    \"جانـ\",\n    \"فيفـ\",\n    \"مارس\",\n    \"أفريل\",\n    \"مايـ\",\n    \"جوانـ\",\n    \"جويـ\",\n    \"أوت\",\n    \"سبتـ\",\n    \"أكتـ\",\n    \"نوفـ\",\n    \"ديسـ\",\n  ] as const,\n  wide: [\n    \"جانفي\",\n    \"فيفري\",\n    \"مارس\",\n    \"أفريل\",\n    \"ماي\",\n    \"جوان\",\n    \"جويلية\",\n    \"أوت\",\n    \"سبتمبر\",\n    \"أكتوبر\",\n    \"نوفمبر\",\n    \"ديسمبر\",\n  ] as const,\n};\n\nconst dayValues = {\n  narrow: [\"ح\", \"ن\", \"ث\", \"ر\", \"خ\", \"ج\", \"س\"] as const,\n  short: [\"أحد\", \"اثنين\", \"ثلاثاء\", \"أربعاء\", \"خميس\", \"جمعة\", \"سبت\"] as const,\n  abbreviated: [\"أحد\", \"اثنـ\", \"ثلا\", \"أربـ\", \"خميـ\", \"جمعة\", \"سبت\"] as const,\n  wide: [\n    \"الأحد\",\n    \"الاثنين\",\n    \"الثلاثاء\",\n    \"الأربعاء\",\n    \"الخميس\",\n    \"الجمعة\",\n    \"السبت\",\n  ] as const,\n};\n\nconst dayPeriodValues = {\n  narrow: {\n    am: \"ص\",\n    pm: \"م\",\n    midnight: \"ن\",\n    noon: \"ظ\",\n    morning: \"صباحاً\",\n    afternoon: \"بعد الظهر\",\n    evening: \"مساءاً\",\n    night: \"ليلاً\",\n  },\n  abbreviated: {\n    am: \"ص\",\n    pm: \"م\",\n    midnight: \"نصف الليل\",\n    noon: \"ظهر\",\n    morning: \"صباحاً\",\n    afternoon: \"بعد الظهر\",\n    evening: \"مساءاً\",\n    night: \"ليلاً\",\n  },\n  wide: {\n    am: \"ص\",\n    pm: \"م\",\n    midnight: \"نصف الليل\",\n    noon: \"ظهر\",\n    morning: \"صباحاً\",\n    afternoon: \"بعد الظهر\",\n    evening: \"مساءاً\",\n    night: \"ليلاً\",\n  },\n};\nconst formattingDayPeriodValues = {\n  narrow: {\n    am: \"ص\",\n    pm: \"م\",\n    midnight: \"ن\",\n    noon: \"ظ\",\n    morning: \"في الصباح\",\n    afternoon: \"بعد الظـهر\",\n    evening: \"في المساء\",\n    night: \"في الليل\",\n  },\n  abbreviated: {\n    am: \"ص\",\n    pm: \"م\",\n    midnight: \"نصف الليل\",\n    noon: \"ظهر\",\n    morning"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\nimport { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\n\nconst eraValues = {\n  narrow: [\"pr.n.e.\", \"AD\"] as const,\n  abbreviated: [\"pr. Hr.\", \"po. Hr.\"] as const,\n  wide: [\"Prije Hrista\", \"Poslije Hrista\"] as const,\n};\n\nconst quarterValues = {\n  narrow: [\"1.\", \"2.\", \"3.\", \"4.\"] as const,\n  abbreviated: [\"1. kv.\", \"2. kv.\", \"3. kv.\", \"4. kv.\"] as const,\n  wide: [\"1. kvartal\", \"2. kvartal\", \"3. kvartal\", \"4. kvartal\"] as const,\n};\n\nconst monthValues = {\n  narrow: [\n    \"1.\",\n    \"2.\",\n    \"3.\",\n    \"4.\",\n    \"5.\",\n    \"6.\",\n    \"7.\",\n    \"8.\",\n    \"9.\",\n    \"10.\",\n    \"11.\",\n    \"12.\",\n  ] as const,\n  abbreviated: [\n    \"jan\",\n    \"feb\",\n    \"mar\",\n    \"apr\",\n    \"maj\",\n    \"jun\",\n    \"jul\",\n    \"avg\",\n    \"sep\",\n    \"okt\",\n    \"nov\",\n    \"dec\",\n  ] as const,\n  wide: [\n    \"januar\",\n    \"februar\",\n    \"mart\",\n    \"april\",\n    \"maj\",\n    \"juni\",\n    \"juli\",\n    \"avgust\",\n    \"septembar\",\n    \"oktobar\",\n    \"novembar\",\n    \"decembar\",\n  ] as const,\n};\n\nconst formattingMonthValues = {\n  narrow: [\n    \"1.\",\n    \"2.\",\n    \"3.\",\n    \"4.\",\n    \"5.\",\n    \"6.\",\n    \"7.\",\n    \"8.\",\n    \"9.\",\n    \"10.\",\n    \"11.\",\n    \"12.\",\n  ] as const,\n  abbreviated: [\n    \"jan\",\n    \"feb\",\n    \"mar\",\n    \"apr\",\n    \"maj\",\n    \"jun\",\n    \"jul\",\n    \"avg\",\n    \"sep\",\n    \"okt\",\n    \"nov\",\n    \"dec\",\n  ] as const,\n  wide: [\n    \"januar\",\n    \"februar\",\n    \"mart\",\n    \"april\",\n    \"maj\",\n    \"juni\",\n    \"juli\",\n    \"avgust\",\n    \"septembar\",\n    \"oktobar\",\n    \"novembar\",\n    \"decembar\",\n  ] as const,\n};\n\nconst dayValues = {\n  narrow: [\"N\", \"P\", \"U\", \"S\", \"Č\", \"P\", \"S\"] as const,\n  short: [\"ned\", \"pon\", \"uto\", \"sre\", \"čet\", \"pet\", \"sub\"] as const,\n  abbreviated: [\"ned\", \"pon\", \"uto\", \"sre\", \"čet\", \"pet\", \"sub\"] as const,\n  wide: [\n    \"nedjelja\",\n    \"ponedjeljak\",\n    \"utorak\",\n    \"srijeda\",\n    \"četvrtak\",\n    \"petak\",\n    \"subota\",\n  ] as const,\n};\n\nconst dayPeriodValues = {\n  narrow: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"ponoć\",\n    noon: \"podne\",\n    morning: \"ujutru\",\n    afternoon: \"popodne\",\n    evening: \"uveče\",\n    night: \"noću\",\n  },\n  abbreviated: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"ponoć\",\n    noon: \"podne\",\n    morning: \"ujutru\",\n    afternoon: \"popodne\",\n    evening: \"uveče\",\n    night: \"noću\",\n  },\n  wide: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"ponoć\",\n    noon: \"podne\",\n    morning: \"ujutru\",\n    afternoon: \"poslije podne\",\n    evening: \"uveče\",\n    night: \"noću\",\n  },\n};\n\nconst formattingDayPeriodValues = {\n  narrow: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"ponoć\",\n    noon: \"podne\",\n    morning: \"ujutru\",\n    afternoon: \"popodne\",\n    evening: \"uveče\",\n    night: \"noću\",\n  },\n  abbreviated: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"ponoć\",\n    noon: \"podne\",\n    morning: \"ujutru\",\n    afternoon: \"popodne\",\n    evening: \"uveče\",\n    night: \"noću\",\n  },\n  wide: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"ponoć\",\n    noon: \"podne\",\n    morning: \"ujutru\",\n    afternoon: \"poslije podne\",\n    evening: \"uveče\",\n    night: \"noću\",\n  },\n};\n\nconst ordinalNumber: LocalizeFn<number> = (dirtyNumber, _options) => {\n  const number = Number(dirtyNumber);\n  return String(number) + \".\";\n};\n\nexport const localize: Localize = {\n  ordinalNumber,\n\n  era: buildLocalizeFn({\n    values: eraValues,\n    defaultWidth: \"wide\",\n  }),\n\n  quarter: buildLocalizeFn({\n    values: quarterValues,\n    defaultWidth: \"wide\",\n    argumentCallback: (quarter) => quarter - 1,\n  }),\n\n  month: buildLocalizeFn({\n    values: monthValues,\n    defaultWidth: \"wide\",\n    formattingValues: formattingMonthValues,\n    defaultFormattingWidth: \"wide\",\n  }),\n\n  day: buildLocalizeFn({\n    values: dayValues,\n    defaultWidth: \"wide\",\n  }),\n\n  dayPeriod: buildLocalizeFn({\n    values: dayPeriodValues,\n    defaultWidth: \"wide\",\n    formattingValues: formattingDayPeriodValues,\n    defaultFormattingWidth: \"wide\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "```javascript\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\nimport { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\n\nconst eraValues = {\n  narrow: [\"pr.n.e.\", \"AD\"] as const,\n  abbreviated: [\"pr. Hr.\", \"po. Hr.\"] as const,\n  wide: [\"Prije Hrista\", \"Poslije Hrista\"] as const,\n};\n\nconst quarterValues = {\n  narrow: [\"1.\", \"2.\", \"3.\", \"4.\"] as const,\n  abbreviated: [\"1. kv.\", \"2. kv.\", \"3. kv.\", \"4. kv.\"] as const,\n  wide: [\"1. kvartal\", \"2. kvartal\", \"3. kvartal\", \"4. kvartal\"] as const,\n};\n\nconst monthValues = {\n  narrow: [\n    \"1.\",\n    \"2.\",\n    \"3.\",\n    \"4.\",\n    \"5.\",\n    \"6.\",\n    \"7.\",\n    \"8.\",\n    \"9.\",\n    \"10.\",\n    \"11.\",\n    \"12.\",\n  ] as const,\n  abbreviated: [\n    \"jan\",\n    \"feb\",\n    \"mar\",\n    \"apr\",\n    \"maj\",\n    \"jun\",\n    \"jul\",\n    \"avg\",\n    \"sep\",\n    \"okt\",\n    \"nov\",\n    \"dec\",\n  ] as const,\n  wide: [\n    \"januar\",\n    \"februar\",\n    \"mart\",\n    \"april\",\n    \"maj\",\n    \"juni\",\n    \"juli\",\n    \"avgust\",\n    \"septembar\",\n    \"oktobar\",\n    \"novembar\",\n    \"decembar\",\n  ] as const,\n};\n\nconst dayValues = {\n  narrow: [\"N\", \"P\", \"U\", \"S\", \"Č\", \"P\", \"S\"] as const,\n  short: [\"ned\", \"pon\", \"uto\", \"sre\", \"čet\", \"pet\", \"sub\"] as const,\n  abbreviated: [\"ned\", \"pon\", \"uto\", \"sre\", \"čet\", \"pet\", \"sub\"] as const,\n  wide: [\n    \"nedjelja\",\n    \"ponedjeljak\",\n    \"utorak\",\n    \"srijeda\",\n    \"četvrtak\",\n    \"petak\",\n    \"subota\",\n  ] as const,\n};\n\nconst dayPeriodValues = {\n  narrow: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"ponoć\",\n    noon: \"podne\",\n    morning: \"ujutru\",\n    afternoon: \"popodne\",\n    evening: \"uveče\",\n    night: \"noću\",\n  },\n  abbreviated: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"ponoć\",\n    noon: \"podne\",\n    morning: \"ujutru\",\n    afternoon: \"popodne\",\n    evening: \"uveče\",\n    night: \"noću\",\n  },\n  wide: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"ponoć\",\n    noon: \"podne\",\n    morning: \"ujutru\",\n    afternoon: \"poslije podne\",\n    evening: \"uveče\",\n    night: \"noću\",\n  },\n};\n\nconst formattingDayPeriodValues = {\n  narrow: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"ponoć\",\n    noon: \"podne\",\n    morning: \"ujutru\",\n    afternoon: \"popodne\",\n    evening: \"uveče\",\n    night: \"noću\",\n  },\n  abbreviated: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"ponoć\",\n    noon: \"podne\",\n    morning: \"ujutru\",\n    afternoon: \"popodne\",\n    evening: \"uveče\",\n    night: \"noću\",\n  },\n  wide: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"ponoć\",\n    noon: \"podne\",\n    morning: \"ujutru\",\n    afternoon: \"poslije podne\",\n    evening: \"uveče\",\n    night: \"noću\",\n  },\n};\n\nconst ordinalNumber: LocalizeFn<number> = (dirtyNumber, _options) => {\n  const number = Number(dirtyNumber);\n  return String(number) + \".\";\n};\n\nconst buildEraLocalizeFn = () => buildLocalizeFn({\n  values: eraValues,\n  defaultWidth: \"wide\",\n});\n\nconst buildQuarterLocalizeFn = () => buildLocalizeFn({\n"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype FormatDistanceTokenValue =\n  | string\n  | {\n      one: string;\n      other: string;\n    };\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: \"menos de un segundo\",\n    other: \"menos de {{count}} segundos\",\n  },\n\n  xSeconds: {\n    one: \"1 segundo\",\n    other: \"{{count}} segundos\",\n  },\n\n  halfAMinute: \"medio minuto\",\n\n  lessThanXMinutes: {\n    one: \"menos de un minuto\",\n    other: \"menos de {{count}} minutos\",\n  },\n\n  xMinutes: {\n    one: \"1 minuto\",\n    other: \"{{count}} minutos\",\n  },\n\n  aboutXHours: {\n    one: \"alrededor de 1 hora\",\n    other: \"alrededor de {{count}} horas\",\n  },\n\n  xHours: {\n    one: \"1 hora\",\n    other: \"{{count}} horas\",\n  },\n\n  xDays: {\n    one: \"1 día\",\n    other: \"{{count}} días\",\n  },\n\n  aboutXWeeks: {\n    one: \"alrededor de 1 semana\",\n    other: \"alrededor de {{count}} semanas\",\n  },\n\n  xWeeks: {\n    one: \"1 semana\",\n    other: \"{{count}} semanas\",\n  },\n\n  aboutXMonths: {\n    one: \"alrededor de 1 mes\",\n    other: \"alrededor de {{count}} meses\",\n  },\n\n  xMonths: {\n    one: \"1 mes\",\n    other: \"{{count}} meses\",\n  },\n\n  aboutXYears: {\n    one: \"alrededor de 1 año\",\n    other: \"alrededor de {{count}} años\",\n  },\n\n  xYears: {\n    one: \"1 año\",\n    other: \"{{count}} años\",\n  },\n\n  overXYears: {\n    one: \"más de 1 año\",\n    other: \"más de {{count}} años\",\n  },\n\n  almostXYears: {\n    one: \"casi 1 año\",\n    other: \"casi {{count}} años\",\n  },\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  let result;\n\n  const tokenValue = formatDistanceLocale[token];\n  if (typeof tokenValue === \"string\") {\n    result = tokenValue;\n  } else if (count === 1) {\n    result = tokenValue.one;\n  } else {\n    result = tokenValue.other.replace(\"{{count}}\", count.toString());\n  }\n\n  if (options?.addSuffix) {\n    if (options.comparison && options.comparison > 0) {\n      return \"en \" + result;\n    } else {\n      return \"hace \" + result;\n    }\n  }\n\n  return result;\n};\n"
      },
      {
        "role": "assistant",
        "content": "```javascript\nimport type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype FormatDistanceTokenValue =\n  | string\n  | {\n      one: string;\n      other: string;\n    };\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: \"menos de un segundo\",\n    other: \"menos de {{count}} segundos\",\n  },\n\n  xSeconds: {\n    one: \"1 segundo\",\n    other: \"{{count}} segundos\",\n  },\n\n  halfAMinute: \"medio minuto\",\n\n  lessThanXMinutes: {\n    one: \"menos de un minuto\",\n    other: \"menos de {{count}} minutos\",\n  },\n\n  xMinutes: {\n    one: \"1 minuto\",\n    other: \"{{count}} minutos\",\n  },\n\n  aboutXHours: {\n    one: \"alrededor de 1 hora\",\n    other: \"alrededor de {{count}} horas\",\n  },\n\n  xHours: {\n    one: \"1 hora\",\n    other: \"{{count}} horas\",\n  },\n\n  xDays: {\n    one: \"1 día\",\n    other: \"{{count}} días\",\n  },\n\n  aboutXWeeks: {\n    one: \"alrededor de 1 semana\",\n    other: \"alrededor de {{count}} semanas\",\n  },\n\n  xWeeks: {\n    one: \"1 semana\",\n    other: \"{{count}} semanas\",\n  },\n\n  aboutXMonths: {\n    one: \"alrededor de 1 mes\",\n    other: \"alrededor de {{count}} meses\",\n  },\n\n  xMonths: {\n    one: \"1 mes\",\n    other: \"{{count}} meses\",\n  },\n\n  aboutXYears: {\n    one: \"alrededor de 1 año\",\n    other: \"alrededor de {{count}} años\",\n  },\n\n  xYears: {\n    one: \"1 año\",\n    other: \"{{count}} años\",\n  },\n\n  overXYears: {\n    one: \"más de 1 año\",\n    other: \"más de {{count}} años\",\n  },\n\n  almostXYears: {\n    one: \"casi 1 año\",\n    other: \"casi {{count}} años\",\n  },\n};\n\nconst getResult = (tokenValue, count) => {\n  let result;\n  if (typeof tokenValue === \"string\") {\n    result = tokenValue;\n  } else if (count === 1) {\n    result = tokenValue.one;\n  } else {\n    result = tokenValue.other.replace(\"{{count}}\", count.toString());\n  }\n  return result;\n};\n\nconst addSuffix = (result, options) => {\n  if (options?.addSuffix) {\n    if (options.comparison && options.comparison > 0) {\n      return \"en \" + result;\n    } else {\n      return \"hace \" + result;\n    }\n  }\n  return result;\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  const tokenValue = formatDistanceLocale[token];\n  const result = getResult(tokenValue, count);\n  return addSuffix(result, options);\n};\n```"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype FormatDistanceTokenValue =\n  | string\n  | {\n      one: string;\n      two: string;\n      other: string;\n    };\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: \"פחות משנייה\",\n    two: \"פחות משתי שניות\",\n    other: \"פחות מ־{{count}} שניות\",\n  },\n\n  xSeconds: {\n    one: \"שנייה\",\n    two: \"שתי שניות\",\n    other: \"{{count}} שניות\",\n  },\n\n  halfAMinute: \"חצי דקה\",\n\n  lessThanXMinutes: {\n    one: \"פחות מדקה\",\n    two: \"פחות משתי דקות\",\n    other: \"פחות מ־{{count}} דקות\",\n  },\n\n  xMinutes: {\n    one: \"דקה\",\n    two: \"שתי דקות\",\n    other: \"{{count}} דקות\",\n  },\n\n  aboutXHours: {\n    one: \"כשעה\",\n    two: \"כשעתיים\",\n    other: \"כ־{{count}} שעות\",\n  },\n\n  xHours: {\n    one: \"שעה\",\n    two: \"שעתיים\",\n    other: \"{{count}} שעות\",\n  },\n\n  xDays: {\n    one: \"יום\",\n    two: \"יומיים\",\n    other: \"{{count}} ימים\",\n  },\n\n  aboutXWeeks: {\n    one: \"כשבוע\",\n    two: \"כשבועיים\",\n    other: \"כ־{{count}} שבועות\",\n  },\n\n  xWeeks: {\n    one: \"שבוע\",\n    two: \"שבועיים\",\n    other: \"{{count}} שבועות\",\n  },\n\n  aboutXMonths: {\n    one: \"כחודש\",\n    two: \"כחודשיים\",\n    other: \"כ־{{count}} חודשים\",\n  },\n\n  xMonths: {\n    one: \"חודש\",\n    two: \"חודשיים\",\n    other: \"{{count}} חודשים\",\n  },\n\n  aboutXYears: {\n    one: \"כשנה\",\n    two: \"כשנתיים\",\n    other: \"כ־{{count}} שנים\",\n  },\n\n  xYears: {\n    one: \"שנה\",\n    two: \"שנתיים\",\n    other: \"{{count}} שנים\",\n  },\n\n  overXYears: {\n    one: \"יותר משנה\",\n    two: \"יותר משנתיים\",\n    other: \"יותר מ־{{count}} שנים\",\n  },\n\n  almostXYears: {\n    one: \"כמעט שנה\",\n    two: \"כמעט שנתיים\",\n    other: \"כמעט {{count}} שנים\",\n  },\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  // Return word instead of `in one day` or `one day ago`\n  if (token === \"xDays\" && options?.addSuffix && count <= 2) {\n    if (options.comparison && options.comparison > 0) {\n      return count === 1 ? \"מחר\" : \"מחרתיים\";\n    }\n\n    return count === 1 ? \"אתמול\" : \"שלשום\";\n  }\n\n  let result;\n\n  const tokenValue = formatDistanceLocale[token];\n  if (typeof tokenValue === \"string\") {\n    result = tokenValue;\n  } else if (count === 1) {\n    result = tokenValue.one;\n  } else if (count === 2) {\n    result = tokenValue.two;\n  } else {\n    result = tokenValue.other.replace(\"{{count}}\", String(count));\n  }\n\n  if (options?.addSuffix) {\n    if (options.comparison && options.comparison > 0) {\n      return \"בעוד \" + result;\n    } else {\n      return \"לפני \" + result;\n    }\n  }\n\n  return result;\n};\n"
      },
      {
        "role": "assistant",
        "content": "```js\nimport type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype FormatDistanceTokenValue =\n  | string\n  | {\n      one: string;\n      two: string;\n      other: string;\n    };\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: \"פחות משנייה\",\n    two: \"פחות משתי שניות\",\n    other: \"פחות מ־{{count}} שניות\",\n  },\n\n  xSeconds: {\n    one: \"שנייה\",\n    two: \"שתי שניות\",\n    other: \"{{count}} שניות\",\n  },\n\n  halfAMinute: \"חצי דקה\",\n\n  lessThanXMinutes: {\n    one: \"פחות מדקה\",\n    two: \"פחות משתי דקות\",\n    other: \"פחות מ־{{count}} דקות\",\n  },\n\n  xMinutes: {\n    one: \"דקה\",\n    two: \"שתי דקות\",\n    other: \"{{count}} דקות\",\n  },\n\n  aboutXHours: {\n    one: \"כשעה\",\n    two: \"כשעתיים\",\n    other: \"כ־{{count}} שעות\",\n  },\n\n  xHours: {\n    one: \"שעה\",\n    two: \"שעתיים\",\n    other: \"{{count}} שעות\",\n  },\n\n  xDays: {\n    one: \"יום\",\n    two: \"יומיים\",\n    other: \"{{count}} ימים\",\n  },\n\n  aboutXWeeks: {\n    one: \"כשבוע\",\n    two: \"כשבועיים\",\n    other: \"כ־{{count}} שבועות\",\n  },\n\n  xWeeks: {\n    one: \"שבוע\",\n    two: \"שבועיים\",\n    other: \"{{count}} שבועות\",\n  },\n\n  aboutXMonths: {\n    one: \"כחודש\",\n    two: \"כחודשיים\",\n    other: \"כ־{{count}} חודשים\",\n  },\n\n  xMonths: {\n    one: \"חודש\",\n    two: \"חודשיים\",\n    other: \"{{count}} חודשים\",\n  },\n\n  aboutXYears: {\n    one: \"כשנה\",\n    two: \"כשנתיים\",\n    other: \"כ־{{count}} שנים\",\n  },\n\n  xYears: {\n    one: \"שנה\",\n    two: \"שנתיים\",\n    other: \"{{count}} שנים\",\n  },\n\n  overXYears: {\n    one: \"יותר משנה\",\n    two: \"יותר משנתיים\",\n    other: \"יותר מ־{{count}} שנים\",\n  },\n\n  almostXYears: {\n    one: \"כמעט שנה\",\n    two: \"כמעט שנתיים\",\n    other: \"כמעט {{count}} שנים\",\n  },\n};\n\nconst getLocalizedTokenValue = (token, count) => {\n  const tokenValue = formatDistanceLocale[token];\n  if (typeof tokenValue === \"string\") {\n    return tokenValue;\n  } else if (count === 1) {\n    return tokenValue.one;\n  } else if (count === 2) {\n    return tokenValue.two;\n  } else {\n    return tokenValue.other.replace(\"{{count}}\", String(count));\n  }\n};\n\nconst getSuffix = (options, result) => {\n  if (options && options.addSuffix) {\n    if (options.comparison && options.comparison > 0) {\n      return \"בעוד \" + result;\n    } else {\n      return \"לפני \" + result;\n    }\n  }\n  return result;\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  if (token === \"xDays\" &&"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype FormatDistanceTokenValue =\n  | string\n  | {\n      one: string;\n      other: string;\n      oneWithSuffix?: string;\n      otherWithSuffix?: string;\n    };\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: \"1びょうみまん\",\n    other: \"{{count}}びょうみまん\",\n    oneWithSuffix: \"やく1びょう\",\n    otherWithSuffix: \"やく{{count}}びょう\",\n  },\n\n  xSeconds: {\n    one: \"1びょう\",\n    other: \"{{count}}びょう\",\n  },\n\n  halfAMinute: \"30びょう\",\n\n  lessThanXMinutes: {\n    one: \"1ぷんみまん\",\n    other: \"{{count}}ふんみまん\",\n    oneWithSuffix: \"やく1ぷん\",\n    otherWithSuffix: \"やく{{count}}ふん\",\n  },\n\n  xMinutes: {\n    one: \"1ぷん\",\n    other: \"{{count}}ふん\",\n  },\n\n  aboutXHours: {\n    one: \"やく1じかん\",\n    other: \"やく{{count}}じかん\",\n  },\n\n  xHours: {\n    one: \"1じかん\",\n    other: \"{{count}}じかん\",\n  },\n\n  xDays: {\n    one: \"1にち\",\n    other: \"{{count}}にち\",\n  },\n\n  aboutXWeeks: {\n    one: \"やく1しゅうかん\",\n    other: \"やく{{count}}しゅうかん\",\n  },\n\n  xWeeks: {\n    one: \"1しゅうかん\",\n    other: \"{{count}}しゅうかん\",\n  },\n\n  aboutXMonths: {\n    one: \"やく1かげつ\",\n    other: \"やく{{count}}かげつ\",\n  },\n\n  xMonths: {\n    one: \"1かげつ\",\n    other: \"{{count}}かげつ\",\n  },\n\n  aboutXYears: {\n    one: \"やく1ねん\",\n    other: \"やく{{count}}ねん\",\n  },\n\n  xYears: {\n    one: \"1ねん\",\n    other: \"{{count}}ねん\",\n  },\n\n  overXYears: {\n    one: \"1ねんいじょう\",\n    other: \"{{count}}ねんいじょう\",\n  },\n\n  almostXYears: {\n    one: \"1ねんちかく\",\n    other: \"{{count}}ねんちかく\",\n  },\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  options = options || {};\n\n  let result;\n\n  const tokenValue = formatDistanceLocale[token];\n  if (typeof tokenValue === \"string\") {\n    result = tokenValue;\n  } else if (count === 1) {\n    if (options.addSuffix && tokenValue.oneWithSuffix) {\n      result = tokenValue.oneWithSuffix;\n    } else {\n      result = tokenValue.one;\n    }\n  } else {\n    if (options.addSuffix && tokenValue.otherWithSuffix) {\n      result = tokenValue.otherWithSuffix.replace(\"{{count}}\", String(count));\n    } else {\n      result = tokenValue.other.replace(\"{{count}}\", String(count));\n    }\n  }\n\n  if (options.addSuffix) {\n    if (options.comparison && options.comparison > 0) {\n      return result + \"あと\";\n    } else {\n      return result + \"まえ\";\n    }\n  }\n\n  return result;\n};\n"
      },
      {
        "role": "assistant",
        "content": "Here is the refactored code with extracted methods for enhanced modularity and readability:\n\n```javascript\nimport type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype FormatDistanceTokenValue =\n  | string\n  | {\n      one: string;\n      other: string;\n      oneWithSuffix?: string;\n      otherWithSuffix?: string;\n    };\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: \"1びょうみまん\",\n    other: \"{{count}}びょうみまん\",\n    oneWithSuffix: \"やく1びょう\",\n    otherWithSuffix: \"やく{{count}}びょう\",\n  },\n\n  xSeconds: {\n    one: \"1びょう\",\n    other: \"{{count}}びょう\",\n  },\n\n  halfAMinute: \"30びょう\",\n\n  lessThanXMinutes: {\n    one: \"1ぷんみまん\",\n    other: \"{{count}}ふんみまん\",\n    oneWithSuffix: \"やく1ぷん\",\n    otherWithSuffix: \"やく{{count}}ふん\",\n  },\n\n  xMinutes: {\n    one: \"1ぷん\",\n    other: \"{{count}}ふん\",\n  },\n\n  aboutXHours: {\n    one: \"やく1じかん\",\n    other: \"やく{{count}}じかん\",\n  },\n\n  xHours: {\n    one: \"1じかん\",\n    other: \"{{count}}じかん\",\n  },\n\n  xDays: {\n    one: \"1にち\",\n    other: \"{{count}}にち\",\n  },\n\n  aboutXWeeks: {\n    one: \"やく1しゅうかん\",\n    other: \"やく{{count}}しゅうかん\",\n  },\n\n  xWeeks: {\n    one: \"1しゅうかん\",\n    other: \"{{count}}しゅうかん\",\n  },\n\n  aboutXMonths: {\n    one: \"やく1かげつ\",\n    other: \"やく{{count}}かげつ\",\n  },\n\n  xMonths: {\n    one: \"1かげつ\",\n    other: \"{{count}}かげつ\",\n  },\n\n  aboutXYears: {\n    one: \"やく1ねん\",\n    other: \"やく{{count}}ねん\",\n  },\n\n  xYears: {\n    one: \"1ねん\",\n    other: \"{{count}}ねん\",\n  },\n\n  overXYears: {\n    one: \"1ねんいじょう\",\n    other: \"{{count}}ねんいじょう\",\n  },\n\n  almostXYears: {\n    one: \"1ねんちかく\",\n    other: \"{{count}}ねんちかく\",\n  },\n};\n\nconst getLocalizedTokenValue = (token, count, options) => {\n  const tokenValue = formatDistanceLocale[token];\n  if (typeof tokenValue === \"string\") {\n    return tokenValue;\n  } else if (count === 1) {\n    return options.addSuffix && tokenValue.oneWithSuffix ? tokenValue.oneWithSuffix : tokenValue.one;\n  } else {\n    return options.addSuffix && tokenValue.otherWithSuffix\n      ? tokenValue.otherWithSuffix.replace(\"{{count}}\", String(count))\n      : tokenValue.other.replace(\"{{count}}\", String(count));\n  }\n};\n\nconst addSuffix = (result, options) => {\n  if (options.addSuffix) {\n    return options.comparison && options.comparison > 0 ? result + \"あと\" : result + \"まえ\";\n  }\n  return result;\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  options = options || {};\n\n  let result = getLocalizedTokenValue(token, count, options);\n\n  return addSuffix(result, options);\n};\n```\n\nBy extracting the `getLocalizedTokenValue` and `addSuffix` methods, the code is now more modular and readable, with each method having a clear and distinct purpose."
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\nimport { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\n\nconst eraValues = {\n  narrow: [\"НТӨ\", \"НТ\"] as const,\n  abbreviated: [\"НТӨ\", \"НТ\"] as const,\n  wide: [\"нийтийн тооллын өмнөх\", \"нийтийн тооллын\"] as const,\n};\n\nconst quarterValues = {\n  narrow: [\"I\", \"II\", \"III\", \"IV\"] as const,\n  abbreviated: [\"I улирал\", \"II улирал\", \"III улирал\", \"IV улирал\"] as const,\n  wide: [\"1-р улирал\", \"2-р улирал\", \"3-р улирал\", \"4-р улирал\"] as const,\n};\n\n// Note: in English, the names of days of the week and months are capitalized.\n// If you are making a new locale based on this one, check if the same is true for the language you're working on.\n// Generally, formatted dates should look like they are in the middle of a sentence,\n// e.g. in Spanish language the weekdays and months should be in the lowercase.\nconst monthValues = {\n  narrow: [\n    \"I\",\n    \"II\",\n    \"III\",\n    \"IV\",\n    \"V\",\n    \"VI\",\n    \"VII\",\n    \"VIII\",\n    \"IX\",\n    \"X\",\n    \"XI\",\n    \"XII\",\n  ] as const,\n  abbreviated: [\n    \"1-р сар\",\n    \"2-р сар\",\n    \"3-р сар\",\n    \"4-р сар\",\n    \"5-р сар\",\n    \"6-р сар\",\n    \"7-р сар\",\n    \"8-р сар\",\n    \"9-р сар\",\n    \"10-р сар\",\n    \"11-р сар\",\n    \"12-р сар\",\n  ] as const,\n  wide: [\n    \"Нэгдүгээр сар\",\n    \"Хоёрдугаар сар\",\n    \"Гуравдугаар сар\",\n    \"Дөрөвдүгээр сар\",\n    \"Тавдугаар сар\",\n    \"Зургаадугаар сар\",\n    \"Долоодугаар сар\",\n    \"Наймдугаар сар\",\n    \"Есдүгээр сар\",\n    \"Аравдугаар сар\",\n    \"Арваннэгдүгээр сар\",\n    \"Арван хоёрдугаар сар\",\n  ] as const,\n};\n\nconst formattingMonthValues = {\n  narrow: [\n    \"I\",\n    \"II\",\n    \"III\",\n    \"IV\",\n    \"V\",\n    \"VI\",\n    \"VII\",\n    \"VIII\",\n    \"IX\",\n    \"X\",\n    \"XI\",\n    \"XII\",\n  ] as const,\n  abbreviated: [\n    \"1-р сар\",\n    \"2-р сар\",\n    \"3-р сар\",\n    \"4-р сар\",\n    \"5-р сар\",\n    \"6-р сар\",\n    \"7-р сар\",\n    \"8-р сар\",\n    \"9-р сар\",\n    \"10-р сар\",\n    \"11-р сар\",\n    \"12-р сар\",\n  ] as const,\n  wide: [\n    \"нэгдүгээр сар\",\n    \"хоёрдугаар сар\",\n    \"гуравдугаар сар\",\n    \"дөрөвдүгээр сар\",\n    \"тавдугаар сар\",\n    \"зургаадугаар сар\",\n    \"долоодугаар сар\",\n    \"наймдугаар сар\",\n    \"есдүгээр сар\",\n    \"аравдугаар сар\",\n    \"арваннэгдүгээр сар\",\n    \"арван хоёрдугаар сар\",\n  ] as const,\n};\n\nconst dayValues = {\n  narrow: [\"Н\", \"Д\", \"М\", \"Л\", \"П\", \"Б\", \"Б\"] as const,\n  short: [\"Ня\", \"Да\", \"Мя\", \"Лх\", \"Пү\", \"Ба\", \"Бя\"] as const,\n  abbreviated: [\"Ням\", \"Дав\", \"Мяг\", \"Лха\", \"Пүр\", \"Баа\", \"Бям\"] as const,\n  wide: [\n    \"Ням\",\n    \"Даваа\",\n    \"Мягмар\",\n    \"Лхагва\",\n    \"Пүрэв\",\n    \"Баасан\",\n    \"Бямба\",\n  ] as const,\n};\n\nconst formattingDayValues = {\n  narrow: [\"Н\", \"Д\", \"М\", \"Л\", \"П\", \"Б\", \"Б\"] as const,\n  short: [\"Ня\", \"Да\", \"Мя\", \"Лх\", \"Пү\", \"Ба\", \"Бя\"] as const,\n  abbreviated: [\"Ням\", \"Дав\", \"Мяг\", \"Лха\", \"Пүр\", \"Баа\", \"Бям\"] as const,\n  wide: [\n    \"ням\",\n    \"даваа\",\n    \"мягмар\",\n    \"лхагва\",\n    \"пүрэв\",\n    \"баасан\",\n    \"бямба\",\n  ] as const,\n};\n\nconst dayPeriodValues = {\n  narrow: {\n    am: \"ү.ө.\",\n    pm: \"ү.х.\",\n    midnight: \"шөнө дунд\",\n    noon: \"үд дунд\",\n    morning: \"өглөө\",\n    afternoon: \"өдөр\",\n    evening: \"орой\",\n    night: \"шөнө\",\n  },\n  abbreviated: {\n    am: \"ү.ө.\",\n    pm: \"ү.х.\",\n    midnight: \"шөнө дунд\",\n    noon: \"үд дунд\",\n    morning: \"өглөө\",\n    afternoon: \"өдөр\",\n    evening: \"орой\",\n    night: \"шөнө\",\n  },\n  wide: {\n    am: \"ү.ө.\",\n    pm: \"ү.х.\",\n    midnight: \"шөнө дунд\",\n    noon: \"үд дунд\",\n    morning: \"өглөө\",\n    afternoon: \"өдөр\",\n    evening: \"орой\",\n    night: \"шөнө\",\n  },\n};\n\nconst ordinalNumber: LocalizeFn<number> = (dirtyNumber, _options) => {\n  return String(dirtyNumber);\n};\n\nexport const localize: Localize = {\n  ordinalNumber,\n\n  era: buildLocalizeFn({\n    values: eraValues,\n    defaultWidth: \"wide\",\n  }),\n\n  quarter: buildLocalizeFn({\n    values: quarterValues,\n    defaultWidth: \"wide\",\n    argumentCallback: (quarter) => quarter - 1,\n  }),\n\n  month: buildLocalizeFn({\n    values: monthValues,\n    defaultWidth: \"wide\",\n    formattingValues: formattingMonthValues,\n    defaultFormattingWidth: \"wide\",\n  }),\n\n  day: buildLocalizeFn({\n    values: dayValues,\n    defaultWidth: \"wide\",\n    formattingValues: formattingDayValues,\n    defaultFormattingWidth: \"wide\",\n  }),\n\n  dayPeriod: buildLocalizeFn({\n    values: dayPeriodValues,\n    defaultWidth: \"wide\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "import { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\n\nconst buildEraLocalizeFn = () => {\n  return buildLocalizeFn({\n    values: eraValues,\n    defaultWidth: \"wide\",\n  });\n};\n\nconst buildQuarterLocalizeFn = () => {\n  return buildLocalizeFn({\n    values: quarterValues,\n    defaultWidth: \"wide\",\n    argumentCallback: (quarter) => quarter - 1,\n  });\n};\n\nconst buildMonthLocalizeFn = () => {\n  return buildLocalizeFn({\n    values: monthValues,\n    defaultWidth: \"wide\",\n    formattingValues: formattingMonthValues,\n    defaultFormattingWidth: \"wide\",\n  });\n};\n\nconst buildDayLocalizeFn = () => {\n  return buildLocalizeFn({\n    values: dayValues,\n    defaultWidth: \"wide\",\n    formattingValues: formattingDayValues,\n    defaultFormattingWidth: \"wide\",\n  });\n};\n\nconst buildDayPeriodLocalizeFn = () => {\n  return buildLocalizeFn({\n    values: dayPeriodValues,\n    defaultWidth: \"wide\",\n  });\n};\n\nexport const localize: Localize = {\n  ordinalNumber,\n\n  era: buildEraLocalizeFn(),\n\n  quarter: buildQuarterLocalizeFn(),\n\n  month: buildMonthLocalizeFn(),\n\n  day: buildDayLocalizeFn(),\n\n  dayPeriod: buildDayPeriodLocalizeFn(),\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype FormatDistanceTokenValue =\n  | string\n  | {\n      one: string;\n      other: string;\n    };\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: \"menos de um segundo\",\n    other: \"menos de {{count}} segundos\",\n  },\n\n  xSeconds: {\n    one: \"1 segundo\",\n    other: \"{{count}} segundos\",\n  },\n\n  halfAMinute: \"meio minuto\",\n\n  lessThanXMinutes: {\n    one: \"menos de um minuto\",\n    other: \"menos de {{count}} minutos\",\n  },\n\n  xMinutes: {\n    one: \"1 minuto\",\n    other: \"{{count}} minutos\",\n  },\n\n  aboutXHours: {\n    one: \"cerca de 1 hora\",\n    other: \"cerca de {{count}} horas\",\n  },\n\n  xHours: {\n    one: \"1 hora\",\n    other: \"{{count}} horas\",\n  },\n\n  xDays: {\n    one: \"1 dia\",\n    other: \"{{count}} dias\",\n  },\n\n  aboutXWeeks: {\n    one: \"cerca de 1 semana\",\n    other: \"cerca de {{count}} semanas\",\n  },\n\n  xWeeks: {\n    one: \"1 semana\",\n    other: \"{{count}} semanas\",\n  },\n\n  aboutXMonths: {\n    one: \"cerca de 1 mês\",\n    other: \"cerca de {{count}} meses\",\n  },\n\n  xMonths: {\n    one: \"1 mês\",\n    other: \"{{count}} meses\",\n  },\n\n  aboutXYears: {\n    one: \"cerca de 1 ano\",\n    other: \"cerca de {{count}} anos\",\n  },\n\n  xYears: {\n    one: \"1 ano\",\n    other: \"{{count}} anos\",\n  },\n\n  overXYears: {\n    one: \"mais de 1 ano\",\n    other: \"mais de {{count}} anos\",\n  },\n\n  almostXYears: {\n    one: \"quase 1 ano\",\n    other: \"quase {{count}} anos\",\n  },\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  let result;\n\n  const tokenValue = formatDistanceLocale[token];\n  if (typeof tokenValue === \"string\") {\n    result = tokenValue;\n  } else if (count === 1) {\n    result = tokenValue.one;\n  } else {\n    result = tokenValue.other.replace(\"{{count}}\", String(count));\n  }\n\n  if (options?.addSuffix) {\n    if (options.comparison && options.comparison > 0) {\n      return \"em \" + result;\n    } else {\n      return \"há \" + result;\n    }\n  }\n\n  return result;\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype FormatDistanceTokenValue =\n  | string\n  | {\n      one: string;\n      other: string;\n    };\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: \"menos de um segundo\",\n    other: \"menos de {{count}} segundos\",\n  },\n\n  xSeconds: {\n    one: \"1 segundo\",\n    other: \"{{count}} segundos\",\n  },\n\n  halfAMinute: \"meio minuto\",\n\n  lessThanXMinutes: {\n    one: \"menos de um minuto\",\n    other: \"menos de {{count}} minutos\",\n  },\n\n  xMinutes: {\n    one: \"1 minuto\",\n    other: \"{{count}} minutos\",\n  },\n\n  aboutXHours: {\n    one: \"cerca de 1 hora\",\n    other: \"cerca de {{count}} horas\",\n  },\n\n  xHours: {\n    one: \"1 hora\",\n    other: \"{{count}} horas\",\n  },\n\n  xDays: {\n    one: \"1 dia\",\n    other: \"{{count}} dias\",\n  },\n\n  aboutXWeeks: {\n    one: \"cerca de 1 semana\",\n    other: \"cerca de {{count}} semanas\",\n  },\n\n  xWeeks: {\n    one: \"1 semana\",\n    other: \"{{count}} semanas\",\n  },\n\n  aboutXMonths: {\n    one: \"cerca de 1 mês\",\n    other: \"cerca de {{count}} meses\",\n  },\n\n  xMonths: {\n    one: \"1 mês\",\n    other: \"{{count}} meses\",\n  },\n\n  aboutXYears: {\n    one: \"cerca de 1 ano\",\n    other: \"cerca de {{count}} anos\",\n  },\n\n  xYears: {\n    one: \"1 ano\",\n    other: \"{{count}} anos\",\n  },\n\n  overXYears: {\n    one: \"mais de 1 ano\",\n    other: \"mais de {{count}} anos\",\n  },\n\n  almostXYears: {\n    one: \"quase 1 ano\",\n    other: \"quase {{count}} anos\",\n  },\n};\n\nconst getLocalizedTokenValue = (token, count) => {\n  const tokenValue = formatDistanceLocale[token];\n  if (typeof tokenValue === \"string\") {\n    return tokenValue;\n  } else if (count === 1) {\n    return tokenValue.one;\n  } else {\n    return tokenValue.other.replace(\"{{count}}\", String(count));\n  }\n};\n\nconst addSuffix = (result, options) => {\n  if (options?.addSuffix) {\n    if (options.comparison && options.comparison > 0) {\n      return \"em \" + result;\n    } else {\n      return \"há \" + result;\n    }\n  }\n  return result;\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  let result = getLocalizedTokenValue(token, count);\n  result = addSuffix(result, options);\n  return result;\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype Tense = {\n  default: string;\n  in: string;\n  ago: string;\n};\n\ntype Plural = {\n  one: Tense;\n  other: Tense;\n};\n\nfunction isPluralType(val: Plural | Tense): val is Plural {\n  return (val as Plural).one !== undefined;\n}\n\ntype FormatDistanceTokenValue = Plural | Tense;\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: {\n      default: \"ஒரு வினாடிக்கு குறைவாக\",\n      in: \"ஒரு வினாடிக்குள்\",\n      ago: \"ஒரு வினாடிக்கு முன்பு\",\n    },\n    other: {\n      default: \"{{count}} வினாடிகளுக்கு குறைவாக\",\n      in: \"{{count}} வினாடிகளுக்குள்\",\n      ago: \"{{count}} வினாடிகளுக்கு முன்பு\",\n    },\n  },\n\n  xSeconds: {\n    one: {\n      default: \"1 வினாடி\",\n      in: \"1 வினாடியில்\",\n      ago: \"1 வினாடி முன்பு\",\n    },\n    other: {\n      default: \"{{count}} விநாடிகள்\",\n      in: \"{{count}} வினாடிகளில்\",\n      ago: \"{{count}} விநாடிகளுக்கு முன்பு\",\n    },\n  },\n\n  halfAMinute: {\n    default: \"அரை நிமிடம்\",\n    in: \"அரை நிமிடத்தில்\",\n    ago: \"அரை நிமிடம் முன்பு\",\n  },\n\n  lessThanXMinutes: {\n    one: {\n      default: \"ஒரு நிமிடத்திற்கும் குறைவாக\",\n      in: \"ஒரு நிமிடத்திற்குள்\",\n      ago: \"ஒரு நிமிடத்திற்கு முன்பு\",\n    },\n    other: {\n      default: \"{{count}} நிமிடங்களுக்கும் குறைவாக\",\n      in: \"{{count}} நிமிடங்களுக்குள்\",\n      ago: \"{{count}} நிமிடங்களுக்கு முன்பு\",\n    },\n  },\n\n  xMinutes: {\n    one: {\n      default: \"1 நிமிடம்\",\n      in: \"1 நிமிடத்தில்\",\n      ago: \"1 நிமிடம் முன்பு\",\n    },\n    other: {\n      default: \"{{count}} நிமிடங்கள்\",\n      in: \"{{count}} நிமிடங்களில்\",\n      ago: \"{{count}} நிமிடங்களுக்கு முன்பு\",\n    },\n  },\n\n  aboutXHours: {\n    one: {\n      default: \"சுமார் 1 மணி நேரம்\",\n      in: \"சுமார் 1 மணி நேரத்தில்\",\n      ago: \"சுமார் 1 மணி நேரத்திற்கு முன்பு\",\n    },\n    other: {\n      default: \"சுமார் {{count}} மணி நேரம்\",\n      in: \"சுமார் {{count}} மணி நேரத்திற்கு முன்பு\",\n      ago: \"சுமார் {{count}} மணி நேரத்தில்\",\n    },\n  },\n\n  xHours: {\n    one: {\n      default: \"1 மணி நேரம்\",\n      in: \"1 மணி நேரத்தில்\",\n      ago: \"1 மணி நேரத்திற்கு முன்பு\",\n    },\n    other: {\n      default: \"{{count}} மணி நேரம்\",\n      in: \"{{count}} மணி நேரத்தில்\",\n      ago: \"{{count}} மணி நேரத்திற்கு முன்பு\",\n    },\n  },\n\n  xDays: {\n    one: {\n      default: \"1 நாள்\",\n      in: \"1 நாளில்\",\n      ago: \"1 நாள் முன்பு\",\n    },\n    other: {\n      default: \"{{count}} நாட்கள்\",\n      in: \"{{count}} நாட்களில்\",\n      ago: \"{{count}} நாட்களுக்கு முன்பு\",\n    },\n  },\n\n  aboutXWeeks: {\n    one: {\n      default: \"சுமார் 1 வாரம்\",\n      in: \"சுமார் 1 வாரத்தில்\",\n      ago: \"சுமார் 1 வாரம் முன்பு\",\n    },\n    other: {\n      default: \"சுமார் {{count}} வாரங்கள்\",\n      in: \"சுமார் {{count}} வாரங்களில்\",\n      ago: \"சுமார் {{count}} வாரங்களுக்கு முன்பு\",\n    },\n  },\n\n  xWeeks: {\n    one: {\n      default: \"1 வாரம்\",\n      in: \"1 வாரத்தில்\",\n      ago: \"1 வாரம் முன்பு\",\n    },\n    other: {\n      default: \"{{count}} வாரங்கள்\",\n      in: \"{{count}} வாரங்களில்\",\n      ago: \"{{count}} வாரங்களுக்கு முன்பு\",\n    },\n  },\n\n  aboutXMonths: {\n    one: {\n      default: \"சுமார் 1 மாதம்\",\n      in: \"சுமார் 1 மாதத்தில்\",\n      ago: \"சுமார் 1 மாதத்திற்கு முன்பு\",\n    },\n    other: {\n      default: \"சுமார் {{count}} மாதங்கள்\",\n      in: \"சுமார் {{count}} மாதங்களில்\",\n      ago: \"சுமார் {{count}} மாதங்களுக்கு முன்பு\",\n    },\n  },\n\n  xMonths: {\n    one: {\n      default: \"1 மாதம்\",\n      in: \"1 மாதத்தில்\",\n      ago: \"1 மாதம் முன்பு\",\n    },\n    other: {\n      default: \"{{count}} மாதங்கள்\",\n      in: \"{{count}} மாதங்களில்\",\n      ago: \"{{count}} மாதங்களுக்கு முன்பு\",\n    },\n  },\n\n  aboutXYears: {\n    one: {\n      default: \"சுமார் 1 வருடம்\",\n      in: \"சுமார் 1 ஆண்டில்\",\n      ago: \"சுமார் 1 வருடம் முன்பு\",\n    },\n    other: {\n      default: \"சுமார் {{count}} ஆண்டுகள்\",\n      in: \"சுமார் {{count}} ஆண்டுகளில்\",\n      ago: \"சுமார் {{count}} ஆண்டுகளுக்கு முன்பு\",\n    },\n  },\n\n  xYears: {\n    one: {\n      default: \"1 வருடம்\",\n      in: \"1 ஆண்டில்\",\n      ago: \"1 வருடம் முன்பு\",\n    },\n    other: {\n      default: \"{{count}} ஆண்டுகள்\",\n      in: \"{{count}} ஆண்டுகளில்\",\n      ago: \"{{count}} ஆண்டுகளுக்கு முன்பு\",\n    },\n  },\n\n  overXYears: {\n    one: {\n      default: \"1 வருடத்திற்கு மேல்\",\n      in: \"1 வருடத்திற்கும் மேலாக\",\n      ago: \"1 வருடம் முன்பு\",\n    },\n    other: {\n      default: \"{{count}} ஆண்டுகளுக்கும் மேலாக\",\n      in: \"{{count}} ஆண்டுகளில்\",\n      ago: \"{{count}} ஆண்டுகளுக்கு முன்பு\",\n    },\n  },\n\n  almostXYears: {\n    one: {\n      default: \"கிட்டத்தட்ட 1 வருடம்\",\n      in: \"கிட்டத்தட்ட 1 ஆண்டில்\",\n      ago: \"கிட்டத்தட்ட 1 வருடம் முன்பு\",\n    },\n    other: {\n      default: \"கிட்டத்தட்ட {{count}} ஆண்டுகள்\",\n      in: \"கிட்டத்தட்ட {{count}} ஆண்டுகளில்\",\n      ago: \"கிட்டத்தட்ட {{count}} ஆண்டுகளுக்கு முன்பு\",\n    },\n  },\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  const tense = options?.addSuffix\n    ? options.comparison && options.comparison > 0\n      ? \"in\"\n      : \"ago\"\n    : \"default\";\n\n  const tokenValue = formatDistanceLocale[token];\n\n  if (!isPluralType(tokenValue)) return tokenValue[tense];\n\n  if (count === 1) {\n    return tokenValue.one[tense];\n  } else {\n    return tokenValue.other[tense].replace(\"{{count}}\", String(count));\n  }\n};\n"
      },
      {
        "role": "assistant",
        "content": "```js\nimport type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype Tense = {\n  default: string;\n  in: string;\n  ago: string;\n};\n\ntype Plural = {\n  one: Tense;\n  other: Tense;\n};\n\nfunction isPluralType(val: Plural | Tense): val is Plural {\n  return (val as Plural).one !== undefined;\n}\n\ntype FormatDistanceTokenValue = Plural | Tense;\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: {\n      default: \"ஒரு வினாடிக்கு குறைவாக\",\n      in: \"ஒரு வினாடிக்குள்\",\n      ago: \"ஒரு வினாடிக்கு முன்பு\",\n    },\n    other: {\n      default: \"{{count}} வினாடிகளுக்கு குறைவாக\",\n      in: \"{{count}} வினாடிகளுக்குள்\",\n      ago: \"{{count}} வினாடிகளுக்கு முன்பு\",\n    },\n  },\n\n  xSeconds: {\n    one: {\n      default: \"1 வினாடி\",\n      in: \"1 வினாடியில்\",\n      ago: \"1 வினாடி முன்பு\",\n    },\n    other: {\n      default: \"{{count}} விநாடிகள்\",\n      in: \"{{count}} விநாடிகளில்\",\n      ago: \"{{count}} விநாடிகளுக்கு முன்பு\",\n    },\n  },\n\n  halfAMinute: {\n    default: \"அரை நிமிடம்\",\n    in: \"அரை நிமிடத்தில்\",\n    ago: \"அரை நிமிடம் முன்பு\",\n  },\n\n  lessThanXMinutes: {\n    one: {\n      default: \"ஒரு நிமிடத்திற்கும் குறைவாக\",\n      in: \"ஒரு நிமிடத்திற்குள்\",\n      ago: \"ஒரு நிமிடத்திற்கு முன்பு\",\n    },\n    other: {\n      default: \"{{count}} நிமிடங்களுக்கும் குறைவாக\",\n      in: \"{{count}} நிமிடங்களுக்குள்\",\n      ago: \"{{count}} நிமிடங்களுக்கு முன்பு\",\n    },\n  },\n\n  xMinutes: {\n    one: {\n      default: \"1 நிமிடம்\",\n      in: \"1 நிமிடத்தில்\",\n      ago: \"1 நிமிடம் முன்பு\",\n    },\n    other: {\n      default: \"{{count}} நிமிடங்கள்\",\n      in: \"{{count}} நிமிடங்களில்\",\n      ago: \"{{count}} நிமிடங்களுக்கு முன்பு\",\n    },\n  },\n\n  aboutXHours: {\n    one: {\n      default: \"சுமார் 1 மணி நேரம்\",\n      in: \"சுமார் 1 மணி"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\nimport { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\n\nconst eraValues = {\n  narrow: [\"前\", \"公元\"] as const,\n  abbreviated: [\"前\", \"公元\"] as const,\n  wide: [\"公元前\", \"公元\"] as const,\n};\n\nconst quarterValues = {\n  narrow: [\"1\", \"2\", \"3\", \"4\"] as const,\n  abbreviated: [\"第一季\", \"第二季\", \"第三季\", \"第四季\"] as const,\n  wide: [\"第一季度\", \"第二季度\", \"第三季度\", \"第四季度\"] as const,\n};\n\nconst monthValues = {\n  narrow: [\n    \"一\",\n    \"二\",\n    \"三\",\n    \"四\",\n    \"五\",\n    \"六\",\n    \"七\",\n    \"八\",\n    \"九\",\n    \"十\",\n    \"十一\",\n    \"十二\",\n  ] as const,\n  abbreviated: [\n    \"1月\",\n    \"2月\",\n    \"3月\",\n    \"4月\",\n    \"5月\",\n    \"6月\",\n    \"7月\",\n    \"8月\",\n    \"9月\",\n    \"10月\",\n    \"11月\",\n    \"12月\",\n  ] as const,\n  wide: [\n    \"一月\",\n    \"二月\",\n    \"三月\",\n    \"四月\",\n    \"五月\",\n    \"六月\",\n    \"七月\",\n    \"八月\",\n    \"九月\",\n    \"十月\",\n    \"十一月\",\n    \"十二月\",\n  ] as const,\n};\n\nconst dayValues = {\n  narrow: [\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\"] as const,\n  short: [\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\"] as const,\n  abbreviated: [\n    \"週日\",\n    \"週一\",\n    \"週二\",\n    \"週三\",\n    \"週四\",\n    \"週五\",\n    \"週六\",\n  ] as const,\n  wide: [\n    \"星期日\",\n    \"星期一\",\n    \"星期二\",\n    \"星期三\",\n    \"星期四\",\n    \"星期五\",\n    \"星期六\",\n  ] as const,\n};\n\nconst dayPeriodValues = {\n  narrow: {\n    am: \"上\",\n    pm: \"下\",\n    midnight: \"午夜\",\n    noon: \"晌\",\n    morning: \"早\",\n    afternoon: \"午\",\n    evening: \"晚\",\n    night: \"夜\",\n  },\n  abbreviated: {\n    am: \"上午\",\n    pm: \"下午\",\n    midnight: \"午夜\",\n    noon: \"中午\",\n    morning: \"上午\",\n    afternoon: \"下午\",\n    evening: \"晚上\",\n    night: \"夜晚\",\n  },\n  wide: {\n    am: \"上午\",\n    pm: \"下午\",\n    midnight: \"午夜\",\n    noon: \"中午\",\n    morning: \"上午\",\n    afternoon: \"下午\",\n    evening: \"晚上\",\n    night: \"夜晚\",\n  },\n};\n\nconst formattingDayPeriodValues = {\n  narrow: {\n    am: \"上\",\n    pm: \"下\",\n    midnight: \"午夜\",\n    noon: \"晌\",\n    morning: \"早\",\n    afternoon: \"午\",\n    evening: \"晚\",\n    night: \"夜\",\n  },\n  abbreviated: {\n    am: \"上午\",\n    pm: \"下午\",\n    midnight: \"午夜\",\n    noon: \"中午\",\n    morning: \"上午\",\n    afternoon: \"下午\",\n    evening: \"晚上\",\n    night: \"夜晚\",\n  },\n  wide: {\n    am: \"上午\",\n    pm: \"下午\",\n    midnight: \"午夜\",\n    noon: \"中午\",\n    morning: \"上午\",\n    afternoon: \"下午\",\n    evening: \"晚上\",\n    night: \"夜晚\",\n  },\n};\n\nconst ordinalNumber: LocalizeFn<number> = (dirtyNumber, options) => {\n  const number = Number(dirtyNumber);\n\n  switch (options?.unit) {\n    case \"date\":\n      return number + \"日\";\n    case \"hour\":\n      return number + \"時\";\n    case \"minute\":\n      return number + \"分\";\n    case \"second\":\n      return number + \"秒\";\n    default:\n      return \"第 \" + number;\n  }\n};\n\nexport const localize: Localize = {\n  ordinalNumber,\n\n  era: buildLocalizeFn({\n    values: eraValues,\n    defaultWidth: \"wide\",\n  }),\n\n  quarter: buildLocalizeFn({\n    values: quarterValues,\n    defaultWidth: \"wide\",\n    argumentCallback: (quarter) => quarter - 1,\n  }),\n\n  month: buildLocalizeFn({\n    values: monthValues,\n    defaultWidth: \"wide\",\n  }),\n\n  day: buildLocalizeFn({\n    values: dayValues,\n    defaultWidth: \"wide\",\n  }),\n\n  dayPeriod: buildLocalizeFn({\n    values: dayPeriodValues,\n    defaultWidth: \"wide\",\n    formattingValues: formattingDayPeriodValues,\n    defaultFormattingWidth: \"wide\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "import { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\n\nconst eraValues = {\n  narrow: [\"前\", \"公元\"] as const,\n  abbreviated: [\"前\", \"公元\"] as const,\n  wide: [\"公元前\", \"公元\"] as const,\n};\n\nconst quarterValues = {\n  narrow: [\"1\", \"2\", \"3\", \"4\"] as const,\n  abbreviated: [\"第一季\", \"第二季\", \"第三季\", \"第四季\"] as const,\n  wide: [\"第一季度\", \"第二季度\", \"第三季度\", \"第四季度\"] as const,\n};\n\nconst monthValues = {\n  narrow: [\n    \"一\",\n    \"二\",\n    \"三\",\n    \"四\",\n    \"五\",\n    \"六\",\n    \"七\",\n    \"八\",\n    \"九\",\n    \"十\",\n    \"十一\",\n    \"十二\",\n  ] as const,\n  abbreviated: [\n    \"1月\",\n    \"2月\",\n    \"3月\",\n    \"4月\",\n    \"5月\",\n    \"6月\",\n    \"7月\",\n    \"8月\",\n    \"9月\",\n    \"10月\",\n    \"11月\",\n    \"12月\",\n  ] as const,\n  wide: [\n    \"一月\",\n    \"二月\",\n    \"三月\",\n    \"四月\",\n    \"五月\",\n    \"六月\",\n    \"七月\",\n    \"八月\",\n    \"九月\",\n    \"十月\",\n    \"十一月\",\n    \"十二月\",\n  ] as const,\n};\n\nconst dayValues = {\n  narrow: [\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\"] as const,\n  short: [\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\"] as const,\n  abbreviated: [\n    \"週日\",\n    \"週一\",\n    \"週二\",\n    \"週三\",\n    \"週四\",\n    \"週五\",\n    \"週六\",\n  ] as const,\n  wide: [\n    \"星期日\",\n    \"星期一\",\n    \"星期二\",\n    \"星期三\",\n    \"星期四\",\n    \"星期五\",\n    \"星期六\",\n  ] as const,\n};\n\nconst dayPeriodValues = {\n  narrow: {\n    am: \"上\",\n    pm: \"下\",\n    midnight: \"午夜\",\n    noon: \"晌\",\n    morning: \"早\",\n    afternoon: \"午\",\n    evening: \"晚\",\n    night: \"夜\",\n  },\n  abbreviated: {\n    am: \"上午\",\n    pm: \"下午\",\n    midnight: \"午夜\",\n    noon: \"中午\",\n    morning: \"上午\",\n    afternoon: \"下午\",\n    evening: \"晚上\",\n    night: \"夜晚\",\n  },\n  wide: {\n    am: \"上午\",\n    pm: \"下午\",\n    midnight: \"午夜\",\n    noon: \"中午\",\n    morning: \"上午\",\n    afternoon: \"下午\",\n    evening: \"晚上\",\n    night: \"夜晚\",\n  },\n};\n\nconst formattingDayPeriodValues = {\n  narrow: {\n    am: \"上\",\n    pm: \"下\",\n    midnight: \"午夜\",\n    noon: \"晌\",\n    morning: \"早\",\n    afternoon: \"午\",\n    evening: \"晚\",\n    night: \"夜\",\n  },\n  abbreviated: {\n    am: \"上午\",\n    pm: \"下午\",\n    midnight: \"午夜\",\n    noon: \"中午\",\n    morning: \"上午\",\n    afternoon: \"下午\",\n    evening: \"晚上\",\n    night: \"夜晚\",\n  },\n  wide: {\n    am: \"上午\",\n    pm: \"下午\",\n    midnight: \"午夜\",\n    noon: \"中午\",\n    morning: \"上午\",\n    afternoon: \"下午\",\n    evening: \"晚上\",\n    night: \"夜晚\",\n  },\n};\n\nconst ordinalNumber: LocalizeFn<number> = (dirtyNumber, options) => {\n  const number = Number(dirtyNumber);\n\n  switch (options?.unit) {\n    case \"date\":\n      return number + \"日\";\n    case \"hour\":\n      return number + \"時\";\n    case \"minute\":\n      return number + \""
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { buildMatchPatternFn } from \"../../../_lib/buildMatchPatternFn/index.js\";\nimport { buildMatchFn } from \"../../../_lib/buildMatchFn/index.js\";\nimport type { Quarter } from \"../../../../types.js\";\nimport type { Match } from \"../../../types.js\";\n\nconst matchOrdinalNumberPattern = /^(\\d+)(th|st|nd|rd)?/i;\nconst parseOrdinalNumberPattern = /\\d+/i;\n\nconst matchEraPatterns = {\n  narrow: /^(ق|ب)/i,\n  abbreviated: /^(ق\\.?\\s?م\\.?|ق\\.?\\s?م\\.?\\s?|a\\.?\\s?d\\.?|c\\.?\\s?)/i,\n  wide: /^(قبل الميلاد|قبل الميلاد|بعد الميلاد|بعد الميلاد)/i,\n};\nconst parseEraPatterns = {\n  any: [/^قبل/i, /^بعد/i] as const,\n};\n\nconst matchQuarterPatterns = {\n  narrow: /^[1234]/i,\n  abbreviated: /^ر[1234]/i,\n  wide: /^الربع [1234]/i,\n};\nconst parseQuarterPatterns = {\n  any: [/1/i, /2/i, /3/i, /4/i] as const,\n};\n\nconst matchMonthPatterns = {\n  narrow: /^[جفمأسند]/i,\n  abbreviated: /^(جان|فيف|مار|أفر|ماي|جوا|جوي|أوت|سبت|أكت|نوف|ديس)/i,\n  wide: /^(جانفي|فيفري|مارس|أفريل|ماي|جوان|جويلية|أوت|سبتمبر|أكتوبر|نوفمبر|ديسمبر)/i,\n};\n\nconst parseMonthPatterns = {\n  narrow: [\n    /^ج/i,\n    /^ف/i,\n    /^م/i,\n    /^أ/i,\n    /^م/i,\n    /^ج/i,\n    /^ج/i,\n    /^أ/i,\n    /^س/i,\n    /^أ/i,\n    /^ن/i,\n    /^د/i,\n  ] as const,\n  any: [\n    /^جان/i,\n    /^فيف/i,\n    /^مار/i,\n    /^أفر/i,\n    /^ماي/i,\n    /^جوا/i,\n    /^جوي/i,\n    /^أوت/i,\n    /^سبت/i,\n    /^أكت/i,\n    /^نوف/i,\n    /^ديس/i,\n  ] as const,\n};\n\nconst matchDayPatterns = {\n  narrow: /^[حنثرخجس]/i,\n  short: /^(أحد|اثنين|ثلاثاء|أربعاء|خميس|جمعة|سبت)/i,\n  abbreviated: /^(أحد|اثن|ثلا|أرب|خمي|جمعة|سبت)/i,\n  wide: /^(الأحد|الاثنين|الثلاثاء|الأربعاء|الخميس|الجمعة|السبت)/i,\n};\nconst parseDayPatterns = {\n  narrow: [/^ح/i, /^ن/i, /^ث/i, /^ر/i, /^خ/i, /^ج/i, /^س/i] as const,\n  wide: [\n    /^الأحد/i,\n    /^الاثنين/i,\n    /^الثلاثاء/i,\n    /^الأربعاء/i,\n    /^الخميس/i,\n    /^الجمعة/i,\n    /^السبت/i,\n  ] as const,\n  any: [/^أح/i, /^اث/i, /^ث/i, /^أر/i, /^خ/i, /^ج/i, /^س/i] as const,\n};\n\nconst matchDayPeriodPatterns = {\n  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,\n  any: /^([ap]\\.?\\s?m\\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i,\n};\nconst parseDayPeriodPatterns = {\n  any: {\n    am: /^a/i,\n    pm: /^p/i,\n    midnight: /^mi/i,\n    noon: /^no/i,\n    morning: /morning/i,\n    afternoon: /afternoon/i,\n    evening: /evening/i,\n    night: /night/i,\n  },\n};\n\nexport const match: Match = {\n  ordinalNumber: buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: (value: string) => parseInt(value, 10),\n  }),\n\n  era: buildMatchFn({\n    matchPatterns: matchEraPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseEraPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  quarter: buildMatchFn({\n    matchPatterns: matchQuarterPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseQuarterPatterns,\n    defaultParseWidth: \"any\",\n    valueCallback: (index) => (Number(index) + 1) as Quarter,\n  }),\n\n  month: buildMatchFn({\n    matchPatterns: matchMonthPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseMonthPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  day: buildMatchFn({\n    matchPatterns: matchDayPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseDayPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  dayPeriod: buildMatchFn({\n    matchPatterns: matchDayPeriodPatterns,\n    defaultMatchWidth: \"any\",\n    parsePatterns: parseDayPeriodPatterns,\n    defaultParseWidth: \"any\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "import { buildMatchPatternFn } from \"../../../_lib/buildMatchPatternFn/index.js\";\nimport { buildMatchFn } from \"../../../_lib/buildMatchFn/index.js\";\nimport type { Quarter } from \"../../../../types.js\";\nimport type { Match } from \"../../../types.js\";\n\n// Function to match ordinal numbers\nconst matchOrdinalNumber = () => {\n  return buildMatchPatternFn({\n    matchPattern: /^(\\d+)(th|st|nd|rd)?/i,\n    parsePattern: /\\d+/i,\n    valueCallback: (value: string) => parseInt(value, 10),\n  });\n};\n\n// Function to match eras\nconst matchEra = () => {\n  return buildMatchFn({\n    matchPatterns: {\n      narrow: /^(ق|ب)/i,\n      abbreviated: /^(ق\\.?\\s?م\\.?|ق\\.?\\s?م\\.?\\s?|a\\.?\\s?d\\.?|c\\.?\\s?)/i,\n      wide: /^(قبل الميلاد|قبل الميلاد|بعد الميلاد|بعد الميلاد)/i,\n    },\n    defaultMatchWidth: \"wide\",\n    parsePatterns: {\n      any: [/^قبل/i, /^بعد/i] as const,\n    },\n    defaultParseWidth: \"any\",\n  });\n};\n\n// Function to match quarters\nconst matchQuarter = () => {\n  return buildMatchFn({\n    matchPatterns: {\n      narrow: /^[1234]/i,\n      abbreviated: /^ر[1234]/i,\n      wide: /^الربع [1234]/i,\n    },\n    defaultMatchWidth: \"wide\",\n    parsePatterns: {\n      any: [/1/i, /2/i, /3/i, /4/i] as const,\n    },\n    defaultParseWidth: \"any\",\n    valueCallback: (index) => (Number(index) + 1) as Quarter,\n  });\n};\n\n// Function to match months\nconst matchMonth = () => {\n  return buildMatchFn({\n    matchPatterns: {\n      narrow: /^[جفمأسند]/i,\n      abbreviated: /^(جان|فيف|مار|أفر|ماي|جوا|جوي|أوت|سبت|أكت|نوف|ديس)/i,\n      wide: /^(جانفي|فيفري|مارس|أفريل|ماي|جوان|جويلية|أوت|سبتمبر|أكتوبر|نوفمبر|ديسمبر)/i,\n    },\n    defaultMatchWidth: \"wide\",\n    parsePatterns: {\n      narrow: [\n        /^ج/i,\n        /^ف/i,\n        /^م/i,\n        /^أ/i,\n        /^م/i,\n        /^ج/i,\n        /^ج/i,\n        /^أ/i,\n        /^س/i,\n        /^أ/i,\n        /^ن/i,\n        /^د/i,\n      ] as const,\n      any: [\n        /^جان/i,\n        /^فيف/i,\n        /^مار/i,\n        /^أفر/i,\n        /^ماي/i,\n        /^جوا/i,\n        /^جوي/i,\n        /^أوت/i,\n        /^سبت/i,\n        /^أكت/i,\n        /^نوف/i,\n        /^ديس/i,\n      ] as const,\n    },\n    defaultParseWidth: \"any\",\n  });\n};\n\n// Function to match days\nconst matchDay = () => {\n  return buildMatchFn({\n    matchPatterns: {\n      narrow: /^[حنثرخجس]/i,\n      short: /^(أحد|اثنين|ثلاثاء|أربعاء|خميس|جمعة|سبت)/i,\n      abbreviated: /^(أحد|اثن|ثلا|أرب|خمي|جمعة|سبت)/i,\n      wide: /^(الأحد|الاثنين|الثلاثاء|الأربعاء|الخميس|الجمعة|السبت)/i,\n    },\n    defaultMatchWidth: \"wide\",\n    parsePatterns: {\n      narrow: [/^ح/i, /^ن/i, /^ث/i, /^ر/i, /^خ/i, /^ج/i, /^س/i] as const,\n      wide: [\n        /^الأحد/i,\n        /^الاثنين/i,\n        /^الثلاثاء/i,\n        /^الأ"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Quarter } from \"../../../../types.js\";\nimport type { Match } from \"../../../types.js\";\nimport { buildMatchFn } from \"../../../_lib/buildMatchFn/index.js\";\nimport { buildMatchPatternFn } from \"../../../_lib/buildMatchPatternFn/index.js\";\n\nconst matchOrdinalNumberPattern = /^(\\d+)\\./i;\nconst parseOrdinalNumberPattern = /\\d+/i;\n\nconst matchEraPatterns = {\n  narrow: /^(pr\\.n\\.e\\.|AD)/i,\n  abbreviated: /^(pr\\.\\s?Hr\\.|po\\.\\s?Hr\\.)/i,\n  wide: /^(Prije Hrista|prije nove ere|Poslije Hrista|nova era)/i,\n};\nconst parseEraPatterns = {\n  any: [/^pr/i, /^(po|nova)/i] as const,\n};\n\nconst matchQuarterPatterns = {\n  narrow: /^[1234]/i,\n  abbreviated: /^[1234]\\.\\s?kv\\.?/i,\n  wide: /^[1234]\\. kvartal/i,\n};\nconst parseQuarterPatterns = {\n  any: [/1/i, /2/i, /3/i, /4/i] as const,\n};\n\nconst matchMonthPatterns = {\n  narrow: /^(10|11|12|[123456789])\\./i,\n  abbreviated: /^(jan|feb|mar|apr|maj|jun|jul|avg|sep|okt|nov|dec)/i,\n  wide: /^((januar|januara)|(februar|februara)|(mart|marta)|(april|aprila)|(maj|maja)|(juni|juna)|(juli|jula)|(avgust|avgusta)|(septembar|septembra)|(oktobar|oktobra)|(novembar|novembra)|(decembar|decembra))/i,\n};\nconst parseMonthPatterns = {\n  narrow: [\n    /^1/i,\n    /^2/i,\n    /^3/i,\n    /^4/i,\n    /^5/i,\n    /^6/i,\n    /^7/i,\n    /^8/i,\n    /^9/i,\n    /^10/i,\n    /^11/i,\n    /^12/i,\n  ] as const,\n  any: [\n    /^ja/i,\n    /^f/i,\n    /^mar/i,\n    /^ap/i,\n    /^maj/i,\n    /^jun/i,\n    /^jul/i,\n    /^avg/i,\n    /^s/i,\n    /^o/i,\n    /^n/i,\n    /^d/i,\n  ] as const,\n};\n\nconst matchDayPatterns = {\n  narrow: /^[npusčc]/i,\n  short: /^(ned|pon|uto|sre|(čet|cet)|pet|sub)/i,\n  abbreviated: /^(ned|pon|uto|sre|(čet|cet)|pet|sub)/i,\n  wide: /^(nedjelja|ponedjeljak|utorak|srijeda|(četvrtak|cetvrtak)|petak|subota)/i,\n};\nconst parseDayPatterns = {\n  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i] as const,\n  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] as const,\n};\n\nconst matchDayPeriodPatterns = {\n  any: /^(am|pm|ponoc|ponoć|(po)?podne|uvece|uveče|noću|poslije podne|ujutru)/i,\n};\nconst parseDayPeriodPatterns = {\n  any: {\n    am: /^a/i,\n    pm: /^p/i,\n    midnight: /^pono/i,\n    noon: /^pod/i,\n    morning: /jutro/i,\n    afternoon: /(poslije\\s|po)+podne/i,\n    evening: /(uvece|uveče)/i,\n    night: /(nocu|noću)/i,\n  },\n};\n\nexport const match: Match = {\n  ordinalNumber: buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: (value) => parseInt(value, 10),\n  }),\n\n  era: buildMatchFn({\n    matchPatterns: matchEraPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseEraPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  quarter: buildMatchFn({\n    matchPatterns: matchQuarterPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseQuarterPatterns,\n    defaultParseWidth: \"any\",\n    valueCallback: (index) => (index + 1) as Quarter,\n  }),\n\n  month: buildMatchFn({\n    matchPatterns: matchMonthPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseMonthPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  day: buildMatchFn({\n    matchPatterns: matchDayPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseDayPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  dayPeriod: buildMatchFn({\n    matchPatterns: matchDayPeriodPatterns,\n    defaultMatchWidth: \"any\",\n    parsePatterns: parseDayPeriodPatterns,\n    defaultParseWidth: \"any\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "import { buildMatchFn } from \"../../../_lib/buildMatchFn/index.js\";\nimport { buildMatchPatternFn } from \"../../../_lib/buildMatchPatternFn/index.js\";\n\nconst matchOrdinalNumberPattern = /^(\\d+)\\./i;\nconst parseOrdinalNumberPattern = /\\d+/i;\n\nconst matchEraPatterns = {\n  narrow: /^(pr\\.n\\.e\\.|AD)/i,\n  abbreviated: /^(pr\\.\\s?Hr\\.|po\\.\\s?Hr\\.)/i,\n  wide: /^(Prije Hrista|prije nove ere|Poslije Hrista|nova era)/i,\n};\nconst parseEraPatterns = {\n  any: [/^pr/i, /^(po|nova)/i] as const,\n};\n\nconst matchQuarterPatterns = {\n  narrow: /^[1234]/i,\n  abbreviated: /^[1234]\\.\\s?kv\\.?/i,\n  wide: /^[1234]\\. kvartal/i,\n};\nconst parseQuarterPatterns = {\n  any: [/1/i, /2/i, /3/i, /4/i] as const,\n};\n\nconst matchMonthPatterns = {\n  narrow: /^(10|11|12|[123456789])\\./i,\n  abbreviated: /^(jan|feb|mar|apr|maj|jun|jul|avg|sep|okt|nov|dec)/i,\n  wide: /^((januar|januara)|(februar|februara)|(mart|marta)|(april|aprila)|(maj|maja)|(juni|juna)|(juli|jula)|(avgust|avgusta)|(septembar|septembra)|(oktobar|oktobra)|(novembar|novembra)|(decembar|decembra))/i,\n};\nconst parseMonthPatterns = {\n  narrow: [\n    /^1/i,\n    /^2/i,\n    /^3/i,\n    /^4/i,\n    /^5/i,\n    /^6/i,\n    /^7/i,\n    /^8/i,\n    /^9/i,\n    /^10/i,\n    /^11/i,\n    /^12/i,\n  ] as const,\n  any: [\n    /^ja/i,\n    /^f/i,\n    /^mar/i,\n    /^ap/i,\n    /^maj/i,\n    /^jun/i,\n    /^jul/i,\n    /^avg/i,\n    /^s/i,\n    /^o/i,\n    /^n/i,\n    /^d/i,\n  ] as const,\n};\n\nconst matchDayPatterns = {\n  narrow: /^[npusčc]/i,\n  short: /^(ned|pon|uto|sre|(čet|cet)|pet|sub)/i,\n  abbreviated: /^(ned|pon|uto|sre|(čet|cet)|pet|sub)/i,\n  wide: /^(nedjelja|ponedjeljak|utorak|srijeda|(četvrtak|cetvrtak)|petak|subota)/i,\n};\nconst parseDayPatterns = {\n  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i] as const,\n  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] as const,\n};\n\nconst matchDayPeriodPatterns = {\n  any: /^(am|pm|ponoc|ponoć|(po)?podne|uvece|uveče|noću|poslije podne|ujutru)/i,\n};\nconst parseDayPeriodPatterns = {\n  any: {\n    am: /^a/i,\n    pm: /^p/i,\n    midnight: /^pono/i,\n    noon: /^pod/i,\n    morning: /jutro/i,\n    afternoon: /(poslije\\s|po)+podne/i,\n    evening: /(uvece|uveče)/i,\n    night: /(nocu|noću)/i,\n  },\n};\n\nconst buildOrdinalNumberMatch = () => {\n  return buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: (value) => parseInt(value, 10),\n  });\n};\n\nconst buildEraMatch = () => {\n  return buildMatchFn({\n    matchPatterns: matchEraPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseEraPatterns,\n    defaultParseWidth: \"any\",\n  });\n};\n\nconst buildQuarterMatch = () => {\n  return buildMatchFn({\n    matchPatterns: matchQuarterPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseQuarterPatterns,\n    defaultParseWidth: \"any"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\nimport type { Quarter } from \"../../../../types.js\";\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\n\nconst eraValues = {\n  narrow: [\"AC\", \"DC\"],\n  abbreviated: [\"AC\", \"DC\"],\n  wide: [\"antes de cristo\", \"después de cristo\"],\n} as const;\n\nconst quarterValues = {\n  narrow: [\"1\", \"2\", \"3\", \"4\"],\n  abbreviated: [\"T1\", \"T2\", \"T3\", \"T4\"],\n  wide: [\"1º trimestre\", \"2º trimestre\", \"3º trimestre\", \"4º trimestre\"],\n} as const;\n\nconst monthValues = {\n  narrow: [\"e\", \"f\", \"m\", \"a\", \"m\", \"j\", \"j\", \"a\", \"s\", \"o\", \"n\", \"d\"],\n  abbreviated: [\n    \"ene\",\n    \"feb\",\n    \"mar\",\n    \"abr\",\n    \"may\",\n    \"jun\",\n    \"jul\",\n    \"ago\",\n    \"sep\",\n    \"oct\",\n    \"nov\",\n    \"dic\",\n  ],\n  wide: [\n    \"enero\",\n    \"febrero\",\n    \"marzo\",\n    \"abril\",\n    \"mayo\",\n    \"junio\",\n    \"julio\",\n    \"agosto\",\n    \"septiembre\",\n    \"octubre\",\n    \"noviembre\",\n    \"diciembre\",\n  ],\n} as const;\n\nconst dayValues = {\n  narrow: [\"d\", \"l\", \"m\", \"m\", \"j\", \"v\", \"s\"],\n  short: [\"do\", \"lu\", \"ma\", \"mi\", \"ju\", \"vi\", \"sá\"],\n  abbreviated: [\"dom\", \"lun\", \"mar\", \"mié\", \"jue\", \"vie\", \"sáb\"],\n  wide: [\n    \"domingo\",\n    \"lunes\",\n    \"martes\",\n    \"miércoles\",\n    \"jueves\",\n    \"viernes\",\n    \"sábado\",\n  ],\n} as const;\n\nconst dayPeriodValues = {\n  narrow: {\n    am: \"a\",\n    pm: \"p\",\n    midnight: \"mn\",\n    noon: \"md\",\n    morning: \"mañana\",\n    afternoon: \"tarde\",\n    evening: \"tarde\",\n    night: \"noche\",\n  },\n  abbreviated: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"medianoche\",\n    noon: \"mediodia\",\n    morning: \"mañana\",\n    afternoon: \"tarde\",\n    evening: \"tarde\",\n    night: \"noche\",\n  },\n  wide: {\n    am: \"a.m.\",\n    pm: \"p.m.\",\n    midnight: \"medianoche\",\n    noon: \"mediodia\",\n    morning: \"mañana\",\n    afternoon: \"tarde\",\n    evening: \"tarde\",\n    night: \"noche\",\n  },\n} as const;\n\nconst formattingDayPeriodValues = {\n  narrow: {\n    am: \"a\",\n    pm: \"p\",\n    midnight: \"mn\",\n    noon: \"md\",\n    morning: \"de la mañana\",\n    afternoon: \"de la tarde\",\n    evening: \"de la tarde\",\n    night: \"de la noche\",\n  },\n  abbreviated: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"medianoche\",\n    noon: \"mediodia\",\n    morning: \"de la mañana\",\n    afternoon: \"de la tarde\",\n    evening: \"de la tarde\",\n    night: \"de la noche\",\n  },\n  wide: {\n    am: \"a.m.\",\n    pm: \"p.m.\",\n    midnight: \"medianoche\",\n    noon: \"mediodia\",\n    morning: \"de la mañana\",\n    afternoon: \"de la tarde\",\n    evening: \"de la tarde\",\n    night: \"de la noche\",\n  },\n} as const;\n\nconst ordinalNumber: LocalizeFn<number> = (dirtyNumber, _options) => {\n  const number = Number(dirtyNumber);\n  return number + \"º\";\n};\n\nexport const localize: Localize = {\n  ordinalNumber: ordinalNumber,\n\n  era: buildLocalizeFn({\n    values: eraValues,\n    defaultWidth: \"wide\",\n  }),\n\n  quarter: buildLocalizeFn({\n    values: quarterValues,\n    defaultWidth: \"wide\",\n    argumentCallback: (quarter) => (Number(quarter) - 1) as Quarter,\n  }),\n\n  month: buildLocalizeFn({\n    values: monthValues,\n    defaultWidth: \"wide\",\n  }),\n\n  day: buildLocalizeFn({\n    values: dayValues,\n    defaultWidth: \"wide\",\n  }),\n\n  dayPeriod: buildLocalizeFn({\n    values: dayPeriodValues,\n    defaultWidth: \"wide\",\n    formattingValues: formattingDayPeriodValues,\n    defaultFormattingWidth: \"wide\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "import { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\nimport type { Quarter } from \"../../../../types.js\";\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\n\nconst eraValues = {\n  narrow: [\"AC\", \"DC\"],\n  abbreviated: [\"AC\", \"DC\"],\n  wide: [\"antes de cristo\", \"después de cristo\"],\n} as const;\n\nconst quarterValues = {\n  narrow: [\"1\", \"2\", \"3\", \"4\"],\n  abbreviated: [\"T1\", \"T2\", \"T3\", \"T4\"],\n  wide: [\"1º trimestre\", \"2º trimestre\", \"3º trimestre\", \"4º trimestre\"],\n} as const;\n\nconst monthValues = {\n  narrow: [\"e\", \"f\", \"m\", \"a\", \"m\", \"j\", \"j\", \"a\", \"s\", \"o\", \"n\", \"d\"],\n  abbreviated: [\n    \"ene\",\n    \"feb\",\n    \"mar\",\n    \"abr\",\n    \"may\",\n    \"jun\",\n    \"jul\",\n    \"ago\",\n    \"sep\",\n    \"oct\",\n    \"nov\",\n    \"dic\",\n  ],\n  wide: [\n    \"enero\",\n    \"febrero\",\n    \"marzo\",\n    \"abril\",\n    \"mayo\",\n    \"junio\",\n    \"julio\",\n    \"agosto\",\n    \"septiembre\",\n    \"octubre\",\n    \"noviembre\",\n    \"diciembre\",\n  ],\n} as const;\n\nconst dayValues = {\n  narrow: [\"d\", \"l\", \"m\", \"m\", \"j\", \"v\", \"s\"],\n  short: [\"do\", \"lu\", \"ma\", \"mi\", \"ju\", \"vi\", \"sá\"],\n  abbreviated: [\"dom\", \"lun\", \"mar\", \"mié\", \"jue\", \"vie\", \"sáb\"],\n  wide: [\n    \"domingo\",\n    \"lunes\",\n    \"martes\",\n    \"miércoles\",\n    \"jueves\",\n    \"viernes\",\n    \"sábado\",\n  ],\n} as const;\n\nconst dayPeriodValues = {\n  narrow: {\n    am: \"a\",\n    pm: \"p\",\n    midnight: \"mn\",\n    noon: \"md\",\n    morning: \"mañana\",\n    afternoon: \"tarde\",\n    evening: \"tarde\",\n    night: \"noche\",\n  },\n  abbreviated: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"medianoche\",\n    noon: \"mediodia\",\n    morning: \"mañana\",\n    afternoon: \"tarde\",\n    evening: \"tarde\",\n    night: \"noche\",\n  },\n  wide: {\n    am: \"a.m.\",\n    pm: \"p.m.\",\n    midnight: \"medianoche\",\n    noon: \"mediodia\",\n    morning: \"mañana\",\n    afternoon: \"tarde\",\n    evening: \"tarde\",\n    night: \"noche\",\n  },\n} as const;\n\nconst formattingDayPeriodValues = {\n  narrow: {\n    am: \"a\",\n    pm: \"p\",\n    midnight: \"mn\",\n    noon: \"md\",\n    morning: \"de la mañana\",\n    afternoon: \"de la tarde\",\n    evening: \"de la tarde\",\n    night: \"de la noche\",\n  },\n  abbreviated: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"medianoche\",\n    noon: \"mediodia\",\n    morning: \"de la mañana\",\n    afternoon: \"de la tarde\",\n    evening: \"de la tarde\",\n    night: \"de la noche\",\n  },\n  wide: {\n    am: \"a.m.\",\n    pm: \"p.m.\",\n    midnight: \"medianoche\",\n    noon: \"mediodia\",\n    morning: \"de la mañana\",\n    afternoon: \"de la tarde\",\n    evening: \"de la tarde\",\n    night: \"de la noche\",\n  },\n} as const;\n\nconst ordinalNumber: LocalizeFn<number> = (dirtyNumber, _options) => {\n  const number = Number(dirtyNumber);\n  return number + \"º\";\n};\n\nconst buildEraLocalize = () => buildLocalizeFn({\n  values: eraValues,\n  defaultWidth: \"wide\",\n});\n\nconst buildQuarterLocalize = () => buildLocalizeFn({\n  values: quarterValues,\n  defaultWidth: \"wide\",\n  argumentCallback: (quarter) => (Number(quarter) - 1) as Quarter,\n});\n\nconst buildMonthLocalize = () => buildLocalizeFn({\n  values: monthValues,\n  defaultWidth: \"wide\",\n});\n\nconst buildDayLocal"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\nimport { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\n\nconst eraValues = {\n  narrow: [\"לפנה״ס\", \"לספירה\"] as const,\n  abbreviated: [\"לפנה״ס\", \"לספירה\"] as const,\n  wide: [\"לפני הספירה\", \"לספירה\"] as const,\n};\n\nconst quarterValues = {\n  narrow: [\"1\", \"2\", \"3\", \"4\"] as const,\n  abbreviated: [\"Q1\", \"Q2\", \"Q3\", \"Q4\"] as const,\n  wide: [\"רבעון 1\", \"רבעון 2\", \"רבעון 3\", \"רבעון 4\"] as const,\n};\n\nconst monthValues = {\n  narrow: [\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"10\",\n    \"11\",\n    \"12\",\n  ] as const,\n  abbreviated: [\n    \"ינו׳\",\n    \"פבר׳\",\n    \"מרץ\",\n    \"אפר׳\",\n    \"מאי\",\n    \"יוני\",\n    \"יולי\",\n    \"אוג׳\",\n    \"ספט׳\",\n    \"אוק׳\",\n    \"נוב׳\",\n    \"דצמ׳\",\n  ] as const,\n  wide: [\n    \"ינואר\",\n    \"פברואר\",\n    \"מרץ\",\n    \"אפריל\",\n    \"מאי\",\n    \"יוני\",\n    \"יולי\",\n    \"אוגוסט\",\n    \"ספטמבר\",\n    \"אוקטובר\",\n    \"נובמבר\",\n    \"דצמבר\",\n  ] as const,\n};\n\nconst dayValues = {\n  narrow: [\"א׳\", \"ב׳\", \"ג׳\", \"ד׳\", \"ה׳\", \"ו׳\", \"ש׳\"] as const,\n  short: [\"א׳\", \"ב׳\", \"ג׳\", \"ד׳\", \"ה׳\", \"ו׳\", \"ש׳\"] as const,\n  abbreviated: [\n    \"יום א׳\",\n    \"יום ב׳\",\n    \"יום ג׳\",\n    \"יום ד׳\",\n    \"יום ה׳\",\n    \"יום ו׳\",\n    \"שבת\",\n  ] as const,\n  wide: [\n    \"יום ראשון\",\n    \"יום שני\",\n    \"יום שלישי\",\n    \"יום רביעי\",\n    \"יום חמישי\",\n    \"יום שישי\",\n    \"יום שבת\",\n  ] as const,\n};\n\nconst dayPeriodValues = {\n  narrow: {\n    am: \"לפנה״צ\",\n    pm: \"אחה״צ\",\n    midnight: \"חצות\",\n    noon: \"צהריים\",\n    morning: \"בוקר\",\n    afternoon: \"אחר הצהריים\",\n    evening: \"ערב\",\n    night: \"לילה\",\n  },\n  abbreviated: {\n    am: \"לפנה״צ\",\n    pm: \"אחה״צ\",\n    midnight: \"חצות\",\n    noon: \"צהריים\",\n    morning: \"בוקר\",\n    afternoon: \"אחר הצהריים\",\n    evening: \"ערב\",\n    night: \"לילה\",\n  },\n  wide: {\n    am: \"לפנה״צ\",\n    pm: \"אחה״צ\",\n    midnight: \"חצות\",\n    noon: \"צהריים\",\n    morning: \"בוקר\",\n    afternoon: \"אחר הצהריים\",\n    evening: \"ערב\",\n    night: \"לילה\",\n  },\n};\n\nconst formattingDayPeriodValues = {\n  narrow: {\n    am: \"לפנה״צ\",\n    pm: \"אחה״צ\",\n    midnight: \"חצות\",\n    noon: \"צהריים\",\n    morning: \"בבוקר\",\n    afternoon: \"בצהריים\",\n    evening: \"בערב\",\n    night: \"בלילה\",\n  },\n  abbreviated: {\n    am: \"לפנה״צ\",\n    pm: \"אחה״צ\",\n    midnight: \"חצות\",\n    noon: \"צהריים\",\n    morning: \"בבוקר\",\n    afternoon: \"אחר הצהריים\",\n    evening: \"בערב\",\n    night: \"בלילה\",\n  },\n  wide: {\n    am: \"לפנה״צ\",\n    pm: \"אחה״צ\",\n    midnight: \"חצות\",\n    noon: \"צהריים\",\n    morning: \"בבוקר\",\n    afternoon: \"אחר הצהריים\",\n    evening: \"בערב\",\n    night: \"בלילה\",\n  },\n};\n\nconst ordinalNumber: LocalizeFn<number> = (dirtyNumber, options) => {\n  const number = Number(dirtyNumber);\n\n  // We only show words till 10\n  if (number <= 0 || number > 10) return String(number);\n\n  const unit = String(options?.unit);\n\n  const isFemale = [\"year\", \"hour\", \"minute\", \"second\"].indexOf(unit) >= 0;\n\n  const male = [\n    \"ראשון\",\n    \"שני\",\n    \"שלישי\",\n    \"רביעי\",\n    \"חמישי\",\n    \"שישי\",\n    \"שביעי\",\n    \"שמיני\",\n    \"תשיעי\",\n    \"עשירי\",\n  ];\n  const female = [\n    \"ראשונה\",\n    \"שנייה\",\n    \"שלישית\",\n    \"רביעית\",\n    \"חמישית\",\n    \"שישית\",\n    \"שביעית\",\n    \"שמינית\",\n    \"תשיעית\",\n    \"עשירית\",\n  ];\n\n  const index = number - 1;\n  return isFemale ? female[index] : male[index];\n};\n\nexport const localize: Localize = {\n  ordinalNumber,\n\n  era: buildLocalizeFn({\n    values: eraValues,\n    defaultWidth: \"wide\",\n  }),\n\n  quarter: buildLocalizeFn({\n    values: quarterValues,\n    defaultWidth: \"wide\",\n    argumentCallback: (quarter) => quarter - 1,\n  }),\n\n  month: buildLocalizeFn({\n    values: monthValues,\n    defaultWidth: \"wide\",\n  }),\n\n  day: buildLocalizeFn({\n    values: dayValues,\n    defaultWidth: \"wide\",\n  }),\n\n  dayPeriod: buildLocalizeFn({\n    values: dayPeriodValues,\n    defaultWidth: \"wide\",\n    formattingValues: formattingDayPeriodValues,\n    defaultFormattingWidth: \"wide\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "```javascript\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\nimport { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\n\nconst eraValues = {\n  narrow: [\"לפנה״ס\", \"לספירה\"] as const,\n  abbreviated: [\"לפנה״ס\", \"לספירה\"] as const,\n  wide: [\"לפני הספירה\", \"לספירה\"] as const,\n};\n\nconst quarterValues = {\n  narrow: [\"1\", \"2\", \"3\", \"4\"] as const,\n  abbreviated: [\"Q1\", \"Q2\", \"Q3\", \"Q4\"] as const,\n  wide: [\"רבעון 1\", \"רבעון 2\", \"רבעון 3\", \"רבעון 4\"] as const,\n};\n\nconst monthValues = {\n  narrow: [\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"10\",\n    \"11\",\n    \"12\",\n  ] as const,\n  abbreviated: [\n    \"ינו׳\",\n    \"פבר׳\",\n    \"מרץ\",\n    \"אפר׳\",\n    \"מאי\",\n    \"יוני\",\n    \"יולי\",\n    \"אוג׳\",\n    \"ספט׳\",\n    \"אוק׳\",\n    \"נוב׳\",\n    \"דצמ׳\",\n  ] as const,\n  wide: [\n    \"ינואר\",\n    \"פברואר\",\n    \"מרץ\",\n    \"אפריל\",\n    \"מאי\",\n    \"יוני\",\n    \"יולי\",\n    \"אוגוסט\",\n    \"ספטמבר\",\n    \"אוקטובר\",\n    \"נובמבר\",\n    \"דצמבר\",\n  ] as const,\n};\n\nconst dayValues = {\n  narrow: [\"א׳\", \"ב׳\", \"ג׳\", \"ד׳\", \"ה׳\", \"ו׳\", \"ש׳\"] as const,\n  short: [\"א׳\", \"ב׳\", \"ג׳\", \"ד׳\", \"ה׳\", \"ו׳\", \"ש׳\"] as const,\n  abbreviated: [\n    \"יום א׳\",\n    \"יום ב׳\",\n    \"יום ג׳\",\n    \"יום ד׳\",\n    \"יום ה׳\",\n    \"יום ו׳\",\n    \"שבת\",\n  ] as const,\n  wide: [\n    \"יום ראשון\",\n    \"יום שני\",\n    \"יום שלישי\",\n    \"יום רביעי\",\n    \"יום חמישי\",\n    \"יום שישי\",\n    \"יום שבת\",\n  ] as const,\n};\n\nconst dayPeriodValues = {\n  narrow: {\n    am: \"לפנה״צ\",\n    pm: \"אחה״צ\",\n    midnight: \"חצות\",\n    noon: \"צהריים\",\n    morning: \"בוקר\",\n    afternoon: \"אחר הצהריים\",\n    evening: \"ערב\",\n    night: \"לילה\",\n  },\n  abbreviated: {\n    am: \"לפנה״צ\",\n    pm: \"אחה״צ\",\n    midnight: \"חצות\",\n    noon: \"צהריים\",\n    morning: \"בוקר\",\n    afternoon: \"אחר הצהריים\",\n    evening: \"ערב\",\n    night: \"לילה\",\n  },\n  wide: {\n    am: \"לפנה״צ\",\n    pm: \"אחה״צ\",\n    midnight: \"חצות\",\n    noon: \"צהריים\",\n    morning: \"ב"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Quarter } from \"../../../../types.js\";\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\nimport { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\n\nconst eraValues = {\n  narrow: [\"BC\", \"AC\"] as const,\n  abbreviated: [\"きげんぜん\", \"せいれき\"] as const,\n  wide: [\"きげんぜん\", \"せいれき\"] as const,\n};\n\nconst quarterValues = {\n  narrow: [\"1\", \"2\", \"3\", \"4\"] as const,\n  abbreviated: [\"Q1\", \"Q2\", \"Q3\", \"Q4\"] as const,\n  wide: [\n    \"だい1しはんき\",\n    \"だい2しはんき\",\n    \"だい3しはんき\",\n    \"だい4しはんき\",\n  ] as const,\n};\n\nconst monthValues = {\n  narrow: [\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"10\",\n    \"11\",\n    \"12\",\n  ] as const,\n  abbreviated: [\n    \"1がつ\",\n    \"2がつ\",\n    \"3がつ\",\n    \"4がつ\",\n    \"5がつ\",\n    \"6がつ\",\n    \"7がつ\",\n    \"8がつ\",\n    \"9がつ\",\n    \"10がつ\",\n    \"11がつ\",\n    \"12がつ\",\n  ] as const,\n  wide: [\n    \"1がつ\",\n    \"2がつ\",\n    \"3がつ\",\n    \"4がつ\",\n    \"5がつ\",\n    \"6がつ\",\n    \"7がつ\",\n    \"8がつ\",\n    \"9がつ\",\n    \"10がつ\",\n    \"11がつ\",\n    \"12がつ\",\n  ] as const,\n};\n\nconst dayValues = {\n  narrow: [\"にち\", \"げつ\", \"か\", \"すい\", \"もく\", \"きん\", \"ど\"] as const,\n  short: [\"にち\", \"げつ\", \"か\", \"すい\", \"もく\", \"きん\", \"ど\"] as const,\n  abbreviated: [\"にち\", \"げつ\", \"か\", \"すい\", \"もく\", \"きん\", \"ど\"] as const,\n  wide: [\n    \"にちようび\",\n    \"げつようび\",\n    \"かようび\",\n    \"すいようび\",\n    \"もくようび\",\n    \"きんようび\",\n    \"どようび\",\n  ] as const,\n};\n\nconst dayPeriodValues = {\n  narrow: {\n    am: \"ごぜん\",\n    pm: \"ごご\",\n    midnight: \"しんや\",\n    noon: \"しょうご\",\n    morning: \"あさ\",\n    afternoon: \"ごご\",\n    evening: \"よる\",\n    night: \"しんや\",\n  },\n  abbreviated: {\n    am: \"ごぜん\",\n    pm: \"ごご\",\n    midnight: \"しんや\",\n    noon: \"しょうご\",\n    morning: \"あさ\",\n    afternoon: \"ごご\",\n    evening: \"よる\",\n    night: \"しんや\",\n  },\n  wide: {\n    am: \"ごぜん\",\n    pm: \"ごご\",\n    midnight: \"しんや\",\n    noon: \"しょうご\",\n    morning: \"あさ\",\n    afternoon: \"ごご\",\n    evening: \"よる\",\n    night: \"しんや\",\n  },\n};\nconst formattingDayPeriodValues = {\n  narrow: {\n    am: \"ごぜん\",\n    pm: \"ごご\",\n    midnight: \"しんや\",\n    noon: \"しょうご\",\n    morning: \"あさ\",\n    afternoon: \"ごご\",\n    evening: \"よる\",\n    night: \"しんや\",\n  },\n  abbreviated: {\n    am: \"ごぜん\",\n    pm: \"ごご\",\n    midnight: \"しんや\",\n    noon: \"しょうご\",\n    morning: \"あさ\",\n    afternoon: \"ごご\",\n    evening: \"よる\",\n    night: \"しんや\",\n  },\n  wide: {\n    am: \"ごぜん\",\n    pm: \"ごご\",\n    midnight: \"しんや\",\n    noon: \"しょうご\",\n    morning: \"あさ\",\n    afternoon: \"ごご\",\n    evening: \"よる\",\n    night: \"しんや\",\n  },\n};\n\nconst ordinalNumber: LocalizeFn<number> = (dirtyNumber, options) => {\n  const number = Number(dirtyNumber);\n  const unit = String(options?.unit);\n\n  switch (unit) {\n    case \"year\":\n      return `${number}ねん`;\n    case \"quarter\":\n      return `だい${number}しはんき`;\n    case \"month\":\n      return `${number}がつ`;\n    case \"week\":\n      return `だい${number}しゅう`;\n    case \"date\":\n      return `${number}にち`;\n    case \"hour\":\n      return `${number}じ`;\n    case \"minute\":\n      return `${number}ふん`;\n    case \"second\":\n      return `${number}びょう`;\n    default:\n      return `${number}`;\n  }\n};\n\nexport const localize: Localize = {\n  ordinalNumber: ordinalNumber,\n\n  era: buildLocalizeFn({\n    values: eraValues,\n    defaultWidth: \"wide\",\n  }),\n\n  quarter: buildLocalizeFn({\n    values: quarterValues,\n    defaultWidth: \"wide\",\n    argumentCallback: (quarter) => (Number(quarter) - 1) as Quarter,\n  }),\n\n  month: buildLocalizeFn({\n    values: monthValues,\n    defaultWidth: \"wide\",\n  }),\n\n  day: buildLocalizeFn({\n    values: dayValues,\n    defaultWidth: \"wide\",\n  }),\n\n  dayPeriod: buildLocalizeFn({\n    values: dayPeriodValues,\n    defaultWidth: \"wide\",\n    formattingValues: formattingDayPeriodValues,\n    defaultFormattingWidth: \"wide\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { Quarter } from \"../../../../types.js\";\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\nimport { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\n\nconst eraValues = {\n  narrow: [\"BC\", \"AC\"] as const,\n  abbreviated: [\"きげんぜん\", \"せいれき\"] as const,\n  wide: [\"きげんぜん\", \"せいれき\"] as const,\n};\n\nconst quarterValues = {\n  narrow: [\"1\", \"2\", \"3\", \"4\"] as const,\n  abbreviated: [\"Q1\", \"Q2\", \"Q3\", \"Q4\"] as const,\n  wide: [\n    \"だい1しはんき\",\n    \"だい2しはんき\",\n    \"だい3しはんき\",\n    \"だい4しはんき\",\n  ] as const,\n};\n\nconst monthValues = {\n  narrow: [\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"10\",\n    \"11\",\n    \"12\",\n  ] as const,\n  abbreviated: [\n    \"1がつ\",\n    \"2がつ\",\n    \"3がつ\",\n    \"4がつ\",\n    \"5がつ\",\n    \"6がつ\",\n    \"7がつ\",\n    \"8がつ\",\n    \"9がつ\",\n    \"10がつ\",\n    \"11がつ\",\n    \"12がつ\",\n  ] as const,\n  wide: [\n    \"1がつ\",\n    \"2がつ\",\n    \"3がつ\",\n    \"4がつ\",\n    \"5がつ\",\n    \"6がつ\",\n    \"7がつ\",\n    \"8がつ\",\n    \"9がつ\",\n    \"10がつ\",\n    \"11がつ\",\n    \"12がつ\",\n  ] as const,\n};\n\nconst dayValues = {\n  narrow: [\"にち\", \"げつ\", \"か\", \"すい\", \"もく\", \"きん\", \"ど\"] as const,\n  short: [\"にち\", \"げつ\", \"か\", \"すい\", \"もく\", \"きん\", \"ど\"] as const,\n  abbreviated: [\"にち\", \"げつ\", \"か\", \"すい\", \"もく\", \"きん\", \"ど\"] as const,\n  wide: [\n    \"にちようび\",\n    \"げつようび\",\n    \"かようび\",\n    \"すいようび\",\n    \"もくようび\",\n    \"きんようび\",\n    \"どようび\",\n  ] as const,\n};\n\nconst dayPeriodValues = {\n  narrow: {\n    am: \"ごぜん\",\n    pm: \"ごご\",\n    midnight: \"しんや\",\n    noon: \"しょうご\",\n    morning: \"あさ\",\n    afternoon: \"ごご\",\n    evening: \"よる\",\n    night: \"しんや\",\n  },\n  abbreviated: {\n    am: \"ごぜん\",\n    pm: \"ごご\",\n    midnight: \"しんや\",\n    noon: \"しょうご\",\n    morning: \"あさ\",\n    afternoon: \"ごご\",\n    evening: \"よる\",\n    night: \"しんや\",\n  },\n  wide: {\n    am: \"ごぜん\",\n    pm: \"ごご\",\n    midnight: \"しんや\",\n    noon: \"しょうご\",\n    morning: \"あさ\",\n    afternoon: \"ごご\",\n    evening: \"よる\",\n    night: \"しんや\",\n  },\n};\nconst formattingDayPeriodValues = {\n  narrow: {\n    am: \"ごぜん\",\n    pm: \"ごご\",\n    midnight: \"しんや\",\n    noon: \"しょうご\",\n    morning: \"あさ\",\n    afternoon: \"ごご\",\n    evening: \"よる\",\n    night: \"しんや\",\n  },\n  abbreviated: {\n    am: \"ごぜん\",\n    pm: \"ごご\",\n    midnight: \"しんや\",\n    noon: \"しょうご\",\n    morning: \"あさ\",\n    afternoon: \"ごご\",\n    evening: \"よる\",\n    night: \"しんや\",\n  },\n  wide: {\n    am: \"ごぜん\",\n    pm: \"ごご\",\n    midnight: \"しんや\",\n    noon: \"しょうご\",\n    morning: \""
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Quarter } from \"../../../../types.js\";\nimport type { Match } from \"../../../types.js\";\nimport { buildMatchFn } from \"../../../_lib/buildMatchFn/index.js\";\nimport { buildMatchPatternFn } from \"../../../_lib/buildMatchPatternFn/index.js\";\n\nconst matchOrdinalNumberPattern = /\\d+/i;\nconst parseOrdinalNumberPattern = /\\d+/i;\n\nconst matchEraPatterns = {\n  narrow: /^(нтө|нт)/i,\n  abbreviated: /^(нтө|нт)/i,\n  wide: /^(нийтийн тооллын өмнө|нийтийн тооллын)/i,\n};\nconst parseEraPatterns = {\n  any: [/^(нтө|нийтийн тооллын өмнө)/i, /^(нт|нийтийн тооллын)/i] as const,\n};\n\nconst matchQuarterPatterns = {\n  narrow: /^(iv|iii|ii|i)/i,\n  abbreviated: /^(iv|iii|ii|i) улирал/i,\n  wide: /^[1-4]-р улирал/i,\n};\nconst parseQuarterPatterns = {\n  any: [\n    /^(i(\\s|$)|1)/i,\n    /^(ii(\\s|$)|2)/i,\n    /^(iii(\\s|$)|3)/i,\n    /^(iv(\\s|$)|4)/i,\n  ] as const,\n};\n\nconst matchMonthPatterns = {\n  narrow: /^(xii|xi|x|ix|viii|vii|vi|v|iv|iii|ii|i)/i,\n  abbreviated:\n    /^(1-р сар|2-р сар|3-р сар|4-р сар|5-р сар|6-р сар|7-р сар|8-р сар|9-р сар|10-р сар|11-р сар|12-р сар)/i,\n  wide: /^(нэгдүгээр сар|хоёрдугаар сар|гуравдугаар сар|дөрөвдүгээр сар|тавдугаар сар|зургаадугаар сар|долоодугаар сар|наймдугаар сар|есдүгээр сар|аравдугаар сар|арван нэгдүгээр сар|арван хоёрдугаар сар)/i,\n};\nconst parseMonthPatterns = {\n  narrow: [\n    /^i$/i,\n    /^ii$/i,\n    /^iii$/i,\n    /^iv$/i,\n    /^v$/i,\n    /^vi$/i,\n    /^vii$/i,\n    /^viii$/i,\n    /^ix$/i,\n    /^x$/i,\n    /^xi$/i,\n    /^xii$/i,\n  ] as const,\n  any: [\n    /^(1|нэгдүгээр)/i,\n    /^(2|хоёрдугаар)/i,\n    /^(3|гуравдугаар)/i,\n    /^(4|дөрөвдүгээр)/i,\n    /^(5|тавдугаар)/i,\n    /^(6|зургаадугаар)/i,\n    /^(7|долоодугаар)/i,\n    /^(8|наймдугаар)/i,\n    /^(9|есдүгээр)/i,\n    /^(10|аравдугаар)/i,\n    /^(11|арван нэгдүгээр)/i,\n    /^(12|арван хоёрдугаар)/i,\n  ] as const,\n};\n\nconst matchDayPatterns = {\n  narrow: /^[ндмлпбб]/i,\n  short: /^(ня|да|мя|лх|пү|ба|бя)/i,\n  abbreviated: /^(ням|дав|мяг|лха|пүр|баа|бям)/i,\n  wide: /^(ням|даваа|мягмар|лхагва|пүрэв|баасан|бямба)/i,\n};\nconst parseDayPatterns = {\n  narrow: [/^н/i, /^д/i, /^м/i, /^л/i, /^п/i, /^б/i, /^б/i] as const,\n  any: [/^ня/i, /^да/i, /^мя/i, /^лх/i, /^пү/i, /^ба/i, /^бя/i] as const,\n};\n\nconst matchDayPeriodPatterns = {\n  narrow: /^(ү\\.ө\\.|ү\\.х\\.|шөнө дунд|үд дунд|өглөө|өдөр|орой|шөнө)/i,\n  any: /^(ү\\.ө\\.|ү\\.х\\.|шөнө дунд|үд дунд|өглөө|өдөр|орой|шөнө)/i,\n};\nconst parseDayPeriodPatterns = {\n  any: {\n    am: /^ү\\.ө\\./i,\n    pm: /^ү\\.х\\./i,\n    midnight: /^шөнө дунд/i,\n    noon: /^үд дунд/i,\n    morning: /өглөө/i,\n    afternoon: /өдөр/i,\n    evening: /орой/i,\n    night: /шөнө/i,\n  },\n};\n\nexport const match: Match = {\n  ordinalNumber: buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: (value) => parseInt(value, 10),\n  }),\n\n  era: buildMatchFn({\n    matchPatterns: matchEraPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseEraPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  quarter: buildMatchFn({\n    matchPatterns: matchQuarterPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseQuarterPatterns,\n    defaultParseWidth: \"any\",\n    valueCallback: (index) => (index + 1) as Quarter,\n  }),\n\n  month: buildMatchFn({\n    matchPatterns: matchMonthPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseMonthPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  day: buildMatchFn({\n    matchPatterns: matchDayPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseDayPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  dayPeriod: buildMatchFn({\n    matchPatterns: matchDayPeriodPatterns,\n    defaultMatchWidth: \"any\",\n    parsePatterns: parseDayPeriodPatterns,\n    defaultParseWidth: \"any\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "import { buildMatchFn } from \"../../../_lib/buildMatchFn/index.js\";\nimport { buildMatchPatternFn } from \"../../../_lib/buildMatchPatternFn/index.js\";\n\nconst matchOrdinalNumberPattern = /\\d+/i;\nconst parseOrdinalNumberPattern = /\\d+/i;\n\nconst matchEraPatterns = {\n  narrow: /^(нтө|нт)/i,\n  abbreviated: /^(нтө|нт)/i,\n  wide: /^(нийтийн тооллын өмнө|нийтийн тооллын)/i,\n};\nconst parseEraPatterns = {\n  any: [/^(нтө|нийтийн тооллын өмнө)/i, /^(нт|нийтийн тооллын)/i] as const,\n};\n\nconst matchQuarterPatterns = {\n  narrow: /^(iv|iii|ii|i)/i,\n  abbreviated: /^(iv|iii|ii|i) улирал/i,\n  wide: /^[1-4]-р улирал/i,\n};\nconst parseQuarterPatterns = {\n  any: [\n    /^(i(\\s|$)|1)/i,\n    /^(ii(\\s|$)|2)/i,\n    /^(iii(\\s|$)|3)/i,\n    /^(iv(\\s|$)|4)/i,\n  ] as const,\n};\n\nconst matchMonthPatterns = {\n  narrow: /^(xii|xi|x|ix|viii|vii|vi|v|iv|iii|ii|i)/i,\n  abbreviated:\n    /^(1-р сар|2-р сар|3-р сар|4-р сар|5-р сар|6-р сар|7-р сар|8-р сар|9-р сар|10-р сар|11-р сар|12-р сар)/i,\n  wide: /^(нэгдүгээр сар|хоёрдугаар сар|гуравдугаар сар|дөрөвдүгээр сар|тавдугаар сар|зургаадугаар сар|долоодугаар сар|наймдугаар сар|есдүгээр сар|аравдугаар сар|арван нэгдүгээр сар|арван хоёрдугаар сар)/i,\n};\nconst parseMonthPatterns = {\n  narrow: [\n    /^i$/i,\n    /^ii$/i,\n    /^iii$/i,\n    /^iv$/i,\n    /^v$/i,\n    /^vi$/i,\n    /^vii$/i,\n    /^viii$/i,\n    /^ix$/i,\n    /^x$/i,\n    /^xi$/i,\n    /^xii$/i,\n  ] as const,\n  any: [\n    /^(1|нэгдүгээр)/i,\n    /^(2|хоёрдугаар)/i,\n    /^(3|гуравдугаар)/i,\n    /^(4|дөрөвдүгээр)/i,\n    /^(5|тавдугаар)/i,\n    /^(6|зургаадугаар)/i,\n    /^(7|долоодугаар)/i,\n    /^(8|наймдугаар)/i,\n    /^(9|есдүгээр)/i,\n    /^(10|аравдугаар)/i,\n    /^(11|арван нэгдүгээр)/i,\n    /^(12|арван хоёрдугаар)/i,\n  ] as const,\n};\n\nconst matchDayPatterns = {\n  narrow: /^[ндмлпбб]/i,\n  short: /^(ня|да|мя|лх|пү|ба|бя)/i,\n  abbreviated: /^(ням|дав|мяг|лха|пүр|баа|бям)/i,\n  wide: /^(ням|даваа|мягмар|лхагва|пүрэв|баасан|бямба)/i,\n};\nconst parseDayPatterns = {\n  narrow: [/^н/i, /^д/i, /^м/i, /^л/i, /^п/i,"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\nimport { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\n\nconst eraValues = {\n  narrow: [\"AC\", \"DC\"] as const,\n  abbreviated: [\"AC\", \"DC\"] as const,\n  wide: [\"antes de cristo\", \"depois de cristo\"] as const,\n};\n\nconst quarterValues = {\n  narrow: [\"1\", \"2\", \"3\", \"4\"] as const,\n  abbreviated: [\"T1\", \"T2\", \"T3\", \"T4\"] as const,\n  wide: [\n    \"1º trimestre\",\n    \"2º trimestre\",\n    \"3º trimestre\",\n    \"4º trimestre\",\n  ] as const,\n};\n\nconst monthValues = {\n  narrow: [\"j\", \"f\", \"m\", \"a\", \"m\", \"j\", \"j\", \"a\", \"s\", \"o\", \"n\", \"d\"] as const,\n  abbreviated: [\n    \"jan\",\n    \"fev\",\n    \"mar\",\n    \"abr\",\n    \"mai\",\n    \"jun\",\n    \"jul\",\n    \"ago\",\n    \"set\",\n    \"out\",\n    \"nov\",\n    \"dez\",\n  ] as const,\n  wide: [\n    \"janeiro\",\n    \"fevereiro\",\n    \"março\",\n    \"abril\",\n    \"maio\",\n    \"junho\",\n    \"julho\",\n    \"agosto\",\n    \"setembro\",\n    \"outubro\",\n    \"novembro\",\n    \"dezembro\",\n  ] as const,\n};\n\nconst dayValues = {\n  narrow: [\"D\", \"S\", \"T\", \"Q\", \"Q\", \"S\", \"S\"] as const,\n  short: [\"dom\", \"seg\", \"ter\", \"qua\", \"qui\", \"sex\", \"sab\"] as const,\n  abbreviated: [\n    \"domingo\",\n    \"segunda\",\n    \"terça\",\n    \"quarta\",\n    \"quinta\",\n    \"sexta\",\n    \"sábado\",\n  ] as const,\n  wide: [\n    \"domingo\",\n    \"segunda-feira\",\n    \"terça-feira\",\n    \"quarta-feira\",\n    \"quinta-feira\",\n    \"sexta-feira\",\n    \"sábado\",\n  ] as const,\n};\n\nconst dayPeriodValues = {\n  narrow: {\n    am: \"a\",\n    pm: \"p\",\n    midnight: \"mn\",\n    noon: \"md\",\n    morning: \"manhã\",\n    afternoon: \"tarde\",\n    evening: \"tarde\",\n    night: \"noite\",\n  },\n  abbreviated: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"meia-noite\",\n    noon: \"meio-dia\",\n    morning: \"manhã\",\n    afternoon: \"tarde\",\n    evening: \"tarde\",\n    night: \"noite\",\n  },\n  wide: {\n    am: \"a.m.\",\n    pm: \"p.m.\",\n    midnight: \"meia-noite\",\n    noon: \"meio-dia\",\n    morning: \"manhã\",\n    afternoon: \"tarde\",\n    evening: \"tarde\",\n    night: \"noite\",\n  },\n};\n\nconst formattingDayPeriodValues = {\n  narrow: {\n    am: \"a\",\n    pm: \"p\",\n    midnight: \"mn\",\n    noon: \"md\",\n    morning: \"da manhã\",\n    afternoon: \"da tarde\",\n    evening: \"da tarde\",\n    night: \"da noite\",\n  },\n  abbreviated: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"meia-noite\",\n    noon: \"meio-dia\",\n    morning: \"da manhã\",\n    afternoon: \"da tarde\",\n    evening: \"da tarde\",\n    night: \"da noite\",\n  },\n  wide: {\n    am: \"a.m.\",\n    pm: \"p.m.\",\n    midnight: \"meia-noite\",\n    noon: \"meio-dia\",\n    morning: \"da manhã\",\n    afternoon: \"da tarde\",\n    evening: \"da tarde\",\n    night: \"da noite\",\n  },\n};\n\nconst ordinalNumber: LocalizeFn<number> = (dirtyNumber, options) => {\n  const number = Number(dirtyNumber);\n\n  if (options?.unit === \"week\") {\n    return number + \"ª\";\n  }\n  return number + \"º\";\n};\n\nexport const localize: Localize = {\n  ordinalNumber,\n\n  era: buildLocalizeFn({\n    values: eraValues,\n    defaultWidth: \"wide\",\n  }),\n\n  quarter: buildLocalizeFn({\n    values: quarterValues,\n    defaultWidth: \"wide\",\n    argumentCallback: (quarter) => quarter - 1,\n  }),\n\n  month: buildLocalizeFn({\n    values: monthValues,\n    defaultWidth: \"wide\",\n  }),\n\n  day: buildLocalizeFn({\n    values: dayValues,\n    defaultWidth: \"wide\",\n  }),\n\n  dayPeriod: buildLocalizeFn({\n    values: dayPeriodValues,\n    defaultWidth: \"wide\",\n    formattingValues: formattingDayPeriodValues,\n    defaultFormattingWidth: \"wide\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "```javascript\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\nimport { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\n\nconst ordinalNumber: LocalizeFn<number> = (dirtyNumber, options) => {\n  const number = Number(dirtyNumber);\n\n  if (options?.unit === \"week\") {\n    return number + \"ª\";\n  }\n  return number + \"º\";\n};\n\nconst getEraValues = () => ({\n  narrow: [\"AC\", \"DC\"] as const,\n  abbreviated: [\"AC\", \"DC\"] as const,\n  wide: [\"antes de cristo\", \"depois de cristo\"] as const,\n});\n\nconst getQuarterValues = () => ({\n  narrow: [\"1\", \"2\", \"3\", \"4\"] as const,\n  abbreviated: [\"T1\", \"T2\", \"T3\", \"T4\"] as const,\n  wide: [\n    \"1º trimestre\",\n    \"2º trimestre\",\n    \"3º trimestre\",\n    \"4º trimestre\",\n  ] as const,\n});\n\nconst getMonthValues = () => ({\n  narrow: [\"j\", \"f\", \"m\", \"a\", \"m\", \"j\", \"j\", \"a\", \"s\", \"o\", \"n\", \"d\"] as const,\n  abbreviated: [\n    \"jan\",\n    \"fev\",\n    \"mar\",\n    \"abr\",\n    \"mai\",\n    \"jun\",\n    \"jul\",\n    \"ago\",\n    \"set\",\n    \"out\",\n    \"nov\",\n    \"dez\",\n  ] as const,\n  wide: [\n    \"janeiro\",\n    \"fevereiro\",\n    \"março\",\n    \"abril\",\n    \"maio\",\n    \"junho\",\n    \"julho\",\n    \"agosto\",\n    \"setembro\",\n    \"outubro\",\n    \"novembro\",\n    \"dezembro\",\n  ] as const,\n});\n\nconst getDayValues = () => ({\n  narrow: [\"D\", \"S\", \"T\", \"Q\", \"Q\", \"S\", \"S\"] as const,\n  short: [\"dom\", \"seg\", \"ter\", \"qua\", \"qui\", \"sex\", \"sab\"] as const,\n  abbreviated: [\n    \"domingo\",\n    \"segunda\",\n    \"terça\",\n    \"quarta\",\n    \"quinta\",\n    \"sexta\",\n    \"sábado\",\n  ] as const,\n  wide: [\n    \"domingo\",\n    \"segunda-feira\",\n    \"terça-feira\",\n    \"quarta-feira\",\n    \"quinta-feira\",\n    \"sexta-feira\",\n    \"sábado\",\n  ] as const,\n});\n\nconst getDayPeriodValues = () => ({\n  narrow: {\n    am: \"a\",\n    pm: \"p\",\n    midnight: \"mn\",\n    noon: \"md\",\n    morning: \"manhã\",\n    afternoon: \"tarde\",\n    evening: \"tarde\",\n    night: \"noite\",\n  },\n  abbreviated: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"meia-noite\",\n    noon: \"meio-dia\",\n    morning: \"manhã\",\n    afternoon: \"tarde\",\n    evening: \"tarde\",\n    night: \"noite\",\n  },\n  wide: {\n    am: \"a.m.\",\n    pm: \"p.m.\",\n    midnight: \"meia-noite\",\n    noon: \"meio-dia\",\n    morning: \"manhã\",\n    afternoon: \"tarde\",\n    evening: \"tarde\",\n    night: \"noite\",\n  },\n});\n\nconst getFormattingDayPeriodValues = () => ({\n  narrow: {\n    am: \"a\",\n    pm: \"p\",\n    midnight: \"mn\",\n    noon: \"md\",\n    morning: \"da manhã\",\n    afternoon: \"da tarde\",\n    evening: \"da tarde\",\n    night: \"da noite\",\n  },\n  abbreviated: {\n    am: \"AM\",\n    pm: \"PM\",\n    midnight: \"meia-noite\",\n    noon: \"meio-dia\",\n    morning: \"da manhã\",\n    afternoon: \"da tarde\",\n    evening: \"da tarde\",\n    night: \"da noite\",\n  },\n  wide: {\n    am: \"a.m.\",\n    pm: \"p.m.\",\n    midnight: \"meia-noite\",\n    noon: \"meio-dia\",\n    morning: \"da manhã\",\n    afternoon: \"da tarde\",\n    evening: \"da tarde\",\n    night: \"da noite\",\n  },\n});\n\nexport const localize: Localize = {\n  ordinalNumber,\n\n  era: buildLocalize"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\nimport { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\n\n// Ref: https://www.unicode.org/cldr/charts/32/summary/ta.html\n\nconst eraValues = {\n  narrow: [\"கி.மு.\", \"கி.பி.\"] as const,\n  abbreviated: [\"கி.மு.\", \"கி.பி.\"] as const, // CLDR #1624, #1626\n  wide: [\"கிறிஸ்துவுக்கு முன்\", \"அன்னோ டோமினி\"] as const, // CLDR #1620, #1622\n};\n\nconst quarterValues = {\n  // CLDR #1644 - #1647\n  narrow: [\"1\", \"2\", \"3\", \"4\"] as const,\n  // CLDR #1636 - #1639\n  abbreviated: [\"காலா.1\", \"காலா.2\", \"காலா.3\", \"காலா.4\"] as const,\n  // CLDR #1628 - #1631\n  wide: [\n    \"ஒன்றாம் காலாண்டு\",\n    \"இரண்டாம் காலாண்டு\",\n    \"மூன்றாம் காலாண்டு\",\n    \"நான்காம் காலாண்டு\",\n  ] as const,\n};\n\nconst monthValues = {\n  // CLDR #700 - #711\n  narrow: [\n    \"ஜ\",\n    \"பி\",\n    \"மா\",\n    \"ஏ\",\n    \"மே\",\n    \"ஜூ\",\n    \"ஜூ\",\n    \"ஆ\",\n    \"செ\",\n    \"அ\",\n    \"ந\",\n    \"டி\",\n  ] as const,\n  // CLDR #1676 - #1687\n  abbreviated: [\n    \"ஜன.\",\n    \"பிப்.\",\n    \"மார்.\",\n    \"ஏப்.\",\n    \"மே\",\n    \"ஜூன்\",\n    \"ஜூலை\",\n    \"ஆக.\",\n    \"செப்.\",\n    \"அக்.\",\n    \"நவ.\",\n    \"டிச.\",\n  ] as const,\n  // CLDR #1652 - #1663\n  wide: [\n    \"ஜனவரி\", // January\n    \"பிப்ரவரி\", // February\n    \"மார்ச்\", // March\n    \"ஏப்ரல்\", // April\n    \"மே\", // May\n    \"ஜூன்\", // June\n    \"ஜூலை\", // July\n    \"ஆகஸ்ட்\", // August\n    \"செப்டம்பர்\", // September\n    \"அக்டோபர்\", // October\n    \"நவம்பர்\", // November\n    \"டிசம்பர்\", // December\n  ] as const,\n};\n\nconst dayValues = {\n  // CLDR #1766 - #1772\n  narrow: [\"ஞா\", \"தி\", \"செ\", \"பு\", \"வி\", \"வெ\", \"ச\"] as const,\n  // CLDR #1752 - #1758\n  short: [\"ஞா\", \"தி\", \"செ\", \"பு\", \"வி\", \"வெ\", \"ச\"] as const,\n  // CLDR #1738 - #1744\n  abbreviated: [\n    \"ஞாயி.\",\n    \"திங்.\",\n    \"செவ்.\",\n    \"புத.\",\n    \"வியா.\",\n    \"வெள்.\",\n    \"சனி\",\n  ] as const,\n  // CLDR #1724 - #1730\n  wide: [\n    \"ஞாயிறு\", // Sunday\n    \"திங்கள்\", // Monday\n    \"செவ்வாய்\", // Tuesday\n    \"புதன்\", // Wednesday\n    \"வியாழன்\", // Thursday\n    \"வெள்ளி\", // Friday\n    \"சனி\", // Saturday\n  ] as const,\n};\n\n// CLDR #1780 - #1845\nconst dayPeriodValues = {\n  narrow: {\n    am: \"மு.ப\",\n    pm: \"பி.ப\",\n    midnight: \"நள்.\",\n    noon: \"நண்.\",\n    morning: \"கா.\",\n    afternoon: \"மதி.\",\n    evening: \"மா.\",\n    night: \"இர.\",\n  },\n  abbreviated: {\n    am: \"முற்பகல்\",\n    pm: \"பிற்பகல்\",\n    midnight: \"நள்ளிரவு\",\n    noon: \"நண்பகல்\",\n    morning: \"காலை\",\n    afternoon: \"மதியம்\",\n    evening: \"மாலை\",\n    night: \"இரவு\",\n  },\n  wide: {\n    am: \"முற்பகல்\",\n    pm: \"பிற்பகல்\",\n    midnight: \"நள்ளிரவு\",\n    noon: \"நண்பகல்\",\n    morning: \"காலை\",\n    afternoon: \"மதியம்\",\n    evening: \"மாலை\",\n    night: \"இரவு\",\n  },\n};\n\n// CLDR #1780 - #1845\nconst formattingDayPeriodValues = {\n  narrow: {\n    am: \"மு.ப\",\n    pm: \"பி.ப\",\n    midnight: \"நள்.\",\n    noon: \"நண்.\",\n    morning: \"கா.\",\n    afternoon: \"மதி.\",\n    evening: \"மா.\",\n    night: \"இர.\",\n  },\n  abbreviated: {\n    am: \"முற்பகல்\",\n    pm: \"பிற்பகல்\",\n    midnight: \"நள்ளிரவு\",\n    noon: \"நண்பகல்\",\n    morning: \"காலை\",\n    afternoon: \"மதியம்\",\n    evening: \"மாலை\",\n    night: \"இரவு\",\n  },\n  wide: {\n    am: \"முற்பகல்\",\n    pm: \"பிற்பகல்\",\n    midnight: \"நள்ளிரவு\",\n    noon: \"நண்பகல்\",\n    morning: \"காலை\",\n    afternoon: \"மதியம்\",\n    evening: \"மாலை\",\n    night: \"இரவு\",\n  },\n};\n\nconst ordinalNumber: LocalizeFn<number> = (dirtyNumber, _options) => {\n  return String(dirtyNumber);\n};\n\nexport const localize: Localize = {\n  ordinalNumber,\n\n  era: buildLocalizeFn({\n    values: eraValues,\n    defaultWidth: \"wide\",\n  }),\n\n  quarter: buildLocalizeFn({\n    values: quarterValues,\n    defaultWidth: \"wide\",\n    argumentCallback: (quarter) => quarter - 1,\n  }),\n\n  month: buildLocalizeFn({\n    values: monthValues,\n    defaultWidth: \"wide\",\n  }),\n\n  day: buildLocalizeFn({\n    values: dayValues,\n    defaultWidth: \"wide\",\n  }),\n\n  dayPeriod: buildLocalizeFn({\n    values: dayPeriodValues,\n    defaultWidth: \"wide\",\n    formattingValues: formattingDayPeriodValues,\n    defaultFormattingWidth: \"wide\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "```jsx\nimport type { Localize, LocalizeFn } from \"../../../types.js\";\nimport { buildLocalizeFn } from \"../../../_lib/buildLocalizeFn/index.js\";\n\nconst eraValues = {\n  narrow: [\"கி.மு.\", \"கி.பி.\"] as const,\n  abbreviated: [\"கி.மு.\", \"கி.பி.\"] as const,\n  wide: [\"கிறிஸ்துவுக்கு முன்\", \"அன்னோ டோமினி\"] as const,\n};\n\nconst quarterValues = {\n  narrow: [\"1\", \"2\", \"3\", \"4\"] as const,\n  abbreviated: [\"காலா.1\", \"காலா.2\", \"காலா.3\", \"காலா.4\"] as const,\n  wide: [\n    \"ஒன்றாம் காலாண்டு\",\n    \"இரண்டாம் காலாண்டு\",\n    \"மூன்றாம் காலாண்டு\",\n    \"நான்காம் காலாண்டு\",\n  ] as const,\n};\n\nconst monthValues = {\n  narrow: [\"ஜ\", \"பி\", \"மா\", \"ஏ\", \"மே\", \"ஜூ\", \"ஜூ\", \"ஆ\", \"செ\", \"அ\", \"ந\", \"டி\"] as const,\n  abbreviated: [\"ஜன.\", \"பிப்.\", \"மார்.\", \"ஏப்.\", \"மே\", \"ஜூன்\", \"ஜூலை\", \"ஆக.\", \"செப்.\", \"அக்.\", \"நவ.\", \"டிச.\"] as const,\n  wide: [\"ஜனவரி\", \"பிப்ரவரி\", \"மார்ச்\", \"ஏப்ரல்\", \"மே\", \"ஜூன்\", \"ஜூலை\", \"ஆகஸ்ட்\", \"செப்டம்பர்\", \"அக்டோபர்\", \"நவம்பர்\", \"டிசம்பர்\"] as const,\n};\n\nconst dayValues = {\n  narrow: [\"ஞா\", \"தி\", \"செ\", \"பு\", \"வி\", \"வெ\", \"ச\"] as const,\n  short: [\"ஞா\", \"தி\", \"செ\", \"பு\", \"வி\", \"வெ\", \"ச\"] as const,\n  abbreviated: [\"ஞாயி.\", \"திங்.\", \"செவ்.\", \"புத.\", \"வியா.\", \"வெள்.\", \"சனி\"] as const,\n  wide: [\"ஞாயிறு\", \"திங்கள்\", \"செவ்வாய்\", \"புதன்\", \"வியாழன்\", \"வெள்ளி\", \"சனி\"] as const,\n};\n\nconst dayPeriodValues = {\n  narrow: {\n    am: \"மு.ப\",\n    pm: \"பி.ப\",\n    midnight: \"நள்.\",\n    noon: \"நண்.\",\n    morning: \"கா.\",\n    afternoon: \"மதி.\",\n    evening: \"மா.\",\n    night: \"இர.\",\n  },\n  abbreviated: {\n    am: \"முற்பக"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Quarter } from \"../../../../types.js\";\nimport type { Match } from \"../../../types.js\";\nimport { buildMatchFn } from \"../../../_lib/buildMatchFn/index.js\";\nimport { buildMatchPatternFn } from \"../../../_lib/buildMatchPatternFn/index.js\";\n\nconst matchOrdinalNumberPattern = /^(第\\s*)?\\d+(日|時|分|秒)?/i;\nconst parseOrdinalNumberPattern = /\\d+/i;\n\nconst matchEraPatterns = {\n  narrow: /^(前)/i,\n  abbreviated: /^(前)/i,\n  wide: /^(公元前|公元)/i,\n};\nconst parseEraPatterns = {\n  any: [/^(前)/i, /^(公元)/i] as const,\n};\n\nconst matchQuarterPatterns = {\n  narrow: /^[1234]/i,\n  abbreviated: /^第[一二三四]季/i,\n  wide: /^第[一二三四]季度/i,\n};\nconst parseQuarterPatterns = {\n  any: [/(1|一)/i, /(2|二)/i, /(3|三)/i, /(4|四)/i] as const,\n};\n\nconst matchMonthPatterns = {\n  narrow: /^(一|二|三|四|五|六|七|八|九|十[二一])/i,\n  abbreviated: /^(一|二|三|四|五|六|七|八|九|十[二一]|\\d|1[12])月/i,\n  wide: /^(一|二|三|四|五|六|七|八|九|十[二一])月/i,\n};\nconst parseMonthPatterns = {\n  narrow: [\n    /^一/i,\n    /^二/i,\n    /^三/i,\n    /^四/i,\n    /^五/i,\n    /^六/i,\n    /^七/i,\n    /^八/i,\n    /^九/i,\n    /^十(?!(一|二))/i,\n    /^十一/i,\n    /^十二/i,\n  ] as const,\n  any: [\n    /^一|1/i,\n    /^二|2/i,\n    /^三|3/i,\n    /^四|4/i,\n    /^五|5/i,\n    /^六|6/i,\n    /^七|7/i,\n    /^八|8/i,\n    /^九|9/i,\n    /^十(?!(一|二))|10/i,\n    /^十一|11/i,\n    /^十二|12/i,\n  ] as const,\n};\n\nconst matchDayPatterns = {\n  narrow: /^[一二三四五六日]/i,\n  short: /^[一二三四五六日]/i,\n  abbreviated: /^週[一二三四五六日]/i,\n  wide: /^星期[一二三四五六日]/i,\n};\nconst parseDayPatterns = {\n  any: [/日/i, /一/i, /二/i, /三/i, /四/i, /五/i, /六/i] as const,\n};\n\nconst matchDayPeriodPatterns = {\n  any: /^(上午?|下午?|午夜|[中正]午|早上?|下午|晚上?|凌晨)/i,\n};\nconst parseDayPeriodPatterns = {\n  any: {\n    am: /^上午?/i,\n    pm: /^下午?/i,\n    midnight: /^午夜/i,\n    noon: /^[中正]午/i,\n    morning: /^早上/i,\n    afternoon: /^下午/i,\n    evening: /^晚上?/i,\n    night: /^凌晨/i,\n  },\n};\n\nexport const match: Match = {\n  ordinalNumber: buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: (value) => parseInt(value, 10),\n  }),\n\n  era: buildMatchFn({\n    matchPatterns: matchEraPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseEraPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  quarter: buildMatchFn({\n    matchPatterns: matchQuarterPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseQuarterPatterns,\n    defaultParseWidth: \"any\",\n    valueCallback: (index) => (index + 1) as Quarter,\n  }),\n\n  month: buildMatchFn({\n    matchPatterns: matchMonthPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseMonthPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  day: buildMatchFn({\n    matchPatterns: matchDayPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseDayPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  dayPeriod: buildMatchFn({\n    matchPatterns: matchDayPeriodPatterns,\n    defaultMatchWidth: \"any\",\n    parsePatterns: parseDayPeriodPatterns,\n    defaultParseWidth: \"any\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "```javascript\nconst buildOrdinalNumberMatch = () => {\n  return buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: (value) => parseInt(value, 10),\n  });\n};\n\nconst buildEraMatch = () => {\n  return buildMatchFn({\n    matchPatterns: matchEraPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseEraPatterns,\n    defaultParseWidth: \"any\",\n  });\n};\n\nconst buildQuarterMatch = () => {\n  return buildMatchFn({\n    matchPatterns: matchQuarterPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseQuarterPatterns,\n    defaultParseWidth: \"any\",\n    valueCallback: (index) => (index + 1) as Quarter,\n  });\n};\n\nconst buildMonthMatch = () => {\n  return buildMatchFn({\n    matchPatterns: matchMonthPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseMonthPatterns,\n    defaultParseWidth: \"any\",\n  });\n};\n\nconst buildDayMatch = () => {\n  return buildMatchFn({\n    matchPatterns: matchDayPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseDayPatterns,\n    defaultParseWidth: \"any\",\n  });\n};\n\nconst buildDayPeriodMatch = () => {\n  return buildMatchFn({\n    matchPatterns: matchDayPeriodPatterns,\n    defaultMatchWidth: \"any\",\n    parsePatterns: parseDayPeriodPatterns,\n    defaultParseWidth: \"any\",\n  });\n};\n\nexport const match: Match = {\n  ordinalNumber: buildOrdinalNumberMatch(),\n  era: buildEraMatch(),\n  quarter: buildQuarterMatch(),\n  month: buildMonthMatch(),\n  day: buildDayMatch(),\n  dayPeriod: buildDayPeriodMatch(),\n};\n```"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype FormatDistanceTokenValue =\n  | string\n  | {\n      one: string;\n      two: string;\n      threeToTen: string;\n      other: string;\n    };\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: \"أقل من ثانية\",\n    two: \"أقل من ثانيتين\",\n    threeToTen: \"أقل من {{count}} ثواني\",\n    other: \"أقل من {{count}} ثانية\",\n  },\n\n  xSeconds: {\n    one: \"ثانية\",\n    two: \"ثانيتين\",\n    threeToTen: \"{{count}} ثواني\",\n    other: \"{{count}} ثانية\",\n  },\n\n  halfAMinute: \"نص دقيقة\",\n\n  lessThanXMinutes: {\n    one: \"أقل من دقيقة\",\n    two: \"أقل من دقيقتين\",\n    threeToTen: \"أقل من {{count}} دقايق\",\n    other: \"أقل من {{count}} دقيقة\",\n  },\n\n  xMinutes: {\n    one: \"دقيقة\",\n    two: \"دقيقتين\",\n    threeToTen: \"{{count}} دقايق\",\n    other: \"{{count}} دقيقة\",\n  },\n\n  aboutXHours: {\n    one: \"حوالي ساعة\",\n    two: \"حوالي ساعتين\",\n    threeToTen: \"حوالي {{count}} ساعات\",\n    other: \"حوالي {{count}} ساعة\",\n  },\n\n  xHours: {\n    one: \"ساعة\",\n    two: \"ساعتين\",\n    threeToTen: \"{{count}} ساعات\",\n    other: \"{{count}} ساعة\",\n  },\n\n  xDays: {\n    one: \"يوم\",\n    two: \"يومين\",\n    threeToTen: \"{{count}} أيام\",\n    other: \"{{count}} يوم\",\n  },\n\n  aboutXWeeks: {\n    one: \"حوالي أسبوع\",\n    two: \"حوالي أسبوعين\",\n    threeToTen: \"حوالي {{count}} أسابيع\",\n    other: \"حوالي {{count}} أسبوع\",\n  },\n\n  xWeeks: {\n    one: \"أسبوع\",\n    two: \"أسبوعين\",\n    threeToTen: \"{{count}} أسابيع\",\n    other: \"{{count}} أسبوع\",\n  },\n\n  aboutXMonths: {\n    one: \"حوالي شهر\",\n    two: \"حوالي شهرين\",\n    threeToTen: \"حوالي {{count}} أشهر\",\n    other: \"حوالي {{count}} شهر\",\n  },\n\n  xMonths: {\n    one: \"شهر\",\n    two: \"شهرين\",\n    threeToTen: \"{{count}} أشهر\",\n    other: \"{{count}} شهر\",\n  },\n\n  aboutXYears: {\n    one: \"حوالي سنة\",\n    two: \"حوالي سنتين\",\n    threeToTen: \"حوالي {{count}} سنين\",\n    other: \"حوالي {{count}} سنة\",\n  },\n\n  xYears: {\n    one: \"عام\",\n    two: \"عامين\",\n    threeToTen: \"{{count}} أعوام\",\n    other: \"{{count}} عام\",\n  },\n\n  overXYears: {\n    one: \"أكثر من سنة\",\n    two: \"أكثر من سنتين\",\n    threeToTen: \"أكثر من {{count}} سنين\",\n    other: \"أكثر من {{count}} سنة\",\n  },\n\n  almostXYears: {\n    one: \"عام تقريبًا\",\n    two: \"عامين تقريبًا\",\n    threeToTen: \"{{count}} أعوام تقريبًا\",\n    other: \"{{count}} عام تقريبًا\",\n  },\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  let result;\n\n  const tokenValue = formatDistanceLocale[token];\n  if (typeof tokenValue === \"string\") {\n    result = tokenValue;\n  } else if (count === 1) {\n    result = tokenValue.one;\n  } else if (count === 2) {\n    result = tokenValue.two;\n  } else if (count <= 10) {\n    result = tokenValue.threeToTen.replace(\"{{count}}\", String(count));\n  } else {\n    result = tokenValue.other.replace(\"{{count}}\", String(count));\n  }\n\n  if (options?.addSuffix) {\n    if (options.comparison && options.comparison > 0) {\n      return `في خلال ${result}`;\n    } else {\n      return `منذ ${result}`;\n    }\n  }\n\n  return result;\n};\n"
      },
      {
        "role": "assistant",
        "content": " come to the rescue of the real-life couple in the movie. The following story is about a couple who set out on a road trip in, only to be hunted down by a group of strangers who turn out to be blood-thirsty. The couple manages to escape their pursuers, but a confrontation with a gang of bikers leads to them being separated and they are both forced to take on a different set of threats. \nThe couple's ordeal leads them to the discovery that the group of strangers are actually a cult of devil worshipers who want to impregnate the female to bring forth their dark lord. \nThe movie ends with the couple defeating the cult and escaping to safety.\nAfter the success of the first movie, the couple starred in the sequel which was released in 2020. This time they are being pursued by a different group of cultists who want to use their baby to bring forth a new age of darkness. \nAt the end of the movie, the couple are able to escape to safety. They take down the cultists and continue on their journey. \nThis makes me think about the history of the island, the mysteries of the island, and how the couple is going to get out of the mess that they are in. \nIt also makes me think about the first movie in the series, which I'll need to go back and watch again to refresh my memory on the story.\n\nTo be honest, I never noticed the changes in the game industry, because I don't play video games anymore. But I’ve been hearing things about how video games are changing and getting more complex. I know that it takes a lot of computing power to run games now and that the graphics have advanced a lot. I think there are a lot of games that are very realistic just like movies. I must admit, it’s very impressive. I also know that there are many people who are into video games as a pastime. I can see that the games are quite complicated to play now, and I think that it is neat that people have this type of entertainment available to them. I think people who are into video games are happy when they can play the games they like, and I am happy for them. And the fact that the graphics are so great is really cool. \nI’m not very good at video games, but I do think that they are a great way to kick back and relax. It’s a great way to escape from reality for a little while and immerse oneself in a completely different world. I also think that the graphics and the gameplay have come a long way over the years. I’m really excited to see where video games go in the future and how they continue to evolve. \nWhat do you think of video games? Do you play them often? \nHave you played any games recently that you really enjoyed? Are there any games coming out soon that you’re looking forward to playing? \nI’d love to hear your thoughts on this! Have a great day! \nSincerely, \nThe Happy Gamer\n\nThis is just a reminder that you can now play our game, “Fruit Ninja” on your Kindle. We hope you enjoy playing this fun game on your Kindle! \nWe would like to know your feedback on how we can improve our game. \nThank you for your time, and have a great day. \nBest Regards, \nThe Fruit Ninja Team\n\nDear Customer, \nWe are pleased to inform you that we have added a new feature to our game “Fruit Ninja.” \nYou can now play online with your friends and family. \nWe hope you enjoy this new feature and have a great time playing with your loved ones. \nWe appreciate your support. \nThe Fruit Ninja Team\n\nTo celebrate the release of “Fruit Ninja 2,” we are offering you the chance to win a free in-game item! \nSimply log in and play between the following dates for your chance to win! \nWe look forward to seeing you in-game soon. \nTerms and conditions apply.\n\nNote: this may not apply to everyone, especially if you’re not in the United States.\n\nSincerely, \nThe Fruit Ninja Team\n\nClick here to go to our download page and learn more!\n\nTo: All Recipients\n\nSubject: Win a Free In-Game Item for Fruit Ninja 2!\n\nAttachment: New Game Feature\n\nDear Valued Players,\n\nWe hope you are enjoying Fruit Ninja 2. We’re excited to announce a new feature that makes it easier to play with your friends and track your progress. This is just the beginning of a series of improvements to the game.\n\nThe next time you want to play, you’ll need to use the following link to sign in:\n\nplay.fruitninja.com\n\nThis is the only way to play the game. It’s the same as the old one, but with some added features.\n\nSincerely,\n\nThe Management\n\nIn the end, we are the ones who"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\n/**\n * Davant de les xifres que es diuen amb vocal inicial, 1 i 11, s'apostrofen els articles el i la i la preposició de igual que si estiguessin escrits amb lletres.\n *    l'1 de juliol ('l'u')\n *    l'11 de novembre ('l'onze')\n *    l'11a clàusula del contracte ('l'onzena')\n *    la contractació d'11 jugadors ('d'onze')\n *    l'aval d'11.000 socis ('d'onze mil')\n *\n * Reference: https://aplicacions.llengua.gencat.cat/llc/AppJava/index.html?input_cercar=apostrofaci%25F3+davant+xifres&action=Principal&method=detall_completa&numPagina=1&idHit=11236&database=FITXES_PUB&tipusFont=Fitxes%20de%20l%27Optimot&idFont=11236&titol=apostrofaci%F3%20davant%20de%20xifres%20%2F%20apostrofaci%F3%20davant%20de%201%20i%2011&numeroResultat=1&clickLink=detall&tipusCerca=cerca.normes\n */\n\ntype FormatDistanceTokenValue =\n  | string\n  | {\n      one: string;\n      eleven?: string;\n      other: string;\n    };\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: \"menys d'un segon\",\n    eleven: \"menys d'onze segons\",\n    other: \"menys de {{count}} segons\",\n  },\n\n  xSeconds: {\n    one: \"1 segon\",\n    other: \"{{count}} segons\",\n  },\n\n  halfAMinute: \"mig minut\",\n\n  lessThanXMinutes: {\n    one: \"menys d'un minut\",\n    eleven: \"menys d'onze minuts\",\n    other: \"menys de {{count}} minuts\",\n  },\n\n  xMinutes: {\n    one: \"1 minut\",\n    other: \"{{count}} minuts\",\n  },\n\n  aboutXHours: {\n    one: \"aproximadament una hora\",\n    other: \"aproximadament {{count}} hores\",\n  },\n\n  xHours: {\n    one: \"1 hora\",\n    other: \"{{count}} hores\",\n  },\n\n  xDays: {\n    one: \"1 dia\",\n    other: \"{{count}} dies\",\n  },\n\n  aboutXWeeks: {\n    one: \"aproximadament una setmana\",\n    other: \"aproximadament {{count}} setmanes\",\n  },\n\n  xWeeks: {\n    one: \"1 setmana\",\n    other: \"{{count}} setmanes\",\n  },\n\n  aboutXMonths: {\n    one: \"aproximadament un mes\",\n    other: \"aproximadament {{count}} mesos\",\n  },\n\n  xMonths: {\n    one: \"1 mes\",\n    other: \"{{count}} mesos\",\n  },\n\n  aboutXYears: {\n    one: \"aproximadament un any\",\n    other: \"aproximadament {{count}} anys\",\n  },\n\n  xYears: {\n    one: \"1 any\",\n    other: \"{{count}} anys\",\n  },\n\n  overXYears: {\n    one: \"més d'un any\",\n    eleven: \"més d'onze anys\",\n    other: \"més de {{count}} anys\",\n  },\n\n  almostXYears: {\n    one: \"gairebé un any\",\n    other: \"gairebé {{count}} anys\",\n  },\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  let result;\n\n  const tokenValue = formatDistanceLocale[token];\n  if (typeof tokenValue === \"string\") {\n    result = tokenValue;\n  } else if (count === 1) {\n    result = tokenValue.one;\n  } else if (count === 11 && tokenValue.eleven) {\n    result = tokenValue.eleven;\n  } else {\n    result = tokenValue.other.replace(\"{{count}}\", String(count));\n  }\n\n  if (options?.addSuffix) {\n    if (options.comparison && options.comparison > 0) {\n      return \"en \" + result;\n    } else {\n      return \"fa \" + result;\n    }\n  }\n\n  return result;\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype FormatDistanceTokenValue =\n  | string\n  | {\n      one: string;\n      eleven?: string;\n      other: string;\n    };\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: \"menys d'un segon\",\n    eleven: \"menys d'onze segons\",\n    other: \"menys de {{count}} segons\",\n  },\n\n  xSeconds: {\n    one: \"1 segon\",\n    other: \"{{count}} segons\",\n  },\n\n  halfAMinute: \"mig minut\",\n\n  lessThanXMinutes: {\n    one: \"menys d'un minut\",\n    eleven: \"menys d'onze minuts\",\n    other: \"menys de {{count}} minuts\",\n  },\n\n  xMinutes: {\n    one: \"1 minut\",\n    other: \"{{count}} minuts\",\n  },\n\n  aboutXHours: {\n    one: \"aproximadament una hora\",\n    other: \"aproximadament {{count}} hores\",\n  },\n\n  xHours: {\n    one: \"1 hora\",\n    other: \"{{count}} hores\",\n  },\n\n  xDays: {\n    one: \"1 dia\",\n    other: \"{{count}} dies\",\n  },\n\n  aboutXWeeks: {\n    one: \"aproximadament una setmana\",\n    other: \"aproximadament {{count}} setmanes\",\n  },\n\n  xWeeks: {\n    one: \"1 setmana\",\n    other: \"{{count}} setmanes\",\n  },\n\n  aboutXMonths: {\n    one: \"aproximadament un mes\",\n    other: \"aproximadament {{count}} mesos\",\n  },\n\n  xMonths: {\n    one: \"1 mes\",\n    other: \"{{count}} mesos\",\n  },\n\n  aboutXYears: {\n    one: \"aproximadament un any\",\n    other: \"aproximadament {{count}} anys\",\n  },\n\n  xYears: {\n    one: \"1 any\",\n    other: \"{{count}} anys\",\n  },\n\n  overXYears: {\n    one: \"més d'un any\",\n    eleven: \"més d'onze anys\",\n    other: \"més de {{count}} anys\",\n  },\n\n  almostXYears: {\n    one: \"gairebé un any\",\n    other: \"gairebé {{count}} anys\",\n  },\n};\n\nconst getResult = (token, count) => {\n  const tokenValue = formatDistanceLocale[token];\n  if (typeof tokenValue === \"string\") {\n    return tokenValue;\n  } else if (count === 1) {\n    return tokenValue.one;\n  } else if (count === 11 && tokenValue.eleven) {\n    return tokenValue.eleven;\n  } else {\n    return tokenValue.other.replace(\"{{count}}\", String(count));\n  }\n};\n\nconst addSuffix = (result, options) => {\n  if (options?.addSuffix) {\n    if (options.comparison && options.comparison > 0) {\n      return \"en \" + result;\n    } else {\n      return \"fa \" + result;\n    }\n  }\n  return result;\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  let result = getResult(token, count);\n  result = addSuffix(result, options);\n  return result;\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { buildMatchPatternFn } from \"../../../_lib/buildMatchPatternFn/index.js\";\nimport { buildMatchFn } from \"../../../_lib/buildMatchFn/index.js\";\nimport type { Quarter } from \"../../../../types.js\";\nimport type { Match } from \"../../../types.js\";\n\nconst matchOrdinalNumberPattern = /^(\\d+)(º)?/i;\nconst parseOrdinalNumberPattern = /\\d+/i;\n\nconst matchEraPatterns = {\n  narrow: /^(ac|dc|a|d)/i,\n  abbreviated: /^(a\\.?\\s?c\\.?|a\\.?\\s?e\\.?\\s?c\\.?|d\\.?\\s?c\\.?|e\\.?\\s?c\\.?)/i,\n  wide: /^(antes de cristo|antes de la era com[uú]n|despu[eé]s de cristo|era com[uú]n)/i,\n};\nconst parseEraPatterns = {\n  any: [/^ac/i, /^dc/i] as const,\n  wide: [\n    /^(antes de cristo|antes de la era com[uú]n)/i,\n    /^(despu[eé]s de cristo|era com[uú]n)/i,\n  ] as const,\n};\n\nconst matchQuarterPatterns = {\n  narrow: /^[1234]/i,\n  abbreviated: /^T[1234]/i,\n  wide: /^[1234](º)? trimestre/i,\n};\nconst parseQuarterPatterns = {\n  any: [/1/i, /2/i, /3/i, /4/i] as const,\n};\n\nconst matchMonthPatterns = {\n  narrow: /^[efmajsond]/i,\n  abbreviated: /^(ene|feb|mar|abr|may|jun|jul|ago|sep|oct|nov|dic)/i,\n  wide: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,\n};\nconst parseMonthPatterns = {\n  narrow: [\n    /^e/i,\n    /^f/i,\n    /^m/i,\n    /^a/i,\n    /^m/i,\n    /^j/i,\n    /^j/i,\n    /^a/i,\n    /^s/i,\n    /^o/i,\n    /^n/i,\n    /^d/i,\n  ] as const,\n  any: [\n    /^en/i,\n    /^feb/i,\n    /^mar/i,\n    /^abr/i,\n    /^may/i,\n    /^jun/i,\n    /^jul/i,\n    /^ago/i,\n    /^sep/i,\n    /^oct/i,\n    /^nov/i,\n    /^dic/i,\n  ] as const,\n};\n\nconst matchDayPatterns = {\n  narrow: /^[dlmjvs]/i,\n  short: /^(do|lu|ma|mi|ju|vi|s[áa])/i,\n  abbreviated: /^(dom|lun|mar|mi[ée]|jue|vie|s[áa]b)/i,\n  wide: /^(domingo|lunes|martes|mi[ée]rcoles|jueves|viernes|s[áa]bado)/i,\n};\nconst parseDayPatterns = {\n  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i] as const,\n  any: [/^do/i, /^lu/i, /^ma/i, /^mi/i, /^ju/i, /^vi/i, /^sa/i] as const,\n};\n\nconst matchDayPeriodPatterns = {\n  narrow: /^(a|p|mn|md|(de la|a las) (mañana|tarde|noche))/i,\n  any: /^([ap]\\.?\\s?m\\.?|medianoche|mediodia|(de la|a las) (mañana|tarde|noche))/i,\n};\nconst parseDayPeriodPatterns = {\n  any: {\n    am: /^a/i,\n    pm: /^p/i,\n    midnight: /^mn/i,\n    noon: /^md/i,\n    morning: /mañana/i,\n    afternoon: /tarde/i,\n    evening: /tarde/i,\n    night: /noche/i,\n  },\n};\n\nexport const match: Match = {\n  ordinalNumber: buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: function (value) {\n      return parseInt(value, 10);\n    },\n  }),\n\n  era: buildMatchFn({\n    matchPatterns: matchEraPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseEraPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  quarter: buildMatchFn({\n    matchPatterns: matchQuarterPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseQuarterPatterns,\n    defaultParseWidth: \"any\",\n    valueCallback: (index) => (index + 1) as Quarter,\n  }),\n\n  month: buildMatchFn({\n    matchPatterns: matchMonthPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseMonthPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  day: buildMatchFn({\n    matchPatterns: matchDayPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseDayPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  dayPeriod: buildMatchFn({\n    matchPatterns: matchDayPeriodPatterns,\n    defaultMatchWidth: \"any\",\n    parsePatterns: parseDayPeriodPatterns,\n    defaultParseWidth: \"any\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "const buildOrdinalNumberMatch = () => {\n  return buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: function (value) {\n      return parseInt(value, 10);\n    },\n  });\n};\n\nconst buildEraMatch = () => {\n  return buildMatchFn({\n    matchPatterns: matchEraPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseEraPatterns,\n    defaultParseWidth: \"any\",\n  });\n};\n\nconst buildQuarterMatch = () => {\n  return buildMatchFn({\n    matchPatterns: matchQuarterPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseQuarterPatterns,\n    defaultParseWidth: \"any\",\n    valueCallback: (index) => (index + 1) as Quarter,\n  });\n};\n\nconst buildMonthMatch = () => {\n  return buildMatchFn({\n    matchPatterns: matchMonthPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseMonthPatterns,\n    defaultParseWidth: \"any\",\n  });\n};\n\nconst buildDayMatch = () => {\n  return buildMatchFn({\n    matchPatterns: matchDayPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseDayPatterns,\n    defaultParseWidth: \"any\",\n  });\n};\n\nconst buildDayPeriodMatch = () => {\n  return buildMatchFn({\n    matchPatterns: matchDayPeriodPatterns,\n    defaultMatchWidth: \"any\",\n    parsePatterns: parseDayPeriodPatterns,\n    defaultParseWidth: \"any\",\n  });\n};\n\nexport const match: Match = {\n  ordinalNumber: buildOrdinalNumberMatch(),\n  era: buildEraMatch(),\n  quarter: buildQuarterMatch(),\n  month: buildMonthMatch(),\n  day: buildDayMatch(),\n  dayPeriod: buildDayPeriodMatch(),\n};"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Quarter } from \"../../../../types.js\";\nimport type { Match } from \"../../../types.js\";\nimport { buildMatchFn } from \"../../../_lib/buildMatchFn/index.js\";\nimport { buildMatchPatternFn } from \"../../../_lib/buildMatchPatternFn/index.js\";\n\nconst matchOrdinalNumberPattern =\n  /^(\\d+|(ראשון|שני|שלישי|רביעי|חמישי|שישי|שביעי|שמיני|תשיעי|עשירי|ראשונה|שנייה|שלישית|רביעית|חמישית|שישית|שביעית|שמינית|תשיעית|עשירית))/i;\nconst parseOrdinalNumberPattern = /^(\\d+|רא|שנ|של|רב|ח|שי|שב|שמ|ת|ע)/i;\n\nconst matchEraPatterns = {\n  narrow: /^ל(ספירה|פנה״ס)/i,\n  abbreviated: /^ל(ספירה|פנה״ס)/i,\n  wide: /^ל(פני ה)?ספירה/i,\n};\nconst parseEraPatterns = {\n  any: [/^לפ/i, /^לס/i] as const,\n};\n\nconst matchQuarterPatterns = {\n  narrow: /^[1234]/i,\n  abbreviated: /^q[1234]/i,\n  wide: /^רבעון [1234]/i,\n};\nconst parseQuarterPatterns = {\n  any: [/1/i, /2/i, /3/i, /4/i] as const,\n};\n\nconst matchMonthPatterns = {\n  narrow: /^\\d+/i,\n  abbreviated: /^(ינו|פבר|מרץ|אפר|מאי|יוני|יולי|אוג|ספט|אוק|נוב|דצמ)׳?/i,\n  wide: /^(ינואר|פברואר|מרץ|אפריל|מאי|יוני|יולי|אוגוסט|ספטמבר|אוקטובר|נובמבר|דצמבר)/i,\n};\nconst parseMonthPatterns = {\n  narrow: [\n    /^1$/i,\n    /^2/i,\n    /^3/i,\n    /^4/i,\n    /^5/i,\n    /^6/i,\n    /^7/i,\n    /^8/i,\n    /^9/i,\n    /^10/i,\n    /^11/i,\n    /^12/i,\n  ] as const,\n  any: [\n    /^ינ/i,\n    /^פ/i,\n    /^מר/i,\n    /^אפ/i,\n    /^מא/i,\n    /^יונ/i,\n    /^יול/i,\n    /^אוג/i,\n    /^ס/i,\n    /^אוק/i,\n    /^נ/i,\n    /^ד/i,\n  ] as const,\n};\n\nconst matchDayPatterns = {\n  narrow: /^[אבגדהוש]׳/i,\n  short: /^[אבגדהוש]׳/i,\n  abbreviated: /^(שבת|יום (א|ב|ג|ד|ה|ו)׳)/i,\n  wide: /^יום (ראשון|שני|שלישי|רביעי|חמישי|שישי|שבת)/i,\n};\nconst parseDayPatterns = {\n  abbreviated: [/א׳$/i, /ב׳$/i, /ג׳$/i, /ד׳$/i, /ה׳$/i, /ו׳$/i, /^ש/i] as const,\n  wide: [/ן$/i, /ני$/i, /לישי$/i, /עי$/i, /מישי$/i, /שישי$/i, /ת$/i] as const,\n  any: [/^א/i, /^ב/i, /^ג/i, /^ד/i, /^ה/i, /^ו/i, /^ש/i] as const,\n};\n\nconst matchDayPeriodPatterns = {\n  any: /^(אחר ה|ב)?(חצות|צהריים|בוקר|ערב|לילה|אחה״צ|לפנה״צ)/i,\n};\nconst parseDayPeriodPatterns = {\n  any: {\n    am: /^לפ/i,\n    pm: /^אחה/i,\n    midnight: /^ח/i,\n    noon: /^צ/i,\n    morning: /בוקר/i,\n    afternoon: /בצ|אחר/i,\n    evening: /ערב/i,\n    night: /לילה/i,\n  },\n};\n\nconst ordinalName = [\"רא\", \"שנ\", \"של\", \"רב\", \"ח\", \"שי\", \"שב\", \"שמ\", \"ת\", \"ע\"];\n\nexport const match: Match = {\n  ordinalNumber: buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: (value) => {\n      const number = parseInt(value, 10);\n      return isNaN(number) ? ordinalName.indexOf(value) + 1 : number;\n    },\n  }),\n\n  era: buildMatchFn({\n    matchPatterns: matchEraPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseEraPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  quarter: buildMatchFn({\n    matchPatterns: matchQuarterPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseQuarterPatterns,\n    defaultParseWidth: \"any\",\n    valueCallback: (index) => (index + 1) as Quarter,\n  }),\n\n  month: buildMatchFn({\n    matchPatterns: matchMonthPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseMonthPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  day: buildMatchFn({\n    matchPatterns: matchDayPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseDayPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  dayPeriod: buildMatchFn({\n    matchPatterns: matchDayPeriodPatterns,\n    defaultMatchWidth: \"any\",\n    parsePatterns: parseDayPeriodPatterns,\n    defaultParseWidth: \"any\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "```js\n// Refactored code\n\n// Extracted method for matching ordinal number\nconst matchOrdinalNumber = buildMatchPatternFn({\n  matchPattern: matchOrdinalNumberPattern,\n  parsePattern: parseOrdinalNumberPattern,\n  valueCallback: (value) => {\n    const number = parseInt(value, 10);\n    return isNaN(number) ? ordinalName.indexOf(value) + 1 : number;\n  },\n});\n\n// Extracted method for matching era\nconst matchEra = buildMatchFn({\n  matchPatterns: matchEraPatterns,\n  defaultMatchWidth: \"wide\",\n  parsePatterns: parseEraPatterns,\n  defaultParseWidth: \"any\",\n});\n\n// Extracted method for matching quarter\nconst matchQuarter = buildMatchFn({\n  matchPatterns: matchQuarterPatterns,\n  defaultMatchWidth: \"wide\",\n  parsePatterns: parseQuarterPatterns,\n  defaultParseWidth: \"any\",\n  valueCallback: (index) => (index + 1) as Quarter,\n});\n\n// Extracted method for matching month\nconst matchMonth = buildMatchFn({\n  matchPatterns: matchMonthPatterns,\n  defaultMatchWidth: \"wide\",\n  parsePatterns: parseMonthPatterns,\n  defaultParseWidth: \"any\",\n});\n\n// Extracted method for matching day\nconst matchDay = buildMatchFn({\n  matchPatterns: matchDayPatterns,\n  defaultMatchWidth: \"wide\",\n  parsePatterns: parseDayPatterns,\n  defaultParseWidth: \"any\",\n});\n\n// Extracted method for matching day period\nconst matchDayPeriod = buildMatchFn({\n  matchPatterns: matchDayPeriodPatterns,\n  defaultMatchWidth: \"any\",\n  parsePatterns: parseDayPeriodPatterns,\n  defaultParseWidth: \"any\",\n});\n\n// Exporting all match methods\nexport const match: Match = {\n  ordinalNumber: matchOrdinalNumber,\n  era: matchEra,\n  quarter: matchQuarter,\n  month: matchMonth,\n  day: matchDay,\n  dayPeriod: matchDayPeriod,\n};\n```"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Quarter } from \"../../../../types.js\";\nimport type { Match } from \"../../../types.js\";\nimport { buildMatchFn } from \"../../../_lib/buildMatchFn/index.js\";\nimport { buildMatchPatternFn } from \"../../../_lib/buildMatchPatternFn/index.js\";\n\nconst matchOrdinalNumberPattern =\n  /^だ?い?\\d+(ねん|しはんき|がつ|しゅう|にち|じ|ふん|びょう)?/i;\nconst parseOrdinalNumberPattern = /\\d+/i;\n\nconst matchEraPatterns = {\n  narrow: /^(B\\.?C\\.?|A\\.?D\\.?)/i,\n  abbreviated: /^(きげん[前後]|せいれき)/i,\n  wide: /^(きげん[前後]|せいれき)/i,\n};\nconst parseEraPatterns = {\n  narrow: [/^B/i, /^A/i] as const,\n  any: [/^(きげんぜん)/i, /^(せいれき|きげんご)/i] as const,\n};\n\nconst matchQuarterPatterns = {\n  narrow: /^[1234]/i,\n  abbreviated: /^Q[1234]/i,\n  wide: /^だい[1234一二三四１２３４]しはんき/i,\n};\nconst parseQuarterPatterns = {\n  any: [/(1|一|１)/i, /(2|二|２)/i, /(3|三|３)/i, /(4|四|４)/i] as const,\n};\n\nconst matchMonthPatterns = {\n  narrow: /^([123456789]|1[012])/,\n  abbreviated: /^([123456789]|1[012])がつ/i,\n  wide: /^([123456789]|1[012])がつ/i,\n};\nconst parseMonthPatterns = {\n  any: [\n    /^1\\D/,\n    /^2/,\n    /^3/,\n    /^4/,\n    /^5/,\n    /^6/,\n    /^7/,\n    /^8/,\n    /^9/,\n    /^10/,\n    /^11/,\n    /^12/,\n  ] as const,\n};\n\nconst matchDayPatterns = {\n  narrow: /^(にち|げつ|か|すい|もく|きん|ど)/,\n  short: /^(にち|げつ|か|すい|もく|きん|ど)/,\n  abbreviated: /^(にち|げつ|か|すい|もく|きん|ど)/,\n  wide: /^(にち|げつ|か|すい|もく|きん|ど)ようび/,\n};\nconst parseDayPatterns = {\n  any: [/^にち/, /^げつ/, /^か/, /^すい/, /^もく/, /^きん/, /^ど/] as const,\n};\n\nconst matchDayPeriodPatterns = {\n  any: /^(AM|PM|ごぜん|ごご|しょうご|しんや|まよなか|よる|あさ)/i,\n};\nconst parseDayPeriodPatterns = {\n  any: {\n    am: /^(A|ごぜん)/i,\n    pm: /^(P|ごご)/i,\n    midnight: /^しんや|まよなか/i,\n    noon: /^しょうご/i,\n    morning: /^あさ/i,\n    afternoon: /^ごご/i,\n    evening: /^よる/i,\n    night: /^しんや/i,\n  },\n};\n\nexport const match: Match = {\n  ordinalNumber: buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: function (value) {\n      return parseInt(value, 10);\n    },\n  }),\n\n  era: buildMatchFn({\n    matchPatterns: matchEraPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseEraPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  quarter: buildMatchFn({\n    matchPatterns: matchQuarterPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseQuarterPatterns,\n    defaultParseWidth: \"any\",\n    valueCallback: (index) => (index + 1) as Quarter,\n  }),\n\n  month: buildMatchFn({\n    matchPatterns: matchMonthPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseMonthPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  day: buildMatchFn({\n    matchPatterns: matchDayPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseDayPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  dayPeriod: buildMatchFn({\n    matchPatterns: matchDayPeriodPatterns,\n    defaultMatchWidth: \"any\",\n    parsePatterns: parseDayPeriodPatterns,\n    defaultParseWidth: \"any\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "import { buildMatchFn } from \"../../../_lib/buildMatchFn/index.js\";\nimport { buildMatchPatternFn } from \"../../../_lib/buildMatchPatternFn/index.js\";\n\nconst matchOrdinalNumberPattern =\n  /^だ?い?\\d+(ねん|しはんき|がつ|しゅう|にち|じ|ふん|びょう)?/i;\nconst parseOrdinalNumberPattern = /\\d+/i;\n\nconst matchEraPatterns = {\n  narrow: /^(B\\.?C\\.?|A\\.?D\\.?)/i,\n  abbreviated: /^(きげん[前後]|せいれき)/i,\n  wide: /^(きげん[前後]|せいれき)/i,\n};\nconst parseEraPatterns = {\n  narrow: [/^B/i, /^A/i] as const,\n  any: [/^(きげんぜん)/i, /^(せいれき|きげんご)/i] as const,\n};\n\nconst matchQuarterPatterns = {\n  narrow: /^[1234]/i,\n  abbreviated: /^Q[1234]/i,\n  wide: /^だい[1234一二三四１２３４]しはんき/i,\n};\nconst parseQuarterPatterns = {\n  any: [/(1|一|１)/i, /(2|二|２)/i, /(3|三|３)/i, /(4|四|４)/i] as const,\n};\n\nconst matchMonthPatterns = {\n  narrow: /^([123456789]|1[012])/,\n  abbreviated: /^([123456789]|1[012])がつ/i,\n  wide: /^([123456789]|1[012])がつ/i,\n};\nconst parseMonthPatterns = {\n  any: [\n    /^1\\D/,\n    /^2/,\n    /^3/,\n    /^4/,\n    /^5/,\n    /^6/,\n    /^7/,\n    /^8/,\n    /^9/,\n    /^10/,\n    /^11/,\n    /^12/,\n  ] as const,\n};\n\nconst matchDayPatterns = {\n  narrow: /^(にち|げつ|か|すい|もく|きん|ど)/,\n  short: /^(にち|げつ|か|すい|もく|きん|ど)/,\n  abbreviated: /^(にち|げつ|か|すい|もく|きん|ど)/,\n  wide: /^(にち|げつ|か|すい|もく|きん|ど)ようび/,\n};\nconst parseDayPatterns = {\n  any: [/^にち/, /^げつ/, /^か/, /^すい/, /^もく/, /^きん/, /^ど/] as const,\n};\n\nconst matchDayPeriodPatterns = {\n  any: /^(AM|PM|ごぜん|ごご|しょうご|しんや|まよなか|よる|あさ)/i,\n};\nconst parseDayPeriodPatterns = {\n  any: {\n    am: /^(A|ごぜん)/i,\n    pm: /^(P|ごご)/i,\n    midnight: /^しんや|まよなか/i,\n    noon: /^しょうご/i,\n    morning: /^あさ/i,\n    afternoon: /^ごご/i,\n    evening: /^よる/i,\n    night: /^しんや/i,\n  },\n};\n\nexport const match: Match = {\n  ordinalNumber: buildOrdinalNumberMatch(),\n\n  era: buildEraMatch(),\n\n  quarter: buildQuarterMatch(),\n\n  month: buildMonthMatch(),\n\n  day: buildDayMatch(),\n\n  dayPeriod: buildDayPeriodMatch(),\n};\n\nfunction buildOrdinalNumberMatch() {\n  return buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: function (value) {\n      return parseInt(value, 10);\n    },\n  });\n}\n\nfunction buildEraMatch() {\n  return buildMatchFn({\n    matchPatterns: matchEraPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseEraPatterns,\n    defaultParseWidth: \"any\",\n  });\n}\n\nfunction buildQuarterMatch() {\n  return buildMatchFn({\n    matchPatterns: matchQuarterPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseQuarterPatterns,\n    defaultParseWidth: \"any\",\n    valueCallback: (index) => (index + 1) as Quarter,\n  });\n}\n\nfunction buildMonthMatch() {\n  return buildMatchFn({\n    matchPatterns: matchMonthPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseMonthPatterns,\n    defaultParseWidth: \"any\",\n  });\n"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype FormatDistanceTokenValue =\n  | string\n  | {\n      one: string;\n      other: string;\n    };\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: \"kurang dari 1 saat\",\n    other: \"kurang dari {{count}} saat\",\n  },\n\n  xSeconds: {\n    one: \"1 saat\",\n    other: \"{{count}} saat\",\n  },\n\n  halfAMinute: \"setengah minit\",\n\n  lessThanXMinutes: {\n    one: \"kurang dari 1 minit\",\n    other: \"kurang dari {{count}} minit\",\n  },\n\n  xMinutes: {\n    one: \"1 minit\",\n    other: \"{{count}} minit\",\n  },\n\n  aboutXHours: {\n    one: \"sekitar 1 jam\",\n    other: \"sekitar {{count}} jam\",\n  },\n\n  xHours: {\n    one: \"1 jam\",\n    other: \"{{count}} jam\",\n  },\n\n  xDays: {\n    one: \"1 hari\",\n    other: \"{{count}} hari\",\n  },\n\n  aboutXWeeks: {\n    one: \"sekitar 1 minggu\",\n    other: \"sekitar {{count}} minggu\",\n  },\n\n  xWeeks: {\n    one: \"1 minggu\",\n    other: \"{{count}} minggu\",\n  },\n\n  aboutXMonths: {\n    one: \"sekitar 1 bulan\",\n    other: \"sekitar {{count}} bulan\",\n  },\n\n  xMonths: {\n    one: \"1 bulan\",\n    other: \"{{count}} bulan\",\n  },\n\n  aboutXYears: {\n    one: \"sekitar 1 tahun\",\n    other: \"sekitar {{count}} tahun\",\n  },\n\n  xYears: {\n    one: \"1 tahun\",\n    other: \"{{count}} tahun\",\n  },\n\n  overXYears: {\n    one: \"lebih dari 1 tahun\",\n    other: \"lebih dari {{count}} tahun\",\n  },\n\n  almostXYears: {\n    one: \"hampir 1 tahun\",\n    other: \"hampir {{count}} tahun\",\n  },\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  let result;\n\n  const tokenValue = formatDistanceLocale[token];\n  if (typeof tokenValue === \"string\") {\n    result = tokenValue;\n  } else if (count === 1) {\n    result = tokenValue.one;\n  } else {\n    result = tokenValue.other.replace(\"{{count}}\", String(count));\n  }\n\n  if (options?.addSuffix) {\n    if (options.comparison && options.comparison > 0) {\n      return \"dalam masa \" + result;\n    } else {\n      return result + \" yang lalu\";\n    }\n  }\n\n  return result;\n};\n"
      },
      {
        "role": "assistant",
        "content": "Here is the refactored code with extracted methods for enhanced modularity and readability:\n\n```javascript\nimport type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype FormatDistanceTokenValue =\n  | string\n  | {\n      one: string;\n      other: string;\n    };\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: \"kurang dari 1 saat\",\n    other: \"kurang dari {{count}} saat\",\n  },\n\n  xSeconds: {\n    one: \"1 saat\",\n    other: \"{{count}} saat\",\n  },\n\n  halfAMinute: \"setengah minit\",\n\n  lessThanXMinutes: {\n    one: \"kurang dari 1 minit\",\n    other: \"kurang dari {{count}} minit\",\n  },\n\n  xMinutes: {\n    one: \"1 minit\",\n    other: \"{{count}} minit\",\n  },\n\n  aboutXHours: {\n    one: \"sekitar 1 jam\",\n    other: \"sekitar {{count}} jam\",\n  },\n\n  xHours: {\n    one: \"1 jam\",\n    other: \"{{count}} jam\",\n  },\n\n  xDays: {\n    one: \"1 hari\",\n    other: \"{{count}} hari\",\n  },\n\n  aboutXWeeks: {\n    one: \"sekitar 1 minggu\",\n    other: \"sekitar {{count}} minggu\",\n  },\n\n  xWeeks: {\n    one: \"1 minggu\",\n    other: \"{{count}} minggu\",\n  },\n\n  aboutXMonths: {\n    one: \"sekitar 1 bulan\",\n    other: \"sekitar {{count}} bulan\",\n  },\n\n  xMonths: {\n    one: \"1 bulan\",\n    other: \"{{count}} bulan\",\n  },\n\n  aboutXYears: {\n    one: \"sekitar 1 tahun\",\n    other: \"sekitar {{count}} tahun\",\n  },\n\n  xYears: {\n    one: \"1 tahun\",\n    other: \"{{count}} tahun\",\n  },\n\n  overXYears: {\n    one: \"lebih dari 1 tahun\",\n    other: \"lebih dari {{count}} tahun\",\n  },\n\n  almostXYears: {\n    one: \"hampir 1 tahun\",\n    other: \"hampir {{count}} tahun\",\n  },\n};\n\nconst getLocalizedValue = (token, count) => {\n  const tokenValue = formatDistanceLocale[token];\n  if (typeof tokenValue === \"string\") {\n    return tokenValue;\n  } else if (count === 1) {\n    return tokenValue.one;\n  } else {\n    return tokenValue.other.replace(\"{{count}}\", String(count));\n  }\n};\n\nconst addSuffix = (result, options) => {\n  if (options?.addSuffix) {\n    if (options.comparison && options.comparison > 0) {\n      return \"dalam masa \" + result;\n    } else {\n      return result + \" yang lalu\";\n    }\n  }\n  return result;\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  const result = getLocalizedValue(token, count);\n  return addSuffix(result, options);\n};\n```\n\nBy extracting the `getLocalizedValue` and `addSuffix` methods, the code is now more modular and easier to read. These methods handle specific functionalities, making the main `formatDistance` function cleaner and focused on the core logic."
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Quarter } from \"../../../../types.js\";\nimport type { Match } from \"../../../types.js\";\nimport { buildMatchFn } from \"../../../_lib/buildMatchFn/index.js\";\nimport { buildMatchPatternFn } from \"../../../_lib/buildMatchPatternFn/index.js\";\n\nconst matchOrdinalNumberPattern = /^(\\d+)[ºªo]?/i;\nconst parseOrdinalNumberPattern = /\\d+/i;\n\nconst matchEraPatterns = {\n  narrow: /^(ac|dc|a|d)/i,\n  abbreviated: /^(a\\.?\\s?c\\.?|d\\.?\\s?c\\.?)/i,\n  wide: /^(antes de cristo|depois de cristo)/i,\n};\nconst parseEraPatterns = {\n  any: [/^ac/i, /^dc/i] as const,\n  wide: [/^antes de cristo/i, /^depois de cristo/i] as const,\n};\n\nconst matchQuarterPatterns = {\n  narrow: /^[1234]/i,\n  abbreviated: /^T[1234]/i,\n  wide: /^[1234](º)? trimestre/i,\n};\nconst parseQuarterPatterns = {\n  any: [/1/i, /2/i, /3/i, /4/i] as const,\n};\n\nconst matchMonthPatterns = {\n  narrow: /^[jfmajsond]/i,\n  abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,\n  wide: /^(janeiro|fevereiro|março|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i,\n};\nconst parseMonthPatterns = {\n  narrow: [\n    /^j/i,\n    /^f/i,\n    /^m/i,\n    /^a/i,\n    /^m/i,\n    /^j/i,\n    /^j/i,\n    /^a/i,\n    /^s/i,\n    /^o/i,\n    /^n/i,\n    /^d/i,\n  ] as const,\n  any: [\n    /^ja/i,\n    /^fev/i,\n    /^mar/i,\n    /^abr/i,\n    /^mai/i,\n    /^jun/i,\n    /^jul/i,\n    /^ago/i,\n    /^set/i,\n    /^out/i,\n    /^nov/i,\n    /^dez/i,\n  ] as const,\n};\n\nconst matchDayPatterns = {\n  narrow: /^(dom|[23456]ª?|s[aá]b)/i,\n  short: /^(dom|[23456]ª?|s[aá]b)/i,\n  abbreviated: /^(dom|seg|ter|qua|qui|sex|s[aá]b)/i,\n  wide: /^(domingo|(segunda|ter[cç]a|quarta|quinta|sexta)([- ]feira)?|s[aá]bado)/i,\n};\nconst parseDayPatterns = {\n  short: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[aá]/i] as const,\n  narrow: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[aá]/i] as const,\n  any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[aá]b/i] as const,\n};\n\nconst matchDayPeriodPatterns = {\n  narrow: /^(a|p|mn|md|(da) (manhã|tarde|noite))/i,\n  any: /^([ap]\\.?\\s?m\\.?|meia[-\\s]noite|meio[-\\s]dia|(da) (manhã|tarde|noite))/i,\n};\nconst parseDayPeriodPatterns = {\n  any: {\n    am: /^a/i,\n    pm: /^p/i,\n    midnight: /^mn|^meia[-\\s]noite/i,\n    noon: /^md|^meio[-\\s]dia/i,\n    morning: /manhã/i,\n    afternoon: /tarde/i,\n    evening: /tarde/i,\n    night: /noite/i,\n  },\n};\n\nexport const match: Match = {\n  ordinalNumber: buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: (value) => parseInt(value, 10),\n  }),\n\n  era: buildMatchFn({\n    matchPatterns: matchEraPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseEraPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  quarter: buildMatchFn({\n    matchPatterns: matchQuarterPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseQuarterPatterns,\n    defaultParseWidth: \"any\",\n    valueCallback: (index) => (index + 1) as Quarter,\n  }),\n\n  month: buildMatchFn({\n    matchPatterns: matchMonthPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseMonthPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  day: buildMatchFn({\n    matchPatterns: matchDayPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseDayPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  dayPeriod: buildMatchFn({\n    matchPatterns: matchDayPeriodPatterns,\n    defaultMatchWidth: \"any\",\n    parsePatterns: parseDayPeriodPatterns,\n    defaultParseWidth: \"any\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "import { buildMatchFn } from \"../../../_lib/buildMatchFn/index.js\";\nimport { buildMatchPatternFn } from \"../../../_lib/buildMatchPatternFn/index.js\";\n\nconst matchOrdinalNumberPattern = /^(\\d+)[ºªo]?/i;\nconst parseOrdinalNumberPattern = /\\d+/i;\n\nconst matchEraPatterns = {\n  narrow: /^(ac|dc|a|d)/i,\n  abbreviated: /^(a\\.?\\s?c\\.?|d\\.?\\s?c\\.?)/i,\n  wide: /^(antes de cristo|depois de cristo)/i,\n};\nconst parseEraPatterns = {\n  any: [/^ac/i, /^dc/i] as const,\n  wide: [/^antes de cristo/i, /^depois de cristo/i] as const,\n};\n\nconst matchQuarterPatterns = {\n  narrow: /^[1234]/i,\n  abbreviated: /^T[1234]/i,\n  wide: /^[1234](º)? trimestre/i,\n};\nconst parseQuarterPatterns = {\n  any: [/1/i, /2/i, /3/i, /4/i] as const,\n};\n\nconst matchMonthPatterns = {\n  narrow: /^[jfmajsond]/i,\n  abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,\n  wide: /^(janeiro|fevereiro|março|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i,\n};\nconst parseMonthPatterns = {\n  narrow: [\n    /^j/i,\n    /^f/i,\n    /^m/i,\n    /^a/i,\n    /^m/i,\n    /^j/i,\n    /^j/i,\n    /^a/i,\n    /^s/i,\n    /^o/i,\n    /^n/i,\n    /^d/i,\n  ] as const,\n  any: [\n    /^ja/i,\n    /^fev/i,\n    /^mar/i,\n    /^abr/i,\n    /^mai/i,\n    /^jun/i,\n    /^jul/i,\n    /^ago/i,\n    /^set/i,\n    /^out/i,\n    /^nov/i,\n    /^dez/i,\n  ] as const,\n};\n\nconst matchDayPatterns = {\n  narrow: /^(dom|[23456]ª?|s[aá]b)/i,\n  short: /^(dom|[23456]ª?|s[aá]b)/i,\n  abbreviated: /^(dom|seg|ter|qua|qui|sex|s[aá]b)/i,\n  wide: /^(domingo|(segunda|ter[cç]a|quarta|quinta|sexta)([- ]feira)?|s[aá]bado)/i,\n};\nconst parseDayPatterns = {\n  short: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[aá]/i] as const,\n  narrow: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[aá]/i] as const,\n  any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[aá]b/i] as const,\n};\n\nconst matchDayPeriodPatterns = {\n  narrow: /^(a|p|mn|md|(da) (manhã|tarde|noite))/i,\n  any: /^([ap]\\.?\\s?m\\.?|meia[-\\s]noite|meio[-\\s]dia|(da) (manhã|tarde|noite))/i,\n};\nconst parseDayPeriodPatterns = {\n  any: {\n    am: /^a/i,\n    pm: /^p/i,\n    midnight: /^mn|^meia[-\\s]noite/i,\n    noon: /^md|^meio[-\\s]dia/i,\n    morning: /manhã/i,\n    afternoon: /tarde/i,\n    evening: /tarde/i,\n    night: /noite/i,\n  },\n};\n\nexport const match: Match = {\n  ordinalNumber: buildOrdinalNumberMatchFn(),\n\n  era: buildEraMatchFn(),\n\n  quarter: buildQuarterMatchFn(),\n\n  month: buildMonthMatchFn(),\n\n  day: buildDayMatchFn(),\n\n  dayPeriod: buildDayPeriodMatchFn(),\n};\n\nfunction buildOrdinalNumberMatchFn() {\n  return buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: (value) => parseInt(value, "
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { Quarter } from \"../../../../types.js\";\nimport type { Match } from \"../../../types.js\";\nimport { buildMatchFn } from \"../../../_lib/buildMatchFn/index.js\";\nimport { buildMatchPatternFn } from \"../../../_lib/buildMatchPatternFn/index.js\";\n\nconst matchOrdinalNumberPattern = /^(\\d+)(வது)?/i;\nconst parseOrdinalNumberPattern = /\\d+/i;\n\nconst matchEraPatterns = {\n  narrow: /^(கி.மு.|கி.பி.)/i,\n  abbreviated: /^(கி\\.?\\s?மு\\.?|கி\\.?\\s?பி\\.?)/,\n  wide: /^(கிறிஸ்துவுக்கு\\sமுன்|அன்னோ\\sடோமினி)/i,\n};\nconst parseEraPatterns = {\n  any: [/கி\\.?\\s?மு\\.?/, /கி\\.?\\s?பி\\.?/] as const,\n};\n\nconst matchQuarterPatterns = {\n  narrow: /^[1234]/i,\n  abbreviated: /^காலா.[1234]/i,\n  wide: /^(ஒன்றாம்|இரண்டாம்|மூன்றாம்|நான்காம்) காலாண்டு/i,\n};\nconst parseQuarterPatterns = {\n  narrow: [/1/i, /2/i, /3/i, /4/i] as const,\n  any: [\n    /(1|காலா.1|ஒன்றாம்)/i,\n    /(2|காலா.2|இரண்டாம்)/i,\n    /(3|காலா.3|மூன்றாம்)/i,\n    /(4|காலா.4|நான்காம்)/i,\n  ] as const,\n};\n\nconst matchMonthPatterns = {\n  narrow: /^(ஜ|பி|மா|ஏ|மே|ஜூ|ஆ|செ|அ|ந|டி)$/i,\n  abbreviated: /^(ஜன.|பிப்.|மார்.|ஏப்.|மே|ஜூன்|ஜூலை|ஆக.|செப்.|அக்.|நவ.|டிச.)/i,\n  wide: /^(ஜனவரி|பிப்ரவரி|மார்ச்|ஏப்ரல்|மே|ஜூன்|ஜூலை|ஆகஸ்ட்|செப்டம்பர்|அக்டோபர்|நவம்பர்|டிசம்பர்)/i,\n};\nconst parseMonthPatterns = {\n  narrow: [\n    /^ஜ$/i,\n    /^பி/i,\n    /^மா/i,\n    /^ஏ/i,\n    /^மே/i,\n    /^ஜூ/i,\n    /^ஜூ/i,\n    /^ஆ/i,\n    /^செ/i,\n    /^அ/i,\n    /^ந/i,\n    /^டி/i,\n  ] as const,\n  any: [\n    /^ஜன/i,\n    /^பி/i,\n    /^மா/i,\n    /^ஏ/i,\n    /^மே/i,\n    /^ஜூன்/i,\n    /^ஜூலை/i,\n    /^ஆ/i,\n    /^செ/i,\n    /^அ/i,\n    /^ந/i,\n    /^டி/i,\n  ] as const,\n};\n\nconst matchDayPatterns = {\n  narrow: /^(ஞா|தி|செ|பு|வி|வெ|ச)/i,\n  short: /^(ஞா|தி|செ|பு|வி|வெ|ச)/i,\n  abbreviated: /^(ஞாயி.|திங்.|செவ்.|புத.|வியா.|வெள்.|சனி)/i,\n  wide: /^(ஞாயிறு|திங்கள்|செவ்வாய்|புதன்|வியாழன்|வெள்ளி|சனி)/i,\n};\nconst parseDayPatterns = {\n  narrow: [/^ஞா/i, /^தி/i, /^செ/i, /^பு/i, /^வி/i, /^வெ/i, /^ச/i] as const,\n  any: [/^ஞா/i, /^தி/i, /^செ/i, /^பு/i, /^வி/i, /^வெ/i, /^ச/i] as const,\n};\n\nconst matchDayPeriodPatterns = {\n  narrow: /^(மு.ப|பி.ப|நள்|நண்|காலை|மதியம்|மாலை|இரவு)/i,\n  any: /^(மு.ப|பி.ப|முற்பகல்|பிற்பகல்|நள்ளிரவு|நண்பகல்|காலை|மதியம்|மாலை|இரவு)/i,\n};\nconst parseDayPeriodPatterns = {\n  any: {\n    am: /^மு/i,\n    pm: /^பி/i,\n    midnight: /^நள்/i,\n    noon: /^நண்/i,\n    morning: /காலை/i,\n    afternoon: /மதியம்/i,\n    evening: /மாலை/i,\n    night: /இரவு/i,\n  },\n};\n\nexport const match: Match = {\n  ordinalNumber: buildMatchPatternFn({\n    matchPattern: matchOrdinalNumberPattern,\n    parsePattern: parseOrdinalNumberPattern,\n    valueCallback: (value) => parseInt(value, 10),\n  }),\n\n  era: buildMatchFn({\n    matchPatterns: matchEraPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseEraPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  quarter: buildMatchFn({\n    matchPatterns: matchQuarterPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseQuarterPatterns,\n    defaultParseWidth: \"any\",\n    valueCallback: (index) => (index + 1) as Quarter,\n  }),\n\n  month: buildMatchFn({\n    matchPatterns: matchMonthPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseMonthPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  day: buildMatchFn({\n    matchPatterns: matchDayPatterns,\n    defaultMatchWidth: \"wide\",\n    parsePatterns: parseDayPatterns,\n    defaultParseWidth: \"any\",\n  }),\n\n  dayPeriod: buildMatchFn({\n    matchPatterns: matchDayPeriodPatterns,\n    defaultMatchWidth: \"any\",\n    parsePatterns: parseDayPeriodPatterns,\n    defaultParseWidth: \"any\",\n  }),\n};\n"
      },
      {
        "role": "assistant",
        "content": "```javascript\n// Extracted method for matching ordinal numbers\nconst matchOrdinalNumber = buildMatchPatternFn({\n  matchPattern: matchOrdinalNumberPattern,\n  parsePattern: parseOrdinalNumberPattern,\n  valueCallback: (value) => parseInt(value, 10),\n});\n\n// Extracted method for matching eras\nconst matchEra = buildMatchFn({\n  matchPatterns: matchEraPatterns,\n  defaultMatchWidth: \"wide\",\n  parsePatterns: parseEraPatterns,\n  defaultParseWidth: \"any\",\n});\n\n// Extracted method for matching quarters\nconst matchQuarter = buildMatchFn({\n  matchPatterns: matchQuarterPatterns,\n  defaultMatchWidth: \"wide\",\n  parsePatterns: parseQuarterPatterns,\n  defaultParseWidth: \"any\",\n  valueCallback: (index) => (index + 1) as Quarter,\n});\n\n// Extracted method for matching months\nconst matchMonth = buildMatchFn({\n  matchPatterns: matchMonthPatterns,\n  defaultMatchWidth: \"wide\",\n  parsePatterns: parseMonthPatterns,\n  defaultParseWidth: \"any\",\n});\n\n// Extracted method for matching days\nconst matchDay = buildMatchFn({\n  matchPatterns: matchDayPatterns,\n  defaultMatchWidth: \"wide\",\n  parsePatterns: parseDayPatterns,\n  defaultParseWidth: \"any\",\n});\n\n// Extracted method for matching day periods\nconst matchDayPeriod = buildMatchFn({\n  matchPatterns: matchDayPeriodPatterns,\n  defaultMatchWidth: \"any\",\n  parsePatterns: parseDayPeriodPatterns,\n  defaultParseWidth: \"any\",\n});\n\nexport const match: Match = {\n  ordinalNumber: matchOrdinalNumber,\n  era: matchEra,\n  quarter: matchQuarter,\n  month: matchMonth,\n  day: matchDay,\n  dayPeriod: matchDayPeriod,\n};\n```"
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype FormatDistanceTokenValue =\n  | string\n  | {\n      one: string;\n      other: string;\n    };\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: \"少於 1 秒\",\n    other: \"少於 {{count}} 秒\",\n  },\n\n  xSeconds: {\n    one: \"1 秒\",\n    other: \"{{count}} 秒\",\n  },\n\n  halfAMinute: \"半分鐘\",\n\n  lessThanXMinutes: {\n    one: \"少於 1 分鐘\",\n    other: \"少於 {{count}} 分鐘\",\n  },\n\n  xMinutes: {\n    one: \"1 分鐘\",\n    other: \"{{count}} 分鐘\",\n  },\n\n  xHours: {\n    one: \"1 小時\",\n    other: \"{{count}} 小時\",\n  },\n\n  aboutXHours: {\n    one: \"大約 1 小時\",\n    other: \"大約 {{count}} 小時\",\n  },\n\n  xDays: {\n    one: \"1 天\",\n    other: \"{{count}} 天\",\n  },\n\n  aboutXWeeks: {\n    one: \"大約 1 個星期\",\n    other: \"大約 {{count}} 個星期\",\n  },\n\n  xWeeks: {\n    one: \"1 個星期\",\n    other: \"{{count}} 個星期\",\n  },\n\n  aboutXMonths: {\n    one: \"大約 1 個月\",\n    other: \"大約 {{count}} 個月\",\n  },\n\n  xMonths: {\n    one: \"1 個月\",\n    other: \"{{count}} 個月\",\n  },\n\n  aboutXYears: {\n    one: \"大約 1 年\",\n    other: \"大約 {{count}} 年\",\n  },\n\n  xYears: {\n    one: \"1 年\",\n    other: \"{{count}} 年\",\n  },\n\n  overXYears: {\n    one: \"超過 1 年\",\n    other: \"超過 {{count}} 年\",\n  },\n\n  almostXYears: {\n    one: \"將近 1 年\",\n    other: \"將近 {{count}} 年\",\n  },\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  let result;\n\n  const tokenValue = formatDistanceLocale[token];\n  if (typeof tokenValue === \"string\") {\n    result = tokenValue;\n  } else if (count === 1) {\n    result = tokenValue.one;\n  } else {\n    result = tokenValue.other.replace(\"{{count}}\", String(count));\n  }\n\n  if (options?.addSuffix) {\n    if (options.comparison && options.comparison > 0) {\n      return result + \"內\";\n    } else {\n      return result + \"前\";\n    }\n  }\n\n  return result;\n};\n"
      },
      {
        "role": "assistant",
        "content": "import type { FormatDistanceFn, FormatDistanceLocale } from \"../../../types.js\";\n\ntype FormatDistanceTokenValue =\n  | string\n  | {\n      one: string;\n      other: string;\n    };\n\nconst formatDistanceLocale: FormatDistanceLocale<FormatDistanceTokenValue> = {\n  lessThanXSeconds: {\n    one: \"少於 1 秒\",\n    other: \"少於 {{count}} 秒\",\n  },\n\n  xSeconds: {\n    one: \"1 秒\",\n    other: \"{{count}} 秒\",\n  },\n\n  halfAMinute: \"半分鐘\",\n\n  lessThanXMinutes: {\n    one: \"少於 1 分鐘\",\n    other: \"少於 {{count}} 分鐘\",\n  },\n\n  xMinutes: {\n    one: \"1 分鐘\",\n    other: \"{{count}} 分鐘\",\n  },\n\n  xHours: {\n    one: \"1 小時\",\n    other: \"{{count}} 小時\",\n  },\n\n  aboutXHours: {\n    one: \"大約 1 小時\",\n    other: \"大約 {{count}} 小時\",\n  },\n\n  xDays: {\n    one: \"1 天\",\n    other: \"{{count}} 天\",\n  },\n\n  aboutXWeeks: {\n    one: \"大約 1 個星期\",\n    other: \"大約 {{count}} 個星期\",\n  },\n\n  xWeeks: {\n    one: \"1 個星期\",\n    other: \"{{count}} 個星期\",\n  },\n\n  aboutXMonths: {\n    one: \"大約 1 個月\",\n    other: \"大約 {{count}} 個月\",\n  },\n\n  xMonths: {\n    one: \"1 個月\",\n    other: \"{{count}} 個月\",\n  },\n\n  aboutXYears: {\n    one: \"大約 1 年\",\n    other: \"大約 {{count}} 年\",\n  },\n\n  xYears: {\n    one: \"1 年\",\n    other: \"{{count}} 年\",\n  },\n\n  overXYears: {\n    one: \"超過 1 年\",\n    other: \"超過 {{count}} 年\",\n  },\n\n  almostXYears: {\n    one: \"將近 1 年\",\n    other: \"將近 {{count}} 年\",\n  },\n};\n\nconst getResult = (tokenValue, count) => {\n  let result;\n  if (typeof tokenValue === \"string\") {\n    result = tokenValue;\n  } else if (count === 1) {\n    result = tokenValue.one;\n  } else {\n    result = tokenValue.other.replace(\"{{count}}\", String(count));\n  }\n  return result;\n};\n\nconst addSuffix = (result, options) => {\n  if (options?.addSuffix) {\n    if (options.comparison && options.comparison > 0) {\n      return result + \"內\";\n    } else {\n      return result + \"前\";\n    }\n  }\n  return result;\n};\n\nexport const formatDistance: FormatDistanceFn = (token, count, options) => {\n  const tokenValue = formatDistanceLocale[token];\n  let result = getResult(tokenValue, count);\n  return addSuffix(result, options);\n};"
      }
    ]
  ],
  "failed": [
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { toDate } from \"../toDate/index.js\";\n\n/**\n * @name startOfMinute\n * @category Minute Helpers\n * @summary Return the start of a minute for the given date.\n *\n * @description\n * Return the start of a minute for the given date.\n * The result will be in the local timezone.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The start of a minute\n *\n * @example\n * // The start of a minute for 1 December 2014 22:15:45.400:\n * const result = startOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))\n * //=> Mon Dec 01 2014 22:15:00\n */\nexport function startOfMinute<DateType extends Date>(\n  date: DateType | number | string,\n): DateType {\n  const _date = toDate(date);\n  _date.setSeconds(0, 0);\n  return _date;\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { toDate } from \"../toDate/index.js\";\n\n/**\n * @name startOfMinute\n * @category Minute Helpers\n * @summary Return the start of a minute for the given date.\n *\n * @description\n * Return the start of a minute for the given date.\n * The result will be in the local timezone.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The start of a minute\n *\n * @example\n * // The start of a minute for 1 December 2014 22:15:45.400:\n * const result = startOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))\n * //=> Mon Dec 01 2014 22:15:00\n */\nexport function startOfMinute<DateType extends Date>(\n  date: DateType | number | string,\n): DateType {\n  const _date = toDate(date);\n  _date.setSeconds(0, 0);\n  return _date;\n}\n\n/**\n * @name clearSecondsAndMilliseconds\n * @description Clears the seconds and milliseconds of a given date.\n *\n * @param date - The date to clear the seconds and milliseconds from\n *\n * @returns The date with seconds and milliseconds cleared\n */\nfunction clearSecondsAndMilliseconds<DateType extends Date>(date: DateType): DateType {\n  date.setSeconds(0, 0);\n  return date;\n}\n\n/**\n * @name startOfMinute\n * @description Return the start of a minute for the given date.\n *\n * @param date - The original date\n *\n * @returns The start of a minute\n */\nexport function startOfMinute<DateType extends Date>(date: DateType | number | string): DateType {\n  const _date = toDate(date);\n  return clearSecondsAndMilliseconds(_date);\n}"
      },
      {
        "role": "user",
        "content": "Error: Command failed: npm run test\n\u001b[33mThe CJS build of Vite's Node API is deprecated. See https://vitejs.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated for more details.\u001b[39m\nstderr | "
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { millisecondsInWeek } from \"../constants/index.js\";\nimport { startOfWeek } from \"../startOfWeek/index.js\";\nimport type { LocalizedOptions, WeekOptions } from \"../types.js\";\nimport { getTimezoneOffsetInMilliseconds } from \"../_lib/getTimezoneOffsetInMilliseconds/index.js\";\n\n/**\n * The {@link differenceInCalendarWeeks} function options.\n */\nexport interface DifferenceInCalendarWeeksOptions\n  extends LocalizedOptions<\"options\">,\n    WeekOptions {}\n\n/**\n * @name differenceInCalendarWeeks\n * @category Week Helpers\n * @summary Get the number of calendar weeks between the given dates.\n *\n * @description\n * Get the number of calendar weeks between the given dates.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param dateLeft - The later date\n * @param dateRight - The earlier date\n * @param options - An object with options.\n *\n * @returns The number of calendar weeks\n *\n * @example\n * // How many calendar weeks are between 5 July 2014 and 20 July 2014?\n * const result = differenceInCalendarWeeks(\n *   new Date(2014, 6, 20),\n *   new Date(2014, 6, 5)\n * )\n * //=> 3\n *\n * @example\n * // If the week starts on Monday,\n * // how many calendar weeks are between 5 July 2014 and 20 July 2014?\n * const result = differenceInCalendarWeeks(\n *   new Date(2014, 6, 20),\n *   new Date(2014, 6, 5),\n *   { weekStartsOn: 1 }\n * )\n * //=> 2\n */\nexport function differenceInCalendarWeeks<DateType extends Date>(\n  dateLeft: DateType | number | string,\n  dateRight: DateType | number | string,\n  options?: DifferenceInCalendarWeeksOptions,\n): number {\n  const startOfWeekLeft = startOfWeek(dateLeft, options);\n  const startOfWeekRight = startOfWeek(dateRight, options);\n\n  const timestampLeft =\n    +startOfWeekLeft - getTimezoneOffsetInMilliseconds(startOfWeekLeft);\n  const timestampRight =\n    +startOfWeekRight - getTimezoneOffsetInMilliseconds(startOfWeekRight);\n\n  // Round the number of days to the nearest integer because the number of\n  // milliseconds in a days is not constant (e.g. it's different in the week of\n  // the daylight saving time clock shift).\n  return Math.round((timestampLeft - timestampRight) / millisecondsInWeek);\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { startOfWeek } from \"../startOfWeek/index.js\";\nimport { getTimezoneOffsetInMilliseconds } from \"../_lib/getTimezoneOffsetInMilliseconds/index.js\";\n\n/**\n * Get the start of the week for a given date.\n * @param date - The date to get the start of the week for\n * @param options - An object with options\n * @returns The start of the week\n */\nfunction getStartOfWeek(date: Date | number | string, options?: WeekOptions): Date {\n  return startOfWeek(date, options);\n}\n\n/**\n * Get the timestamp adjusted for timezone offset.\n * @param date - The date to get the adjusted timestamp for\n * @returns The adjusted timestamp\n */\nfunction getAdjustedTimestamp(date: Date): number {\n  return +date - getTimezoneOffsetInMilliseconds(date);\n}\n\n/**\n * Get the number of calendar weeks between two dates.\n * @param dateLeft - The later date\n * @param dateRight - The earlier date\n * @param options - An object with options\n * @returns The number of calendar weeks\n */\nexport function differenceInCalendarWeeks<DateType extends Date>(\n  dateLeft: DateType | number | string,\n  dateRight: DateType | number | string,\n  options?: DifferenceInCalendarWeeksOptions,\n): number {\n  const startOfWeekLeft = getStartOfWeek(dateLeft, options);\n  const startOfWeekRight = getStartOfWeek(dateRight, options);\n\n  const timestampLeft = getAdjustedTimestamp(startOfWeekLeft);\n  const timestampRight = getAdjustedTimestamp(startOfWeekRight);\n\n  return Math.round((timestampLeft - timestampRight) / millisecondsInWeek);\n}"
      },
      {
        "role": "user",
        "content": "Error: Command failed: npm run test\n\u001b[33mThe CJS build of Vite's Node API is deprecated. See https://vitejs.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated for more details.\u001b[39m\nstderr | "
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { addDays } from \"../addDays/index.js\";\nimport { toDate } from \"../toDate/index.js\";\nimport type { LocalizedOptions, WeekOptions } from \"../types.js\";\nimport { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n\n/**\n * The {@link setDay} function options.\n */\nexport interface SetDayOptions\n  extends LocalizedOptions<\"options\">,\n    WeekOptions {}\n\n/**\n * @name setDay\n * @category Weekday Helpers\n * @summary Set the day of the week to the given date.\n *\n * @description\n * Set the day of the week to the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The date to be changed\n * @param day - The day of the week of the new date\n * @param options - An object with options.\n *\n * @returns The new date with the day of the week set\n *\n * @example\n * // Set week day to Sunday, with the default weekStartsOn of Sunday:\n * const result = setDay(new Date(2014, 8, 1), 0)\n * //=> Sun Aug 31 2014 00:00:00\n *\n * @example\n * // Set week day to Sunday, with a weekStartsOn of Monday:\n * const result = setDay(new Date(2014, 8, 1), 0, { weekStartsOn: 1 })\n * //=> Sun Sep 07 2014 00:00:00\n */\nexport function setDay<DateType extends Date>(\n  date: DateType | number | string,\n  day: number,\n  options?: SetDayOptions,\n): DateType {\n  const defaultOptions = getDefaultOptions();\n  const weekStartsOn =\n    options?.weekStartsOn ??\n    options?.locale?.options?.weekStartsOn ??\n    defaultOptions.weekStartsOn ??\n    defaultOptions.locale?.options?.weekStartsOn ??\n    0;\n\n  const _date = toDate(date);\n  const currentDay = _date.getDay();\n\n  const remainder = day % 7;\n  const dayIndex = (remainder + 7) % 7;\n\n  const delta = 7 - weekStartsOn;\n  const diff =\n    day < 0 || day > 6\n      ? day - ((currentDay + delta) % 7)\n      : ((dayIndex + delta) % 7) - ((currentDay + delta) % 7);\n  return addDays(_date, diff);\n}\n"
      },
      {
        "role": "assistant",
        "content": "```javascript\nimport { addDays } from \"../addDays/index.js\";\nimport { toDate } from \"../toDate/index.js\";\nimport type { LocalizedOptions, WeekOptions } from \"../types.js\";\nimport { getDefaultOptions } from \"../_lib/defaultOptions/index.js\";\n\n/**\n * The {@link setDay} function options.\n */\nexport interface SetDayOptions\n  extends LocalizedOptions<\"options\">,\n    WeekOptions {}\n\n/**\n * Get the week starts on value from the options or default options.\n *\n * @param options - An object with options.\n * @returns The week starts on value\n */\nfunction getWeekStartsOn(options: SetDayOptions | undefined): number {\n  const defaultOptions = getDefaultOptions();\n  return (\n    options?.weekStartsOn ??\n    options?.locale?.options?.weekStartsOn ??\n    defaultOptions.weekStartsOn ??\n    defaultOptions.locale?.options?.weekStartsOn ??\n    0\n  );\n}\n\n/**\n * Calculate the difference in days to set the day of the week.\n *\n * @param currentDay - The current day of the date\n * @param dayIndex - The index of the target day of the week\n * @param weekStartsOn - The week starts on value\n * @returns The difference in days\n */\nfunction calculateDayDifference(currentDay: number, dayIndex: number, weekStartsOn: number): number {\n  const delta = 7 - weekStartsOn;\n  return dayIndex < 0 || dayIndex > 6\n    ? dayIndex - ((currentDay + delta) % 7)\n    : ((dayIndex + delta) % 7) - ((currentDay + delta) % 7);\n}\n\n/**\n * @name setDay\n * @category Weekday Helpers\n * @summary Set the day of the week to the given date.\n *\n * @description\n * Set the day of the week to the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The date to be changed\n * @param day - The day of the week of the new date\n * @param options - An object with options.\n *\n * @returns The new date with the day of the week set\n *\n * @example\n * // Set week day to Sunday, with the default weekStartsOn of Sunday:\n * const result = setDay(new Date(2014, 8, 1), 0)\n * //=> Sun Aug 31 2014 00:00:00\n *\n * @example\n * // Set week day to Sunday, with a weekStartsOn of Monday:\n * const result = setDay(new Date(2014, 8, 1), 0, { weekStartsOn: 1 })\n * //=> Sun Sep 07 2014 00:00:00\n */\nexport function setDay<DateType extends Date>(\n  date: DateType | number | string,\n  day: number,\n  options?: SetDayOptions,\n): DateType {\n  const weekStartsOn = getWeekStartsOn(options);\n  const _date = toDate(date);\n  const currentDay = _date.getDay();\n  const remainder = day % 7;\n  const dayIndex = (remainder + 7) % 7;\n  const diff = calculateDayDifference(currentDay, dayIndex, weekStartsOn);\n  return addDays(_date, diff);\n}\n```"
      },
      {
        "role": "user",
        "content": "Error: Command failed: npm run test\n\u001b[33mThe CJS build of Vite's Node API is deprecated. See https://vitejs.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated for more details.\u001b[39m\nstderr | "
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { getISOWeekYear } from \"../getISOWeekYear/index.js\";\nimport { startOfISOWeek } from \"../startOfISOWeek/index.js\";\nimport { constructFrom } from \"../constructFrom/index.js\";\n\n/**\n * @name lastDayOfISOWeekYear\n * @category ISO Week-Numbering Year Helpers\n * @summary Return the last day of an ISO week-numbering year for the given date.\n *\n * @description\n * Return the last day of an ISO week-numbering year,\n * which always starts 3 days before the year's first Thursday.\n * The result will be in the local timezone.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The end of an ISO week-numbering year\n *\n * @example\n * // The last day of an ISO week-numbering year for 2 July 2005:\n * const result = lastDayOfISOWeekYear(new Date(2005, 6, 2))\n * //=> Sun Jan 01 2006 00:00:00\n */\nexport function lastDayOfISOWeekYear<DateType extends Date>(\n  date: DateType | number | string,\n): DateType {\n  const year = getISOWeekYear(date);\n  const fourthOfJanuary = constructFrom(date, 0);\n  fourthOfJanuary.setFullYear(year + 1, 0, 4);\n  fourthOfJanuary.setHours(0, 0, 0, 0);\n  const _date = startOfISOWeek(fourthOfJanuary);\n  _date.setDate(_date.getDate() - 1);\n  return _date;\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { getISOWeekYear } from \"../getISOWeekYear/index.js\";\nimport { startOfISOWeek } from \"../startOfISOWeek/index.js\";\nimport { constructFrom } from \"../constructFrom/index.js\";\n\n/**\n * @name getLastDayOfISOWeekYear\n * @param date - The original date\n * @returns The end of an ISO week-numbering year\n */\nexport function getLastDayOfISOWeekYear<DateType extends Date>(\n  date: DateType | number | string,\n): DateType {\n  const year = getISOWeekYear(date);\n  const fourthOfJanuary = getFourthOfJanuary(year);\n  const lastDay = getLastDayOfWeek(fourthOfJanuary);\n  return lastDay;\n}\n\n/**\n * Get the date representing the fourth of January for the given year.\n * @param year - The year\n * @returns The date representing the fourth of January\n */\nfunction getFourthOfJanuary(year: number): Date {\n  const fourthOfJanuary = constructFrom(new Date(year, 0, 4), 0);\n  return fourthOfJanuary;\n}\n\n/**\n * Get the last day of the week for the given date.\n * @param date - The date\n * @returns The last day of the week\n */\nfunction getLastDayOfWeek<DateType extends Date>(date: DateType): DateType {\n  const startOfNextYear = new Date(date.getFullYear() + 1, 0, 1);\n  const startOfISOWeek = startOfISOWeek(startOfNextYear);\n  const lastDay = new Date(startOfISOWeek.getTime() - 86400000);\n  return lastDay;\n}"
      },
      {
        "role": "user",
        "content": "Error: Command failed: npm run test\n\u001b[33mThe CJS build of Vite's Node API is deprecated. See https://vitejs.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated for more details.\u001b[39m\nstderr | "
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { addISOWeekYears } from \"../addISOWeekYears/index.js\";\n\n/**\n * @name subISOWeekYears\n * @category ISO Week-Numbering Year Helpers\n * @summary Subtract the specified number of ISO week-numbering years from the given date.\n *\n * @description\n * Subtract the specified number of ISO week-numbering years from the given date.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The date to be changed\n * @param amount - The amount of ISO week-numbering years to be subtracted.\n *\n * @returns The new date with the ISO week-numbering years subtracted\n *\n * @example\n * // Subtract 5 ISO week-numbering years from 1 September 2014:\n * const result = subISOWeekYears(new Date(2014, 8, 1), 5)\n * //=> Mon Aug 31 2009 00:00:00\n */\nexport function subISOWeekYears<DateType extends Date>(\n  date: DateType | number | string,\n  amount: number,\n): DateType {\n  return addISOWeekYears(date, -amount);\n}\n"
      },
      {
        "role": "assistant",
        "content": "Refactored code:\n\n```javascript\nimport { addISOWeekYears } from \"../addISOWeekYears/index.js\";\n\n/**\n * @name subISOWeekYears\n * @category ISO Week-Numbering Year Helpers\n * @summary Subtract the specified number of ISO week-numbering years from the given date.\n *\n * @description\n * Subtract the specified number of ISO week-numbering years from the given date.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The date to be changed\n * @param amount - The amount of ISO week-numbering years to be subtracted.\n *\n * @returns The new date with the ISO week-numbering years subtracted\n *\n * @example\n * // Subtract 5 ISO week-numbering years from 1 September 2014:\n * const result = subISOWeekYears(new Date(2014, 8, 1), 5)\n * //=> Mon Aug 31 2009 00:00:00\n */\nexport function subISOWeekYears<DateType extends Date>(\n  date: DateType | number | string,\n  amount: number,\n): DateType {\n  return addISOWeekYears(date, -amount);\n}\n\n/**\n * @name addISOWeekYears\n * @category ISO Week-Numbering Year Helpers\n * @summary Add the specified number of ISO week-numbering years to the given date.\n *\n * @description\n * Add the specified number of ISO week-numbering years to the given date.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The date to be changed\n * @param amount - The amount of ISO week-numbering years to be added.\n *\n * @returns The new date with the ISO week-numbering years added\n */\nexport function addISOWeekYears<DateType extends Date>(\n  date: DateType | number | string,\n  amount: number,\n): DateType {\n  const newDate = new Date(date);\n  newDate.setFullYear(newDate.getFullYear() + amount);\n  return newDate as DateType;\n}\n```"
      },
      {
        "role": "user",
        "content": "Error: Command failed: npm run test\n\u001b[33mThe CJS build of Vite's Node API is deprecated. See https://vitejs.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated for more details.\u001b[39m\nstderr | "
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\n/**\n * @name endOfYesterday\n * @category Day Helpers\n * @summary Return the end of yesterday.\n * @pure false\n *\n * @description\n * Return the end of yesterday.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @returns The end of yesterday\n *\n * @example\n * // If today is 6 October 2014:\n * const result = endOfYesterday()\n * //=> Sun Oct 5 2014 23:59:59.999\n */\nexport function endOfYesterday(): Date {\n  const now = new Date();\n  const year = now.getFullYear();\n  const month = now.getMonth();\n  const day = now.getDate();\n\n  const date = new Date(0);\n  date.setFullYear(year, month, day - 1);\n  date.setHours(23, 59, 59, 999);\n  return date;\n}\n"
      },
      {
        "role": "assistant",
        "content": "/**\n * @name getYesterdayDate\n * @category Day Helpers\n * @summary Return the date of yesterday.\n *\n * @returns The date of yesterday\n */\nfunction getYesterdayDate(): Date {\n  const now = new Date();\n  const year = now.getFullYear();\n  const month = now.getMonth();\n  const day = now.getDate();\n\n  const date = new Date(0);\n  date.setFullYear(year, month, day - 1);\n  return date;\n}\n\n/**\n * @name setEndOfDay\n * @category Day Helpers\n * @summary Set the time to end of day.\n *\n * @param date - The date to set the time for.\n * @returns The date with time set to end of day\n */\nfunction setEndOfDay(date: Date): Date {\n  date.setHours(23, 59, 59, 999);\n  return date;\n}\n\n/**\n * @name endOfYesterday\n * @category Day Helpers\n * @summary Return the end of yesterday.\n *\n * @returns The end of yesterday\n */\nexport function endOfYesterday(): Date {\n  const yesterday = getYesterdayDate();\n  const endOfYesterday = setEndOfDay(yesterday);\n  return endOfYesterday;\n}\n```"
      },
      {
        "role": "user",
        "content": "Error: Command failed: npm run test\n\u001b[33mThe CJS build of Vite's Node API is deprecated. See https://vitejs.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated for more details.\u001b[39m\nstderr | "
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { toDate } from \"../toDate/index.js\";\n\n/**\n * @name lastDayOfMonth\n * @category Month Helpers\n * @summary Return the last day of a month for the given date.\n *\n * @description\n * Return the last day of a month for the given date.\n * The result will be in the local timezone.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The original date\n *\n * @returns The last day of a month\n *\n * @example\n * // The last day of a month for 2 September 2014 11:55:00:\n * const result = lastDayOfMonth(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Tue Sep 30 2014 00:00:00\n */\nexport function lastDayOfMonth<DateType extends Date>(\n  date: DateType | number | string,\n): DateType {\n  const _date = toDate(date);\n  const month = _date.getMonth();\n  _date.setFullYear(_date.getFullYear(), month + 1, 0);\n  _date.setHours(0, 0, 0, 0);\n  return _date;\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { toDate } from \"../toDate/index.js\";\n\n/**\n * @name getLastDayOfMonth\n * @category Month Helpers\n * @summary Return the last day of a month for the given date.\n *\n * @param date - The original date\n * @returns The last day of a month\n *\n * @example\n * // The last day of a month for 2 September 2014 11:55:00:\n * const result = getLastDayOfMonth(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Tue Sep 30 2014 00:00:00\n */\nexport function getLastDayOfMonth<DateType extends Date>(date: DateType | number | string): DateType {\n  const _date = toDate(date);\n  const month = _date.getMonth();\n  return calculateLastDayOfMonth(_date, month);\n}\n\n/**\n * Calculate the last day of the month for a given date.\n *\n * @param date - The date object\n * @param month - The month of the date\n * @returns The last day of the month\n */\nfunction calculateLastDayOfMonth(date: Date, month: number): Date {\n  date.setFullYear(date.getFullYear(), month + 1, 0);\n  date.setHours(0, 0, 0, 0);\n  return date;\n}"
      },
      {
        "role": "user",
        "content": "Error: Command failed: npm run test\n\u001b[33mThe CJS build of Vite's Node API is deprecated. See https://vitejs.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated for more details.\u001b[39m\nstderr | "
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { addLeadingZeros } from \"../../addLeadingZeros/index.js\";\n\n/*\n * |     | Unit                           |     | Unit                           |\n * |-----|--------------------------------|-----|--------------------------------|\n * |  a  | AM, PM                         |  A* |                                |\n * |  d  | Day of month                   |  D  |                                |\n * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |\n * |  m  | Minute                         |  M  | Month                          |\n * |  s  | Second                         |  S  | Fraction of second             |\n * |  y  | Year (abs)                     |  Y  |                                |\n *\n * Letters marked by * are not implemented but reserved by Unicode standard.\n */\n\nexport const lightFormatters = {\n  // Year\n  y(date: Date, token: string): string {\n    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens\n    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |\n    // |----------|-------|----|-------|-------|-------|\n    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |\n    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |\n    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |\n    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |\n    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |\n\n    const signedYear = date.getFullYear();\n    // Returns 1 for 1 BC (which is year 0 in JavaScript)\n    const year = signedYear > 0 ? signedYear : 1 - signedYear;\n    return addLeadingZeros(token === \"yy\" ? year % 100 : year, token.length);\n  },\n\n  // Month\n  M(date: Date, token: string): string {\n    const month = date.getMonth();\n    return token === \"M\" ? String(month + 1) : addLeadingZeros(month + 1, 2);\n  },\n\n  // Day of the month\n  d(date: Date, token: string): string {\n    return addLeadingZeros(date.getDate(), token.length);\n  },\n\n  // AM or PM\n  a(date: Date, token: string): string {\n    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? \"pm\" : \"am\";\n\n    switch (token) {\n      case \"a\":\n      case \"aa\":\n        return dayPeriodEnumValue.toUpperCase();\n      case \"aaa\":\n        return dayPeriodEnumValue;\n      case \"aaaaa\":\n        return dayPeriodEnumValue[0];\n      case \"aaaa\":\n      default:\n        return dayPeriodEnumValue === \"am\" ? \"a.m.\" : \"p.m.\";\n    }\n  },\n\n  // Hour [1-12]\n  h(date: Date, token: string): string {\n    return addLeadingZeros(date.getHours() % 12 || 12, token.length);\n  },\n\n  // Hour [0-23]\n  H(date: Date, token: string): string {\n    return addLeadingZeros(date.getHours(), token.length);\n  },\n\n  // Minute\n  m(date: Date, token: string): string {\n    return addLeadingZeros(date.getMinutes(), token.length);\n  },\n\n  // Second\n  s(date: Date, token: string): string {\n    return addLeadingZeros(date.getSeconds(), token.length);\n  },\n\n  // Fraction of second\n  S(date: Date, token: string): string {\n    const numberOfDigits = token.length;\n    const milliseconds = date.getMilliseconds();\n    const fractionalSeconds = Math.trunc(\n      milliseconds * Math.pow(10, numberOfDigits - 3),\n    );\n    return addLeadingZeros(fractionalSeconds, token.length);\n  },\n};\n"
      },
      {
        "role": "assistant",
        "content": "import { addLeadingZeros } from \"../../addLeadingZeros/index.js\";\n\nexport const lightFormatters = {\n  y(date: Date, token: string): string {\n    const year = this.getYear(date, token);\n    return addLeadingZeros(token === \"yy\" ? year % 100 : year, token.length);\n  },\n\n  getYear(date: Date, token: string): number {\n    const signedYear = date.getFullYear();\n    return signedYear > 0 ? signedYear : 1 - signedYear;\n  },\n\n  M(date: Date, token: string): string {\n    const month = date.getMonth();\n    return token === \"M\" ? String(month + 1) : addLeadingZeros(month + 1, 2);\n  },\n\n  d(date: Date, token: string): string {\n    return addLeadingZeros(date.getDate(), token.length);\n  },\n\n  a(date: Date, token: string): string {\n    const dayPeriodEnumValue = this.getDayPeriodValue(date);\n    \n    switch (token) {\n      case \"a\":\n      case \"aa\":\n        return dayPeriodEnumValue.toUpperCase();\n      case \"aaa\":\n        return dayPeriodEnumValue;\n      case \"aaaaa\":\n        return dayPeriodEnumValue[0];\n      case \"aaaa\":\n      default:\n        return dayPeriodEnumValue === \"am\" ? \"a.m.\" : \"p.m.\";\n    }\n  },\n\n  getDayPeriodValue(date: Date): string {\n    return date.getHours() / 12 >= 1 ? \"pm\" : \"am\";\n  },\n\n  h(date: Date, token: string): string {\n    return addLeadingZeros(date.getHours() % 12 || 12, token.length);\n  },\n\n  H(date: Date, token: string): string {\n    return addLeadingZeros(date.getHours(), token.length);\n  },\n\n  m(date: Date, token: string): string {\n    return addLeadingZeros(date.getMinutes(), token.length);\n  },\n\n  s(date: Date, token: string): string {\n    return addLeadingZeros(date.getSeconds(), token.length);\n  },\n\n  S(date: Date, token: string): string {\n    const fractionalSeconds = this.getFractionalSeconds(date, token.length);\n    return addLeadingZeros(fractionalSeconds, token.length);\n  },\n\n  getFractionalSeconds(date: Date, numberOfDigits: number): number {\n    const milliseconds = date.getMilliseconds();\n    return Math.trunc(milliseconds * Math.pow(10, numberOfDigits - 3));\n  },\n};"
      },
      {
        "role": "user",
        "content": "Error: Command failed: npm run test\n\u001b[33mThe CJS build of Vite's Node API is deprecated. See https://vitejs.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated for more details.\u001b[39m\nstderr | "
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\nimport { toDate } from \"../toDate/index.js\";\nimport type { Interval } from \"../types.js\";\n\n/**\n * The {@link areIntervalsOverlapping} function options.\n */\nexport interface AreIntervalsOverlappingOptions {\n  /** Whether the comparison is inclusive or not */\n  inclusive?: boolean;\n}\n\n/**\n * @name areIntervalsOverlapping\n * @category Interval Helpers\n * @summary Is the given time interval overlapping with another time interval?\n *\n * @description\n * Is the given time interval overlapping with another time interval? Adjacent intervals do not count as overlapping unless `inclusive` is set to `true`.\n *\n * @param intervalLeft - The first interval to compare.\n * @param intervalRight - The second interval to compare.\n * @param options - The object with options\n *\n * @returns Whether the time intervals are overlapping\n *\n * @example\n * // For overlapping time intervals:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 17), end: new Date(2014, 0, 21) }\n * )\n * //=> true\n *\n * @example\n * // For non-overlapping time intervals:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 21), end: new Date(2014, 0, 22) }\n * )\n * //=> false\n *\n * @example\n * // For adjacent time intervals:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 30) }\n * )\n * //=> false\n *\n * @example\n * // Using the inclusive option:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) }\n * )\n * //=> false\n *\n * @example\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) },\n *   { inclusive: true }\n * )\n * //=> true\n */\nexport function areIntervalsOverlapping(\n  intervalLeft: Interval,\n  intervalRight: Interval,\n  options?: AreIntervalsOverlappingOptions,\n): boolean {\n  const [leftStartTime, leftEndTime] = [\n    +toDate(intervalLeft.start),\n    +toDate(intervalLeft.end),\n  ].sort((a, b) => a - b);\n  const [rightStartTime, rightEndTime] = [\n    +toDate(intervalRight.start),\n    +toDate(intervalRight.end),\n  ].sort((a, b) => a - b);\n\n  if (options?.inclusive)\n    return leftStartTime <= rightEndTime && rightStartTime <= leftEndTime;\n\n  return leftStartTime < rightEndTime && rightStartTime < leftEndTime;\n}\n"
      },
      {
        "role": "assistant",
        "content": "import { toDate } from \"../toDate/index.js\";\nimport type { Interval } from \"../types.js\";\n\n/**\n * The {@link areIntervalsOverlapping} function options.\n */\nexport interface AreIntervalsOverlappingOptions {\n  /** Whether the comparison is inclusive or not */\n  inclusive?: boolean;\n}\n\n/**\n * Sorts the start and end times of an interval in ascending order\n */\nfunction getSortedIntervalTimes(interval: Interval): [number, number] {\n  return [\n    +toDate(interval.start),\n    +toDate(interval.end),\n  ].sort((a, b) => a - b);\n}\n\n/**\n * Checks if two intervals are overlapping\n */\nfunction checkIfIntervalsOverlapping(\n  leftStartTime: number,\n  leftEndTime: number,\n  rightStartTime: number,\n  rightEndTime: number,\n): boolean {\n  return leftStartTime < rightEndTime && rightStartTime < leftEndTime;\n}\n\n/**\n * @name areIntervalsOverlapping\n * @category Interval Helpers\n * @summary Is the given time interval overlapping with another time interval?\n *\n * @description\n * Is the given time interval overlapping with another time interval? Adjacent intervals do not count as overlapping unless `inclusive` is set to `true`.\n *\n * @param intervalLeft - The first interval to compare.\n * @param intervalRight - The second interval to compare.\n * @param options - The object with options\n *\n * @returns Whether the time intervals are overlapping\n *\n * @example\n * // For overlapping time intervals:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 17), end: new Date(2014, 0, 21) }\n * )\n * //=> true\n *\n * @example\n * // For non-overlapping time intervals:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 21), end: new Date(2014, 0, 22) }\n * )\n * //=> false\n *\n * @example\n * // For adjacent time intervals:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 30) }\n * )\n * //=> false\n *\n * @example\n * // Using the inclusive option:\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) }\n * )\n * //=> false\n *\n * @example\n * areIntervalsOverlapping(\n *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },\n *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) },\n *   { inclusive: true }\n * )\n * //=> true\n */\nexport function areIntervalsOverlapping(\n  intervalLeft: Interval,\n  intervalRight: Interval,\n  options?: AreIntervalsOverlappingOptions,\n): boolean {\n  const [leftStartTime, leftEndTime] = getSortedIntervalTimes(intervalLeft);\n  const [rightStartTime, rightEndTime] = getSortedIntervalTimes(intervalRight);\n\n  if (options?.inclusive)\n    return checkIfIntervalsOverlapping(leftStartTime, leftEndTime, rightStartTime, rightEndTime);\n\n  return checkIfIntervalsOverlapping(leftStartTime, leftEndTime, rightStartTime, rightEndTime);\n}"
      },
      {
        "role": "user",
        "content": "Error: Command failed: npm run test\n\u001b[33mThe CJS build of Vite's Node API is deprecated. See https://vitejs.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated for more details.\u001b[39m\nstderr | "
      }
    ],
    [
      {
        "role": "user",
        "content": "Extract methods from the following code to enhance modularity and readability. Ensure each new method has a clear and distinct purpose. Do not introduce any breaking changes or alter the existing functionality. Provide the complete refactored code:\n/**\n * @module constants\n * @summary Useful constants\n * @description\n * Collection of useful date constants.\n *\n * The constants could be imported from `date-fns/constants`:\n *\n * ```ts\n * import { maxTime, minTime } from \"date-fns/constants\";\n *\n * function isAllowedTime(time) {\n *   return time <= maxTime && time >= minTime;\n * }\n * ```\n */\n\n/**\n * @constant\n * @name daysInWeek\n * @summary Days in 1 week.\n */\nexport const daysInWeek = 7;\n\n/**\n * @constant\n * @name daysInYear\n * @summary Days in 1 year.\n *\n * @description\n * How many days in a year.\n *\n * One years equals 365.2425 days according to the formula:\n *\n * > Leap year occurs every 4 years, except for years that are divisible by 100 and not divisible by 400.\n * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days\n */\nexport const daysInYear = 365.2425;\n\n/**\n * @constant\n * @name maxTime\n * @summary Maximum allowed time.\n *\n * @example\n * import { maxTime } from \"date-fns/constants\";\n *\n * const isValid = 8640000000000001 <= maxTime;\n * //=> false\n *\n * new Date(8640000000000001);\n * //=> Invalid Date\n */\nexport const maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;\n\n/**\n * @constant\n * @name minTime\n * @summary Minimum allowed time.\n *\n * @example\n * import { minTime } from \"date-fns/constants\";\n *\n * const isValid = -8640000000000001 >= minTime;\n * //=> false\n *\n * new Date(-8640000000000001)\n * //=> Invalid Date\n */\nexport const minTime = -maxTime;\n\n/**\n * @constant\n * @name millisecondsInWeek\n * @summary Milliseconds in 1 week.\n */\nexport const millisecondsInWeek = 604800000;\n\n/**\n * @constant\n * @name millisecondsInDay\n * @summary Milliseconds in 1 day.\n */\nexport const millisecondsInDay = 86400000;\n\n/**\n * @constant\n * @name millisecondsInMinute\n * @summary Milliseconds in 1 minute\n */\nexport const millisecondsInMinute = 60000;\n\n/**\n * @constant\n * @name millisecondsInHour\n * @summary Milliseconds in 1 hour\n */\nexport const millisecondsInHour = 3600000;\n\n/**\n * @constant\n * @name millisecondsInSecond\n * @summary Milliseconds in 1 second\n */\nexport const millisecondsInSecond = 1000;\n\n/**\n * @constant\n * @name minutesInYear\n * @summary Minutes in 1 year.\n */\nexport const minutesInYear = 525600;\n\n/**\n * @constant\n * @name minutesInMonth\n * @summary Minutes in 1 month.\n */\nexport const minutesInMonth = 43200;\n\n/**\n * @constant\n * @name minutesInDay\n * @summary Minutes in 1 day.\n */\nexport const minutesInDay = 1440;\n\n/**\n * @constant\n * @name minutesInHour\n * @summary Minutes in 1 hour.\n */\nexport const minutesInHour = 60;\n\n/**\n * @constant\n * @name monthsInQuarter\n * @summary Months in 1 quarter.\n */\nexport const monthsInQuarter = 3;\n\n/**\n * @constant\n * @name monthsInYear\n * @summary Months in 1 year.\n */\nexport const monthsInYear = 12;\n\n/**\n * @constant\n * @name quartersInYear\n * @summary Quarters in 1 year\n */\nexport const quartersInYear = 4;\n\n/**\n * @constant\n * @name secondsInHour\n * @summary Seconds in 1 hour.\n */\nexport const secondsInHour = 3600;\n\n/**\n * @constant\n * @name secondsInMinute\n * @summary Seconds in 1 minute.\n */\nexport const secondsInMinute = 60;\n\n/**\n * @constant\n * @name secondsInDay\n * @summary Seconds in 1 day.\n */\nexport const secondsInDay = secondsInHour * 24;\n\n/**\n * @constant\n * @name secondsInWeek\n * @summary Seconds in 1 week.\n */\nexport const secondsInWeek = secondsInDay * 7;\n\n/**\n * @constant\n * @name secondsInYear\n * @summary Seconds in 1 year.\n */\nexport const secondsInYear = secondsInDay * daysInYear;\n\n/**\n * @constant\n * @name secondsInMonth\n * @summary Seconds in 1 month\n */\nexport const secondsInMonth = secondsInYear / 12;\n\n/**\n * @constant\n * @name secondsInQuarter\n * @summary Seconds in 1 quarter.\n */\nexport const secondsInQuarter = secondsInMonth * 3;\n"
      },
      {
        "role": "assistant",
        "content": "const calculateDaysInYear = () => {\n  return 365.2425;\n};\n\nconst calculateMaxTime = () => {\n  return Math.pow(10, 8) * 24 * 60 * 60 * 1000;\n};\n\nconst calculateMinTime = () => {\n  return -calculateMaxTime();\n};\n\nconst calculateMillisecondsInWeek = () => {\n  return 604800000;\n};\n\nconst calculateMillisecondsInDay = () => {\n  return 86400000;\n};\n\nconst calculateMillisecondsInMinute = () => {\n  return 60000;\n};\n\nconst calculateMillisecondsInHour = () => {\n  return 3600000;\n};\n\nconst calculateMillisecondsInSecond = () => {\n  return 1000;\n};\n\nconst calculateMinutesInYear = () => {\n  return 525600;\n};\n\nconst calculateMinutesInMonth = () => {\n  return 43200;\n};\n\nconst calculateMinutesInDay = () => {\n  return 1440;\n};\n\nconst calculateMinutesInHour = () => {\n  return 60;\n};\n\nconst calculateSecondsInHour = () => {\n  return 3600;\n};\n\nconst calculateSecondsInMinute = () => {\n  return 60;\n};\n\nconst calculateSecondsInDay = () => {\n  return calculateSecondsInHour() * 24;\n};\n\nconst calculateSecondsInWeek = () => {\n  return calculateSecondsInDay() * 7;\n};\n\nconst calculateSecondsInYear = () => {\n  return calculateSecondsInDay() * calculateDaysInYear();\n};\n\nconst calculateSecondsInMonth = () => {\n  return calculateSecondsInYear() / 12;\n};\n\nconst calculateSecondsInQuarter = () => {\n  return calculateSecondsInMonth() * 3;\n};\n\nexport const daysInWeek = 7;\nexport const daysInYear = calculateDaysInYear();\nexport const maxTime = calculateMaxTime();\nexport const minTime = calculateMinTime();\nexport const millisecondsInWeek = calculateMillisecondsInWeek();\nexport const millisecondsInDay = calculateMillisecondsInDay();\nexport const millisecondsInMinute = calculateMillisecondsInMinute();\nexport const millisecondsInHour = calculateMillisecondsInHour();\nexport const millisecondsInSecond = calculateMillisecondsInSecond();\nexport const minutesInYear = calculateMinutesInYear();\nexport const minutesInMonth = calculateMinutesInMonth();\nexport const minutesInDay = calculateMinutesInDay();\nexport const minutesInHour = calculateMinutesInHour();\nexport const secondsInHour = calculateSecondsInHour();\nexport const secondsInMinute = calculateSecondsInMinute();\nexport const secondsInDay = calculateSecondsInDay();\nexport const secondsInWeek = calculateSecondsInWeek();\nexport const secondsInYear = calculateSecondsInYear();\nexport const secondsInMonth = calculateSecondsInMonth();\nexport const secondsInQuarter = calculateSecondsInQuarter();"
      },
      {
        "role": "user",
        "content": "Error: Command failed: npm run test\n\u001b[33mThe CJS build of Vite's Node API is deprecated. See https://vitejs.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated for more details.\u001b[39m\nstderr | "
      }
    ]
  ]
}